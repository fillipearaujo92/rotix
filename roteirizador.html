

<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Roday - Otimizador de Rotas</title>
  <link rel="icon" type="image/png" href="img/favicon.png">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
    
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"/>
  <script>
    tailwind.config = {
      darkMode: 'class'
    }
  </script>

  <style>
    :root { --Roday-blue: #5e33ea; }

    @import url('https://fonts.googleapis.com/css2?family=Rubik:ital,wght@0,600;1,600&display=swap');
    
    #map { height: 100vh; }
    .leaflet-control-zoom, .leaflet-control-attribution { display: none !important; }
    .leaflet-popup-content-wrapper { border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
    .dark .leaflet-popup-content-wrapper {background: #2d3748; }
    .leaflet-popup-content { margin: 15px; font-size: 14px; line-height: 1.6; }
    .leaflet-popup-content b { font-weight: 600; }
    .leaflet-popup-content small { color: #555; }
    .leaflet-popup-tip { box-shadow: none; }

    .toast {
      position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.85);
      backdrop-filter: blur(5px);
      color: #141414; padding: 12px 20px; border-radius: 25px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2); z-index: 10001;
      display: none; align-items: center;
      z-index: 9999;
    }
    .dark .toast {
      background: #2d3748; 
      color: white;
    }
    .toast.show { display: flex; animation: fadeIn 0.3s ease; }
    @keyframes fadeIn { from { opacity: 0; transform: translate(-50%, -20px); } to { opacity: 1; transform: translate(-50%, 0); } }

    .map-floating-btn {
      position: fixed; z-index: 1000; background-color: white;
      width: 48px; height: 48px; border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2); cursor: pointer;
      transition: all 0.2s ease;
    }

    .dark .map-floating-btn {
      background-color: #2d3748; /* cinza escuro */
      color: #f7fafc;            /* texto claro */
    }

    .dark #menuToggleBtn {
      background-color: #4F45E4; /* cinza escuro */
      color: #f7fafc;            /* texto claro */
    }

    .map-floating-btn:hover { transform: scale(1.05); }
    #menuToggleBtn { top: 20px; left: 20px; box-shadow: 5px 5px 20px rgba(0,0,0,0.5); cursor: pointer;}
    #settingsBtn { bottom: 250px; right: 20px; border: 3px solid white; box-shadow: 5px 5px 20px rgba(0,0,0,0.5); cursor: pointer; }    
    #reOptimizeBtn { bottom: 430px; right: 20px; border: 3px solid white; box-shadow: 5px 5px 20px rgba(0,0,0,0.5); cursor: pointer;}
    #centerUserBtn { bottom: 370px; right: 20px; border: 3px solid white; box-shadow: 5px 5px 20px rgba(0,0,0,0.5); cursor: pointer;}
    #fullscreenBtn { bottom: 310px; right: 20px; border: 3px solid white; box-shadow: 5px 5px 20px rgba(0,0,0,0.5); cursor: pointer; }
    #themeToggleBtn { bottom: 250px; right: 20px; border: 3px solid white; box-shadow: 5px 5px 20px rgba(0,0,0,0.5); cursor: pointer; }

    #sideMenu {
        z-index: 9999;
        box-shadow: 6px 0px 20px 0px #0000008a;
        scrollbar-width: none;
    }

    #menuOverlay {background: #141414;}

    /* Estilos para o Modal de Progresso */
    #progressModal.hidden {
      display: none;
    }

    /* Animação do Spinner (Loader) */
    .loader {
      border: 5px solid #f3f3f3; /* Cinza claro */
      border-top: 5px solid #5e33ea; /* Roxo Roday */
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Classes específicas para o Sortable */
    .sortable-chosen {
        transform: scale(1.05) rotate(2deg) !important;
        z-index: 1000;
        box-shadow: 0 8px 25px rgba(0,0,0,0.3);
    }

    .sortable-ghost {
        opacity: 0.4 !important;
        background: #f3f4f6 !important;
        border: 2px dashed #d1d5db !important;
    }

    .sortable-drag {
        transform: rotate(5deg) !important;
        box-shadow: 0 10px 30px rgba(0,0,0,0.4) !important;
    }

    .route-item {
      position: relative;
      transition: transform 0.2s ease, background-color 0.2s ease, border-color 0.2s ease;
      touch-action: pan-y;
      user-select: none;
      overflow: visible;
    }

    .route-item:hover {
        transform: translateY(-2px);
    }

    .delete-button {
        transition: opacity 0.2s ease !important;
    }

    .delete-button:hover {
        background: #dc2626 !important;
        transform: translateY(-50%) scale(1.1) !important;
    }

  </style>
</head>
<body class="bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-white">

  <!-- Toast Notification -->
  <div id="toast" class="toast">
    <i id="toastIcon" class="fas fa-info-circle mr-3"></i>
    <span id="toastMessage"></span>
  </div>

  <!-- Modal de Progresso da Otimização -->
    <div id="progressModal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-[9999] flex items-center justify-center">
        <div class="bg-white dark:bg-gray-800 rounded-2xl shadow-lg p-8 flex flex-col items-center space-y-4 w-64">
            <div class="loader"></div>
            <h3 class="text-gray-700 font-semibold text-lg dark:text-white">Otimizando Rota...</h3>
            <p id="progressText" class="text-gray-500 text-sm dark:text-white">Calculando distâncias...</p>
        </div>
    </div>

    <div id="confirmModal" class="hidden fixed inset-0 bg-black bg-opacity-60 z-[9999] flex items-center justify-center p-4">
    <div class="bg-white dark:bg-gray-800 rounded-2xl shadow-lg p-6 flex flex-col w-full max-w-sm">
        <div class="flex items-center mb-4">
        <!--<i class="fas fa-exclamation-triangle text-yellow-500 text-2xl mr-4"></i>-->
        <h3 id="confirmTitle" class="text-gray-800 font-bold text-lg dark:text-white">Atenção</h3>
        </div>
        <p id="confirmMessage" class="text-gray-600 text-sm mb-6 dark:text-white">Deseja continuar com esta ação?</p>
        <div class="flex justify-end space-x-3">
        <button id="confirmCancelBtn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-semibold py-2 px-5 rounded-lg transition-colors">Cancelar</button>
        <button id="confirmOkBtn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-5 rounded-lg transition-colors">OK</button>
        </div>
    </div>
    </div>

  <!-- Botões Flutuantes do Mapa -->
  <button id="menuToggleBtn" class="map-floating-btn hidden">
    <i class="fas fa-bars text-xl text-gray-600 dark:text-white"></i>
  </button>
  <button id="settingsBtn" class="map-floating-btn hidden" title="Configurações">
    <i class="fas fa-cog text-xl dark:text-white"></i>
  </button>
  <button id="centerUserBtn" class="map-floating-btn hidden">
    <i class="fas fa-location-crosshairs text-xl text-sky-600 dark:text-white"></i>
  </button>
  <button id="reOptimizeBtn" class="map-floating-btn hidden" title="Reotimizar Rota a partir da sua localização">
    <i class="fas fa-route text-xl text-green-600 dark:text-white"></i>
  </button>
  <button id="fullscreenBtn" class="map-floating-btn hidden" title="Tela Cheia">
    <i class="fas fa-expand text-xl text-sky-600 dark:text-white"></i>
  </button>
  <!--<button id="themeToggleBtn" class="map-floating-btn hidden" title="Alternar Tema">
    <i class="fas fa-sun text-xl text-yellow-500 dark:text-white"></i>
  </button> -->

  <!-- NOVO: Modal de Configurações -->
  <div id="settingsModal" class="hidden fixed inset-0 bg-black bg-opacity-60 z-[9999] flex items-center justify-center p-4">
      <div class="bg-white dark:bg-gray-800 rounded-2xl shadow-lg p-6 flex flex-col w-full max-w-md">
          <div class="flex justify-between items-center mb-6">
              <h3 class="text-gray-800 font-bold text-lg dark:text-white"><i class="fas fa-cog mr-2"></i>Configurações</h3>
              <button id="closeSettingsBtn" class="text-gray-500 hover:text-red-500"><i class="fas fa-times text-xl"></i></button>
          </div>

          <div class="space-y-6">
              <!-- Seção de Navegação -->
              <div>
                  <label for="navAppSelect" class="block text-sm font-medium text-gray-700 dark:text-gray-300">Aplicativo de Navegação Padrão</label>
                  <select id="navAppSelect" class="mt-1 block w-full p-2 border border-gray-300 dark:bg-gray-700 dark:border-gray-600 rounded-md shadow-sm">
                      <option value="google">Google Maps</option>
                      <option value="waze">Waze</option>
                      <option value="apple">Apple Maps (somente iOS)</option>
                  </select>
                  <p class="text-xs text-gray-500 mt-1">O aplicativo será aberto ao clicar em "Navegar".</p>
              </div>

              <!-- Seção de Zoom Automático -->
              <div>
                  <label class="block text-sm font-medium text-gray-700 dark:text-gray-300">Zoom Automático</label>
                  <div class="flex items-center mt-2">
                      <input id="autoZoomToggle" type="checkbox" class="h-4 w-4 text-indigo-600 border-gray-300 rounded" checked>
                      <label for="autoZoomToggle" class="ml-2 block text-sm text-gray-900 dark:text-gray-200">Aproximar mapa ao chegar perto do destino</label>
                  </div>
              </div>
              
            <fieldset class="border-t border-gray-200 dark:border-gray-700 pt-4">
                <legend class="text-sm font-semibold text-gray-900 dark:text-gray-200">Comportamento da Rota</legend>
                
                <div class="mt-4 space-y-4">
                  <div class="flex items-center justify-between">
                        <span class="text-sm font-medium text-gray-700 dark:text-gray-300">Retornar ao Ponto Inicial</span>
                        <button id="returnToStartToggle" type="button" class="relative inline-flex h-6 w-11 flex-shrink-0 cursor-pointer rounded-full border-2 border-transparent transition-colors duration-200 ease-in-out focus:outline-none bg-gray-200" role="switch" aria-checked="false">
                            <span class="sr-only">Ativar retorno ao ponto inicial</span>
                            <span aria-hidden="true" class="pointer-events-none inline-block h-5 w-5 transform rounded-full bg-white shadow ring-0 transition duration-200 ease-in-out translate-x-0"></span>
                        </button>
                    </div>
                    <p class="text-xs text-gray-500 mt-1">Se ativado, a rota será otimizada para terminar na parada mais próxima do seu ponto de partida.</p>
                    <div id="endPointAddressContainer" class="hidden pl-4 border-l-2 border-indigo-200">
                        <label for="endAddress" class="block text-xs font-medium text-gray-500 dark:text-gray-400">Endereço de Término</label>
                        <textarea id="endAddress" placeholder="Digite o endereço de término" class="mt-1 w-full p-2 border border-gray-300 dark:bg-gray-700 dark:border-gray-600 rounded-md text-sm" rows="2"></textarea>
                        <button id="geocodeEndBtn" class="mt-2 w-full bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded text-sm"><i class="fas fa-search mr-1"></i>Buscar Endereço</button>
                    </div>
                </div>
            </fieldset>

            <!-- Seção de Interface e Experiência -->
            <div class="border-t border-gray-200 dark:border-gray-700 pt-4">
                <legend class="text-sm font-semibold text-gray-900 dark:text-gray-200">Interface e Experiência</legend>

                <div class="mt-4 space-y-4">
                  <div>
                <label class="block text-sm font-medium text-gray-700 dark:text-gray-300">Tema da Interface</label>
                <div class="mt-2 flex items-center justify-between p-3 rounded-lg">
                    <span class="text-gray-800 dark:text-gray-200">Modo Escuro</span>
                    <button id="themeToggleSwitch" type="button" class="relative inline-flex h-6 w-11 flex-shrink-0 cursor-pointer rounded-full border-2 border-transparent transition-colors duration-200 ease-in-out focus:outline-none bg-gray-200 dark:bg-indigo-600" role="switch" aria-checked="false">
                        <span class="sr-only">Use setting</span>
                        <span aria-hidden="true" class="pointer-events-none inline-block h-5 w-5 transform rounded-full bg-white shadow ring-0 transition duration-200 ease-in-out translate-x-0 dark:translate-x-5"></span>
                    </button>
                </div>
            </div>
                    
                </div>
              </div>
          </div>
      </div>
  </div>

  <!-- Menu Lateral -->
  <div id="menuOverlay" class="hidden fixed inset-0 bg-black bg-opacity-40 z-40"></div>
  <div id="sideMenu" class="hidden dark:bg-gray-800 fixed top-0 left-0 w-full max-w-sm h-full bg-white z-5000 p-6 overflow-y-auto transform -translate-x-full transition-transform duration-300">
    
    <div class="flex justify-between items-center mb-6">
      <h4 class="font-semibold text-gray-800 dark:text-white text-lg"><i class="fa-solid fa-bars"></i> Menu</h4>
      <button id="closeMenuBtn" class="text-gray-500 hover:text-red-500"><i class="fas fa-times text-xl"></i></button>
    </div>
    
    <div class="mb-6 p-4 bg-red-50 dark:bg-red-900 border-red-300 dark:border-red-700 border border-red-200 rounded-lg">
      <h5 class="font-medium text-red-800 mb-2 dark:text-white"><i class="fas fa-exclamation-triangle mr-2"></i>Recomeçar Rota</h5>
      <p class="text-sm dark:text-white text-red-600 mb-3">Isso apagará a rota atual e voltará ao início.</p>
      <button id="loadNewFileBtn" class="w-full bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-lg font-medium transition"><i class="fas fa-file-upload mr-2"></i>Carregar Novo Arquivo</button>
    </div>

    <!-- SEÇÃO DE CONFIGURAÇÕES DE ROTA FOI REMOVIDA -->
    <div class="mb-6 p-4 rounded-lg border 
            bg-indigo-50 border-indigo-200 text-indigo-700
            dark:bg-gray-800 dark:border-gray-700 dark:text-gray-100">
      <h5 class="font-medium mb-2 text-indigo-800 dark:text-indigo-300">
        <i class="fas fa-chart-bar mr-2"></i>Estatísticas
      </h5>
      <div id="routeStats" class="text-sm"></div>
    </div>
    
    <div class="flex justify-between items-center mb-6">
      <h4 class="font-semibold text-gray-800 dark:text-white text-lg"><i class="fa-regular fa-rectangle-list"></i> Lista de Entregas</h4>
    </div>

    <div id="routeList"></div>
  </div>

  <!-- Etapa 1: Upload -->
  <div id="step1" class="flex-1 flex flex-col items-center justify-center p-6 min-h-screen">
    <div class="bg-white dark:bg-gray-800 rounded-2xl shadow-lg p-10 w-full max-w-md text-center">
      <div class="w-20 h-20 mx-auto mb-6 bg-gradient-to-br from-[var(--Roday-blue)] to-purple-800 rounded-3xl flex items-center justify-center">
        <img src="img/logo.svg" width="45">
        </div>
      <h1 class="text-4xl font-bold tracking-widest text-gray-800 dark:text-white font-logo">Roday</h1>
      <h3 class="text-xs tracking-widest text-gray-500 dark:text-white mb-8">Inteligência em movimento</h3>
      <label for="fileInput" class="cursor-pointer block border-2 border-dashed border-indigo-400 rounded-xl p-10 hover:bg-indigo-50 transition">
        <i class="fas fa-file-excel text-4xl text-indigo-500 mb-4 block"></i>
        <span class="text-indigo-600 font-semibold">Clique ou arraste seu arquivo</span>
        <input type="file" id="fileInput" accept=".xlsx,.xls" class="hidden"/>
      </label>
    </div>
  </div>

  <!-- Etapa 2: Seleção de Colunas (Versão Simplificada) -->
  <div id="step2" class="hidden flex-1 flex flex-col items-center justify-center p-6 min-h-screen">
      <div class="bg-white rounded-2xl shadow-lg p-8 w-full max-w-md dark:bg-gray-800">
          <h2 class="text-xl font-bold text-indigo-600 mb-2 dark:text-white"><i class="fas fa-list-check mr-2"></i>Informações Adicionais</h2>
          <p class="text-gray-500 mb-6 text-sm dark:text-white">Escolha os campos que deseja visualizar nos detalhes da entrega.</p>
          
          <div id="columnsList" class="space-y-3 mb-6 max-h-60 overflow-y-auto p-4 bg-gray-50 rounded-lg dark:bg-gray-800">
              <!-- As checkboxes serão populadas via JavaScript -->
          </div>

          <button id="confirmColumnsBtn" class="w-full bg-indigo-600 text-white py-3 rounded-lg font-semibold hover:bg-indigo-700 transition">
              <i class="fas fa-check mr-2"></i>Confirmar e Otimizar
          </button>
      </div>
  </div>

  <!-- Etapa 3: Mapa -->
  <div id="step3" class="hidden">
    <div id="map"></div>
    <div id="nextStopBar" class="hidden dark:bg-gray-800 dark:text-white fixed bottom-0 left-0 right-0 bg-white shadow-[0_-5px_20px_rgba(0,0,0,0.1)] rounded-t-2xl z-[1001] p-4">
        <div class="w-full max-w-4xl mx-auto">
            <div class="flex justify-between items-start mb-3 dark:text-white">
            <div id="nextStopInfo" class="text-gray-800 mr-4"></div>
            </div>
            <!-- MODIFICAÇÃO: grid-cols-3 para grid-cols-4 e adição do botão Pendente -->
            <div class="grid grid-cols-4 gap-2">
                <button onclick="openNavigation()" class="col-span-1 bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center text-xs dark:bg-gray-800 dark:text-white dark:border-2 dark:border-solid dark:border-indigo-600 dark:hover:bg-indigo-900">
                  <i class="fas fa-diamond-turn-right mr-2 dark:text-indigo-500"></i>Navegar</button>
                
                <button id="entregueBtn" onclick="markNext('entregue')" class="col-span-1 bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-3 px-4 rounded-lg flex items-center justify-center text-xs dark:bg-gray-800 dark:text-white dark:border-2 dark:border-solid dark:border-green-600 dark:hover:bg-green-900">
                    <i class="fas fa-check-double mr-2 text-green-500"></i>
                    <span id="entregueText">Entregue</span>
                </button>

                <button id="naoEntregueBtn" onclick="markNext('naoentregue')" class="col-span-1 bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-3 px-4 rounded-lg flex items-center justify-center text-xs dark:bg-gray-800 dark:text-white dark:border-2 dark:border-solid dark:border-red-600 dark:hover:bg-red-900">
                    <i class="fas fa-box mr-2 text-red-500"></i>
                    <span id="naoEntregueText">Não Entregue</span>
                </button>
                
                <button onclick="markNext('pendente')" class="col-span-1 bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-3 px-4 rounded-lg flex items-center justify-center text-xs dark:bg-gray-800 dark:text-white dark:border-2 dark:border-solid dark:border-yellow-600 dark:hover:bg-yellow-900">
                    <i class="fas fa-clock mr-2 text-yellow-500"></i>
                    <span id="pendenteText">Pendente</span>
                </button>
            </div>
        </div>
    </div>

  </div>

<script>
// =================================================================================
// VARIÁVEIS GLOBAIS
// =================================================================================
let deliveryData = [], userLocation = null, map, markers = [], routeLayer, nextDeliveryRouteLayer, userMarker;
let selectedColumns = [];
let startPoint = null;
let endPoint = null;
let isRouteOptimized = false;
let markerClusterGroup;
let mapTileLayer;

const iconMapping = {
  'cliente': 'fa-user',
  'telefone': 'fa-phone',
  'stop': 'fa-hashtag',
  'sequence': 'fa-list-ol',
  'tn': 'fa-barcode',
  'cod': 'fa-barcode',
  'cep': 'fa-street-view',
  'Zipcode/Postal code': 'fa-street-view',
  'Postal': 'fa-street-view',
  'observação': 'fa-comment-dots',
  'obs': 'fa-comment-dots',
  'default': 'fa-info-circle'
};

// =================================================================================
// INICIALIZAÇÃO E GERENCIAMENTO DE ESTADO
// =================================================================================
window.addEventListener('load', () => {
  loadSavedState();
  initGeolocation();
});

function saveState() {
  try {
    const stateToSave = {
      deliveryData: deliveryData,
      selectedColumns: selectedColumns,
      startPoint: startPoint,
      endPoint: endPoint,
      currentStep: getCurrentStep(),
      isRouteOptimized: isRouteOptimized // <-- ADICIONAR ESTA LINHA
    };
    localStorage.setItem('routeOptimizerState', JSON.stringify(stateToSave));
  } catch (e) { console.error('Erro ao salvar estado:', e); }
}

async function loadSavedState() { // <-- TORNAR A FUNÇÃO ASYNC
  const savedState = localStorage.getItem('routeOptimizerState');
  if (!savedState) return;
  try {
    const state = JSON.parse(savedState);
    if (state.currentStep === 'step3' && state.deliveryData?.length > 0) {
      deliveryData = state.deliveryData;
      selectedColumns = state.selectedColumns || [];
      startPoint = state.startPoint;
      endPoint = state.endPoint;
      isRouteOptimized = state.isRouteOptimized || false; // <-- RESTAURAR O ESTADO DE OTIMIZAÇÃO

      document.getElementById('step1').classList.add('hidden');
      document.getElementById('step3').classList.remove('hidden');
      
      showMapControls(true);
      await initGeolocation(); // Espera a geolocalização para ter o userLocation
      initMap();

      // --- SOLUÇÃO: DESENHA A ROTA COMPLETA AO RECARREGAR ---
      if (isRouteOptimized) {
        if (routeLayer) map.removeLayer(routeLayer);
        const allPoints = deliveryData.map(d => ({ lat: +d.Latitude, lng: +d.Longitude }));
        if (userLocation) allPoints.unshift(userLocation); // Adiciona a localização atual ao traçado
        
        routeLayer = await drawRoute(allPoints, { style: { color: "#5e33ea", weight: 5, opacity: 0.7 } });
        if (routeLayer) {
          routeLayer.addTo(map);
          // Ajusta o zoom para a rota completa
          setTimeout(() => map.fitBounds(routeLayer.getBounds(), { padding: [50, 50] }), 500);
        }
      }
      // --- FIM DA SOLUÇÃO ---

      updateUI();
      startTracking();
      showToast('Rota anterior restaurada!', 'success');
    }
  } catch (e) {
    console.error('Erro ao carregar estado:', e);
    clearState();
  }
}

function clearState() {
  localStorage.removeItem('routeOptimizerState');
  window.location.reload();
}

function getCurrentStep() {
  if (!document.getElementById('step1').classList.contains('hidden')) return 'step1';
  if (!document.getElementById('step2').classList.contains('hidden')) return 'step2';
  if (!document.getElementById('step3').classList.contains('hidden')) return 'step3';
  return null;
}

// =================================================================================
// UPLOAD DE ARQUIVO E PREPARAÇÃO
// =================================================================================
document.getElementById('fileInput').addEventListener('change', handleFileUpload);

async function handleFileUpload(e) {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = async (event) => { // <-- Tornar a função async
    try {
      const data = new Uint8Array(event.target.result);
      const workbook = XLSX.read(data, { type: 'array' });
      const sheetName = workbook.SheetNames[0];
      const worksheet = workbook.Sheets[sheetName];
      const jsonData = XLSX.utils.sheet_to_json(worksheet);

      if (jsonData.length === 0) return showToast('Arquivo vazio ou formato inválido', 'error');

      const headers = Object.keys(jsonData[0]);
      const findHeader = (keys) => headers.find(h => keys.some(key => h.toLowerCase().includes(key)));

      let latHeader = findHeader(['lat', 'latitude']);
      let lngHeader = findHeader(['lon', 'lng', 'longitude']);
      const addressHeader = findHeader(['address', 'endereço', 'rua']);
      const districtHeader = findHeader(['bairro']);
      const cityHeader = findHeader(['cidade']);

      // Se não houver lat/lng, mas houver endereço, prepara para geocodificação
      if ((!latHeader || !lngHeader) && addressHeader) {
        showProgressModal('Iniciando geocodificação...', 0);
        await delay(50);

        for (let i = 0; i < jsonData.length; i++) {
          const row = jsonData[i];
          const fullAddress = [row[addressHeader], row[districtHeader], row[cityHeader]].filter(Boolean).join(', ');
          
          const progress = ((i + 1) / jsonData.length) * 100;
          showProgressModal(`Buscando coordenadas para: ${fullAddress}`, progress);
          
          const coords = await geocodeAddress(fullAddress);
          if (coords) {
            row.Latitude = coords.lat;
            row.Longitude = coords.lng;
          } else {
            row.Latitude = null;
            row.Longitude = null;
            console.warn(`Geocodificação falhou para: ${fullAddress}`);
          }
          await delay(200); // Delay para não sobrecarregar a API de geocodificação
        }
        
        hideProgressModal();
        // Define os novos headers de lat/lng
        latHeader = 'Latitude';
        lngHeader = 'Longitude';
      }

      // Validação final
      if (!latHeader || !lngHeader) {
        return showToast('Erro: Não foi possível determinar a Latitude e Longitude das entregas.', 'error');
      }

      // Processa os dados finais
      deliveryData = jsonData
        .filter(row => row[latHeader] && row[lngHeader]) // Filtra entregas que não puderam ser geocodificadas
        .map((row, index) => ({
          ...row,
          Latitude: row[latHeader],
          Longitude: row[lngHeader],
          Endereço: addressHeader ? row[addressHeader] : 'Endereço não fornecido',
          STOP: findHeader(['stop']) ? row[findHeader(['stop'])] : index + 1,
          id: index,
          status: "pendente",
        }));

      if(deliveryData.length === 0) {
        return showToast('Nenhuma entrega pôde ser localizada. Verifique os endereços.', 'error');
      }

      // Prepara a lista de colunas para seleção
      const processedHeaders = [latHeader, lngHeader, addressHeader].filter(Boolean);
      const cols = headers.filter(h => !processedHeaders.includes(h));
      
      const container = document.getElementById("columnsList");
      container.innerHTML = cols.map(c => `
        <label class="flex items-center space-x-3 cursor-pointer hover:bg-gray-50 dark:hover:bg-indigo-600 p-2 rounded-lg">
          <input type="checkbox" value="${c}" class="columnChk h-5 w-5 text-indigo-600 border-gray-300 rounded" ${['cliente', 'telefone', 'obs', 'stop', 'sequence'].some(kw => c.toLowerCase().includes(kw)) ? 'checked' : ''}/>
          <span class="text-gray-700 dark:text-white">${c}</span>
        </label>`).join('');

      document.getElementById('step1').classList.add('hidden');
      document.getElementById('step2').classList.remove('hidden');
      showToast(`${deliveryData.length} entregas carregadas e localizadas!`, 'success');

    } catch (error) {
      console.error('Erro ao processar arquivo:', error);
      showToast('Erro fatal ao processar o arquivo.', 'error');
      hideProgressModal();
    }
  };
  reader.readAsArrayBuffer(file);
}

// Substitua o listener do 'confirmMappingBtn' por este
document.getElementById('confirmColumnsBtn')?.addEventListener('click', () => {
  selectedColumns = [...document.querySelectorAll(".columnChk:checked")].map(c => c.value);
  document.getElementById('step2').classList.add('hidden');
  document.getElementById('step3').classList.remove('hidden');
  
  showMapControls(true);
  initMap();
  optimizeRoute();
});

// =================================================================================
// GEOLOCALIZAÇÃO E GEOCODIFICAÇÃO (Nominatim/OSM)
// =================================================================================
function initGeolocation() {
  return new Promise((resolve) => {
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        pos => { 
          userLocation = { lat: pos.coords.latitude, lng: pos.coords.longitude };
          resolve();
        },
        () => { 
            userLocation = { lat: -3.73186, lng: -38.5267 }; // Fallback
            showToast('Usando localização padrão. Permita o acesso para maior precisão.', 'warn');
            resolve();
        }
      );
    } else {
      userLocation = { lat: -3.73186, lng: -38.5267 }; // Fallback
      showToast('Geolocalização não suportada por este navegador.', 'error');
      resolve();
    }
  });
}

async function geocodeAddress(address) {
  if (!address) return null;
  try {
    const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address )}&countrycodes=br&limit=1`);
    const data = await response.json();
    if (data && data.length > 0) {
      return { lat: parseFloat(data[0].lat), lng: parseFloat(data[0].lon), address: data[0].display_name };
    }
    return null;
  } catch (error) {
    console.error('Erro na geocodificação:', error);
    return null;
  }
}

// =================================================================================
// OTIMIZAÇÃO RÁPIDA E INTELIGENTE (HÍBRIDA)
// =================================================================================

// Cache otimizado para distâncias
let fastDistanceCache = new Map();

// Função rápida que usa haversine primeiro e OSRM apenas quando necessário
async function getSmartDistance(point1, point2, useRealRoute = false) {
    const key = `${point1.lat.toFixed(6)},${point1.lng.toFixed(6)}-${point2.lat.toFixed(6)},${point2.lng.toFixed(6)}`;
    
    if (fastDistanceCache.has(key)) {
        return fastDistanceCache.get(key);
    }
    
    let distance;
    
    if (useRealRoute) {
        // Usa OSRM apenas quando solicitado
        try {
            const coords = `${point1.lng},${point1.lat};${point2.lng},${point2.lat}`;
            const url = `https://router.project-osrm.org/route/v1/driving/${coords}?overview=false`;
            const response = await fetch(url);
            
            if (response.ok) {
                const data = await response.json();
                if (data.routes && data.routes.length > 0) {
                    distance = data.routes[0].distance / 1000;
                } else {
                    distance = haversine(point1, point2);
                }
            } else {
                distance = haversine(point1, point2);
            }
        } catch (error) {
            distance = haversine(point1, point2);
        }
    } else {
        // Usa haversine (muito mais rápido)
        distance = haversine(point1, point2);
    }
    
    fastDistanceCache.set(key, distance);
    return distance;
}

// Algoritmo de otimização rápido e inteligente
async function fastOptimizeRoute(route, startPoint) {
    const totalStops = route.length;
    
    // FASE 1: Rota inicial rápida usando haversine
    showProgressModal('Criando rota inicial rápida...', 10);
    await delay(20);
    
    let optimizedRoute = [];
    let remaining = [...route];
    let currentPoint = startPoint;
    
    // Algoritmo guloso rápido
    while (remaining.length > 0) {
        let nearestIndex = 0;
        let minDistance = Infinity;
        
        for (let i = 0; i < remaining.length; i++) {
            const distance = await getSmartDistance(currentPoint, {
                lat: remaining[i].Latitude,
                lng: remaining[i].Longitude
            }, false); // Usa haversine (rápido)
            
            if (distance < minDistance) {
                minDistance = distance;
                nearestIndex = i;
            }
        }
        
        const nextStop = remaining.splice(nearestIndex, 1)[0];
        optimizedRoute.push(nextStop);
        currentPoint = { lat: nextStop.Latitude, lng: nextStop.Longitude };
        
        const progress = 10 + ((totalStops - remaining.length) / totalStops) * 40;
        showProgressModal(`Rota inicial: ${totalStops - remaining.length}/${totalStops}`, progress);
        await delay(5);
    }
    
    // FASE 2: Refinamento 2-opt rápido (apenas algumas iterações)
    showProgressModal('Refinando rota...', 50);
    await delay(20);
    
    let improved = true;
    let iterations = 0;
    const maxIterations = Math.min(10, Math.floor(totalStops / 8)); // Limita iterações
    
    while (improved && iterations < maxIterations) {
        improved = false;
        
        // Testa apenas algumas trocas por iteração para ser mais rápido
        const step = Math.max(1, Math.floor(optimizedRoute.length / 20));
        
        for (let i = 0; i < optimizedRoute.length - 1; i += step) {
            for (let j = i + step; j < optimizedRoute.length; j += step) {
                const current_i = i;
                const next_i = (i + 1) % optimizedRoute.length;
                const current_j = j;
                const next_j = (j + 1) % optimizedRoute.length;
                
                const currentDistance = 
                    await getSmartDistance({lat: optimizedRoute[current_i].Latitude, lng: optimizedRoute[current_i].Longitude}, 
                                         {lat: optimizedRoute[next_i].Latitude, lng: optimizedRoute[next_i].Longitude}, false) +
                    await getSmartDistance({lat: optimizedRoute[current_j].Latitude, lng: optimizedRoute[current_j].Longitude}, 
                                         {lat: optimizedRoute[next_j].Latitude, lng: optimizedRoute[next_j].Longitude}, false);
                
                const newDistance = 
                    await getSmartDistance({lat: optimizedRoute[current_i].Latitude, lng: optimizedRoute[current_i].Longitude}, 
                                         {lat: optimizedRoute[current_j].Latitude, lng: optimizedRoute[current_j].Longitude}, false) +
                    await getSmartDistance({lat: optimizedRoute[next_i].Latitude, lng: optimizedRoute[next_i].Longitude}, 
                                         {lat: optimizedRoute[next_j].Latitude, lng: optimizedRoute[next_j].Longitude}, false);
                
                if (newDistance < currentDistance) {
                    optimizedRoute = twoOptSwap(optimizedRoute, i + 1, j);
                    improved = true;
                }
            }
        }
        
        iterations++;
        const progress = 50 + (iterations / maxIterations) * 40;
        showProgressModal(`Refinando... (${iterations}/${maxIterations})`, progress);
        await delay(10);
    }
    
    return optimizedRoute;
}

// =================================================================================
// OTIMIZAÇÃO MELHORADA - SUBSTITUA AS FUNÇÕES EXISTENTES
// =================================================================================

const delay = ms => new Promise(res => setTimeout(res, ms));

// Algoritmo específico para circuito (TSP - Traveling Salesman Problem)
async function optimizeCircuitRoute(route, startPoint) {
  const totalStops = route.length;
  
  if (totalStops <= 2) return route;
  
  showProgressModal('Otimizando circuito completo...', 5);
  await delay(50);
  
  // 1. Encontrar a primeira parada (mais próxima do início)
  let firstStopIndex = 0;
  let minDistanceToStart = Infinity;
  
  for (let i = 0; i < route.length; i++) {
    const distance = getDistance(startPoint, {
      lat: route[i].Latitude,
      lng: route[i].Longitude
    });
    if (distance < minDistanceToStart) {
      minDistanceToStart = distance;
      firstStopIndex = i;
    }
  }
  
  const firstStop = route[firstStopIndex];
  let remainingStops = route.filter((_, index) => index !== firstStopIndex);
  
  showProgressModal('Primeira parada definida...', 15);
  await delay(50);
  
  // 2. Construir o circuito usando algoritmo de inserção mais próxima
  let circuitRoute = [firstStop];
  
  while (remainingStops.length > 0) {
    let bestInsertPosition = -1;
    let bestStopIndex = -1;
    let minIncreaseDistance = Infinity;
    
    // Para cada parada restante
    for (let stopIndex = 0; stopIndex < remainingStops.length; stopIndex++) {
      const candidateStop = remainingStops[stopIndex];
      
      // Testa inserir em cada posição possível do circuito
      for (let insertPos = 0; insertPos <= circuitRoute.length; insertPos++) {
        const increasedDistance = calculateInsertionCost(
          circuitRoute, candidateStop, insertPos, startPoint
        );
        
        if (increasedDistance < minIncreaseDistance) {
          minIncreaseDistance = increasedDistance;
          bestInsertPosition = insertPos;
          bestStopIndex = stopIndex;
        }
      }
    }
    
    // Insere a melhor parada na melhor posição
    const bestStop = remainingStops.splice(bestStopIndex, 1)[0];
    circuitRoute.splice(bestInsertPosition, 0, bestStop);
    
    const progress = 15 + ((totalStops - remainingStops.length) / totalStops) * 60;
    showProgressModal(`Construindo circuito: ${totalStops - remainingStops.length}/${totalStops}`, progress);
    await delay(30);
  }
  
  showProgressModal('Otimizando circuito com 2-Opt...', 75);
  await delay(50);
  
  // 3. Refinamento com 2-Opt específico para circuito
  circuitRoute = await circuitTwoOpt(circuitRoute, startPoint);
  
  showProgressModal('Verificando última parada...', 90);
  await delay(50);
  
  // 4. Otimização final: garantir que a última parada seja ótima para retorno
  circuitRoute = optimizeLastStop(circuitRoute, startPoint);
  
  return circuitRoute;
}

// Calcula o custo de inserir uma parada em uma posição específica do circuito
function calculateInsertionCost(currentRoute, newStop, insertPosition, startPoint) {
  const newStopPoint = { lat: newStop.Latitude, lng: newStop.Longitude };
  
  if (currentRoute.length === 0) {
    // Primeira inserção: custo é ida + volta
    return 2 * getDistance(startPoint, newStopPoint);
  }
  
  if (insertPosition === 0) {
    // Inserção no início
    const nextPoint = { lat: currentRoute[0].Latitude, lng: currentRoute[0].Longitude };
    const oldCost = getDistance(startPoint, nextPoint);
    const newCost = getDistance(startPoint, newStopPoint) + getDistance(newStopPoint, nextPoint);
    return newCost - oldCost;
  }
  
  if (insertPosition === currentRoute.length) {
    // Inserção no final
    const prevPoint = { lat: currentRoute[currentRoute.length - 1].Latitude, lng: currentRoute[currentRoute.length - 1].Longitude };
    const oldCost = getDistance(prevPoint, startPoint);
    const newCost = getDistance(prevPoint, newStopPoint) + getDistance(newStopPoint, startPoint);
    return newCost - oldCost;
  }
  
  // Inserção no meio
  const prevPoint = { lat: currentRoute[insertPosition - 1].Latitude, lng: currentRoute[insertPosition - 1].Longitude };
  const nextPoint = { lat: currentRoute[insertPosition].Latitude, lng: currentRoute[insertPosition].Longitude };
  
  const oldCost = getDistance(prevPoint, nextPoint);
  const newCost = getDistance(prevPoint, newStopPoint) + getDistance(newStopPoint, nextPoint);
  
  return newCost - oldCost;
}

// 2-Opt específico para circuito (considera retorno ao início)
async function circuitTwoOpt(route, startPoint) {
  let bestRoute = [...route];
  let bestDistance = calculateCircuitDistance(bestRoute, startPoint);
  let improved = true;
  let iterations = 0;
  const maxIterations = Math.min(100, route.length * 3);
  
  while (improved && iterations < maxIterations) {
    improved = false;
    
    for (let i = 0; i < bestRoute.length - 1; i++) {
      for (let j = i + 2; j < bestRoute.length; j++) {
        // Aplica 2-opt swap
        const newRoute = twoOptSwap(bestRoute, i, j);
        const newDistance = calculateCircuitDistance(newRoute, startPoint);
        
        if (newDistance < bestDistance) {
          bestRoute = newRoute;
          bestDistance = newDistance;
          improved = true;
        }
      }
      
      if (i % 5 === 0) await delay(10);
    }
    
    iterations++;
    
    if (iterations % 10 === 0) {
      const progress = 75 + (iterations / maxIterations) * 15;
      showProgressModal(`2-Opt circuito: iteração ${iterations}`, progress);
      await delay(20);
    }
  }
  
  return bestRoute;
}

// Calcula distância total do circuito (inclui retorno ao início)
function calculateCircuitDistance(route, startPoint) {
  if (route.length === 0) return 0;
  if (route.length === 1) {
    const stopPoint = { lat: route[0].Latitude, lng: route[0].Longitude };
    return 2 * getDistance(startPoint, stopPoint);
  }
  
  let totalDistance = 0;
  
  // Distância do início para primeira parada
  const firstStop = { lat: route[0].Latitude, lng: route[0].Longitude };
  totalDistance += getDistance(startPoint, firstStop);
  
  // Distâncias entre paradas consecutivas
  for (let i = 0; i < route.length - 1; i++) {
    const currentStop = { lat: route[i].Latitude, lng: route[i].Longitude };
    const nextStop = { lat: route[i + 1].Latitude, lng: route[i + 1].Longitude };
    totalDistance += getDistance(currentStop, nextStop);
  }
  
  // Distância da última parada de volta ao início
  const lastStop = { lat: route[route.length - 1].Latitude, lng: route[route.length - 1].Longitude };
  totalDistance += getDistance(lastStop, startPoint);
  
  return totalDistance;
}

// Otimiza especificamente a última parada para minimizar retorno
function optimizeLastStop(route, startPoint) {
  if (route.length < 3) return route;
  
  // Considera os últimos 30% das paradas como candidatas a última
  const candidateCount = Math.max(2, Math.ceil(route.length * 0.3));
  const candidates = route.slice(-candidateCount);
  
  let bestLastIndex = -1;
  let minReturnDistance = Infinity;
  
  candidates.forEach((candidate, index) => {
    const candidatePoint = { lat: candidate.Latitude, lng: candidate.Longitude };
    const distanceToStart = getDistance(candidatePoint, startPoint);
    
    if (distanceToStart < minReturnDistance) {
      minReturnDistance = distanceToStart;
      bestLastIndex = route.length - candidateCount + index;
    }
  });
  
  // Se encontrou uma última parada melhor, reordena
  if (bestLastIndex !== route.length - 1) {
    const bestLastStop = route[bestLastIndex];
    const newRoute = route.filter((_, index) => index !== bestLastIndex);
    newRoute.push(bestLastStop);
    return newRoute;
  }
  
  return route;
}

// Algoritmo simples para nearest neighbor sem circuito
async function simpleNearestNeighborRoute(route, startPoint) {
  let optimizedRoute = [];
  let remaining = [...route];
  let currentPoint = startPoint;
  
  while (remaining.length > 0) {
    let nearestIndex = 0;
    let minDistance = Infinity;
    
    for (let i = 0; i < remaining.length; i++) {
      const distance = getDistance(currentPoint, {
        lat: remaining[i].Latitude,
        lng: remaining[i].Longitude
      });
      
      if (distance < minDistance) {
        minDistance = distance;
        nearestIndex = i;
      }
    }
    
    const nextStop = remaining.splice(nearestIndex, 1)[0];
    optimizedRoute.push(nextStop);
    currentPoint = { lat: nextStop.Latitude, lng: nextStop.Longitude };
    
    await delay(10);
  }
  
  return optimizedRoute;
}

// FUNÇÃO PRINCIPAL ATUALIZADA - SUBSTITUA A optimizeRoute EXISTENTE
async function optimizeRoute() {
  if (deliveryData.length < 3) {
    return showToast('São necessárias pelo menos 3 paradas para otimizar.', 'warn');
  }

  const optimizeBtn = document.getElementById('reOptimizeBtn');
  if (optimizeBtn) {
    optimizeBtn.disabled = true;
    optimizeBtn.classList.add('opacity-50', 'cursor-not-allowed');
  }

  await delay(50);

  let startPoint = userLocation;
  if (!startPoint) {
    startPoint = { lat: deliveryData[0].Latitude, lng: deliveryData[0].Longitude };
    showToast('Localização não encontrada. Iniciando da primeira entrega.', 'warn');
  }

  // Reseta status
  deliveryData.forEach(d => d.status = "pendente");

  try {
    // Verifica se deve fazer circuito completo
    const useReturnToStart = localStorage.getItem('useReturnToStart') === 'true';
    
    let optimizedRoute;
    
    if (useReturnToStart) {
      showProgressModal('Otimizando circuito completo (ida e volta)...', 0);
      optimizedRoute = await optimizeCircuitRoute(deliveryData, startPoint);
      
      const circuitDistance = calculateCircuitDistance(optimizedRoute, startPoint);
      showToast(`Circuito otimizado! ${optimizedRoute.length} paradas, distância total: ${circuitDistance.toFixed(1)}km (ida e volta)`, 'success');
    } else {
      showProgressModal('Otimizando rota simples (apenas ida)...', 0);
      optimizedRoute = await simpleNearestNeighborRoute(deliveryData, startPoint);
      
      const simpleDistance = calculateSimpleRouteDistance(optimizedRoute, startPoint);
      showToast(`Rota otimizada! ${optimizedRoute.length} paradas, distância total: ${simpleDistance.toFixed(1)}km`, 'success');
    }

    // Finalização
    deliveryData = optimizedRoute.map((d, i) => ({ ...d, Sequence: i + 1 }));
    isRouteOptimized = true;

    hideProgressModal();

  } catch (error) {
    console.error('Erro na otimização:', error);
    showToast('Erro na otimização. Usando algoritmo simples...', 'error');
    
    // Fallback
    let fallbackRoute = await simpleNearestNeighborRoute(deliveryData, startPoint);
    deliveryData = fallbackRoute.map((d, i) => ({ ...d, Sequence: i + 1 }));
    isRouteOptimized = true;
    hideProgressModal();
  }

  if (optimizeBtn) {
    optimizeBtn.disabled = false;
    optimizeBtn.classList.remove('opacity-50', 'cursor-not-allowed');
  }

  saveState();
  updateUI();
  startTracking();

  setTimeout(() => {
    if (routeLayer && map) {
      map.fitBounds(routeLayer.getBounds(), { padding: [50, 50] });
    }
  }, 1000);
}

// Função auxiliar para calcular distância de rota simples
function calculateSimpleRouteDistance(route, startPoint) {
  if (route.length === 0) return 0;
  
  let totalDistance = 0;
  let currentPoint = startPoint;
  
  for (const stop of route) {
    const stopPoint = { lat: stop.Latitude, lng: stop.Longitude };
    totalDistance += getDistance(currentPoint, stopPoint);
    currentPoint = stopPoint;
  }
  
  return totalDistance;
}

// Função que implementa o algoritmo 2-Opt
async function apply2Opt(route) {
    let bestRoute = [...route];
    let improved = true;
    let iteration = 0;

    while (improved) {
        improved = false;
        for (let i = 0; i < bestRoute.length - 1; i++) {
            for (let j = i + 1; j < bestRoute.length; j++) {
                // Calcula a distância da rota atual e da rota com a troca
                const currentDistance = calculateDistance(bestRoute[i], bestRoute[(i + 1) % bestRoute.length]) + calculateDistance(bestRoute[j], bestRoute[(j + 1) % bestRoute.length]);
                const newDistance = calculateDistance(bestRoute[i], bestRoute[j]) + calculateDistance(bestRoute[(i + 1) % bestRoute.length], bestRoute[(j + 1) % bestRoute.length]);

                if (newDistance < currentDistance) {
                    // Se a troca melhora a rota, realiza o "swap"
                    bestRoute = twoOptSwap(bestRoute, i + 1, j);
                    improved = true;
                }
            }
        }
        iteration++;
        if (iteration % 5 === 0) { // Atualiza a UI a cada 5 iterações para não sobrecarregar
            showProgressModal(`Refinando... (Iteração ${iteration})`, 25 + (iteration % 70));
            await delay(1);
        }
    }
    return bestRoute;
}

// Função que orienta a rota para começar no ponto mais próximo do início
function orientRoute(route, startPoint) {
    let bestStartIndex = 0;
    let minDistance = Infinity;

    route.forEach((stop, index) => {
        const dist = haversine(startPoint, { lat: stop.Latitude, lng: stop.Longitude });
        if (dist < minDistance) {
            minDistance = dist;
            bestStartIndex = index;
        }
    });

    // Gira o array para que a rota comece no ponto mais próximo
    return [...route.slice(bestStartIndex), ...route.slice(0, bestStartIndex)];
}

// Função auxiliar que realiza a troca (inverte um segmento da rota)
function twoOptSwap(route, i, k) {
    const part1 = route.slice(0, i);
    const part2 = route.slice(i, k + 1).reverse();
    const part3 = route.slice(k + 1);
    return [...part1, ...part2, ...part3];
}

// Função auxiliar para calcular a distância (usa a haversine)
function calculateDistance(stop1, stop2) {
    if (!stop1 || !stop2) return 0;
    return haversine({ lat: stop1.Latitude, lng: stop1.Longitude }, { lat: stop2.Latitude, lng: stop2.Longitude });
}

async function reOptimizeFromCurrentLocation() {
  showToast('Reotimizando a rota...', 'info');
  await optimizeRoute(); // 🔹 usa exatamente a mesma lógica da otimização inicial
}

// Função para desenhar a rota no mapa
async function drawRoute(points, options) {
  if (points.length < 2) return null;
  const coords = points.map(p => `${p.lng},${p.lat}`).join(';');
  const url = `https://router.project-osrm.org/route/v1/driving/${coords}?overview=full&geometries=geojson`;
  try {
    const res = await fetch(url );
    const data = await res.json();
    if (data.routes && data.routes.length) {
      return L.geoJSON(data.routes[0].geometry, { style: options.style });
    }
  } catch (error) { console.error('Erro ao desenhar rota OSRM:', error); }
  return null;
}


// =================================================================================
// ATUALIZAÇÃO DA INTERFACE (UI)
// =================================================================================

function updateMapTheme() {
    if (!map) return;
    if (mapTileLayer) {
        map.removeLayer(mapTileLayer);
    }

    // Detecta se o tema da interface está em modo escuro
    const isDarkMode = document.documentElement.classList.contains('dark');
    
    let url, attribution;

    if (isDarkMode) {
        // Tema escuro do mapa
        url = 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png';
        attribution = '&copy; OpenStreetMap &copy; CARTO';
    } else {
        // Tema claro do mapa
        url = 'https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png';
        attribution = '&copy; OpenStreetMap &copy; CARTO';
    }

    mapTileLayer = L.tileLayer(url, { attribution, maxZoom: 19 });
    mapTileLayer.addTo(map);
}

// Modifique a função initMap para usar a nova função de tema
function initMap() {
  if (!map) {
      map = L.map('map', { zoomControl: false }).setView(userLocation || [-3.73, -38.52], 13);
      updateMapTheme(); // Usa a função de tema para inicializar
  }
}

function updateUI() {
  if (!map) initMap();
  updateMarkers();
  showNextStop();
  updateStats();
  updateRouteLines();
  updateSideList();
}

async function updateRouteLines() {
  await drawAllRoutes();
}

function updateMarkers() {
  if (!map) return;
  markers.forEach(m => m.remove());
  markers = [];
  const next = deliveryData.find(d => d.status === "pendente");

  deliveryData.forEach(d => {
    const isNext = next && d.id === next.id;
    const color = d.status === "entregue" ? "#28a745" : d.status === "naoentregue" ? "#dc3545" : isNext ? "#ff6b35" : "#007bff";
    const size = isNext ? 38 : 30;
    const zIndex = isNext ? 1000 : 500;

    const iconHtml = `<div style="background-color:${color}; color:white; border-radius:50%; width:${size}px; height:${size}px; display:flex; align-items:center; justify-content:center; font-size:14px; font-weight:bold; border: 2px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3);">${d.Sequence}</div>`;
    const marker = L.marker([+d.Latitude, +d.Longitude], {
      icon: L.divIcon({ className: '', html: iconHtml }),
      zIndexOffset: zIndex
    }).addTo(map);

    // --- SOLUÇÃO: LÓGICA DE ÍCONES PERSONALIZADOS PARA O POPUP ---
    const defaultColumns = ['Destination Address', 'Endereço'];
    const endereco = d['Destination Address'] || d['Endereço'] || 'Sem endereço';

    const extraInfoHtml = selectedColumns
      .filter(col => !defaultColumns.includes(col) && d[col])
      .map(col => {
        // Reutiliza a mesma lógica de mapeamento de ícones
        const lowerCol = col.toLowerCase();
        let iconClass = iconMapping.default;

        for (const key in iconMapping) {
          if (lowerCol.includes(key)) {
            iconClass = iconMapping[key];
            break;
          }
        }
        // Retorna o HTML com o ícone e o valor
        return `<div class="flex items-center mb-1"><i class="fas ${iconClass} w-5 text-center mr-2"></i><span>${d[col]}</span></div>`;
      })
      .join(''); // Junta as divs verticalmente

    let popupContent = `
      <div style="min-width: 200px; font-family: 'Inter', sans-serif;">
        <h2 class="popup-title dark:text-white text-lg"><b>Parada ${d.Sequence}</b></h2>
        <p class="popup-info dark:text-white text-xs">${endereco}</p>
        
        ${extraInfoHtml ? `
          <hr>
          <div class="popup-extra-info mt-2 dark:text-white">
            ${extraInfoHtml}
          </div>
        ` : ''}
        
        <hr>
        
        <div style="display: flex; justify-content: space-around; align-items: center; margin-top: 10px;">
          <button title="Entregue" onclick="changeStatus(${d.id}, 'entregue')" style="background: #10b981; color: white; border: none; border-radius: 50%; width: 36px; height: 36px; cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center;"><i class="fas fa-check"></i></button>
          <button title="Não Entregue" onclick="changeStatus(${d.id}, 'naoentregue')" style="background: #ef4444; color: white; border: none; border-radius: 50%; width: 36px; height: 36px; cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center;"><i class="fas fa-times"></i></button>
          <button title="Pendente" onclick="changeStatus(${d.id}, 'pendente')" style="background: #f59e0b; color: white; border: none; border-radius: 50%; width: 36px; height: 36px; cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center;"><i class="fas fa-clock"></i></button>
        </div>
      </div>
    `;
    // --- FIM DA SOLUÇÃO ---

    marker.bindPopup(popupContent, { className: 'dark-theme-popup' });
    markers.push(marker);
  });
}



function showNextStop() {
  const next = deliveryData.find(d => d.status === "pendente");
  const nextStopBar = document.getElementById('nextStopBar');
  
  if (!next) {
    nextStopBar.classList.add("hidden");
    const allDone = deliveryData.every(d => d.status !== 'pendente');
    if (allDone && deliveryData.length > 0) showToast("🎉 Rota Concluída!", 'success');
    return;
  }

  const entreguesCount = deliveryData.filter(d => d.status === 'entregue').length;
  const naoEntreguesCount = deliveryData.filter(d => d.status === 'naoentregue').length;
  const pendentesCount = deliveryData.filter(d => d.status === 'pendente').length;
  const total = deliveryData.length;
  
  const endereco = next['Destination Address'] || next['Endereço'] || 'Endereço não disponível';

  // --- SOLUÇÃO: LÓGICA DE ÍCONES PERSONALIZADOS INTEGRADA ---
  const defaultColumns = ['Destination Address', 'Endereço'];
  
  const extraInfoHtml = selectedColumns
    .filter(col => !defaultColumns.includes(col) && next[col])
    .map(col => {
      // Procura por uma correspondência no mapeamento de ícones
      const lowerCol = col.toLowerCase();
      let iconClass = iconMapping.default;

      for (const key in iconMapping) {
        if (lowerCol.includes(key)) {
          iconClass = iconMapping[key];
          break;
        }
      }
      
      // Retorna o HTML com o ícone correto e o valor da coluna
      return `<span class="text-xs text-gray-500 dark:text-gray-300 flex items-center flex-shrink-0"><i class="fas ${iconClass} w-4 text-center mr-1"></i>${next[col]}</span>`;
    })
    .join(''); // Remove o separador " | " para usar o espaçamento do flexbox

  let infoHtml = `
    <div>
      <div class="flex justify-between items-center mb-1">
        <h3 class="text-lg font-bold text-gray-800 dark:text-white"><span class="text-sm font-light text-gray-600 dark:text-gray-300">${entreguesCount + naoEntreguesCount} / ${total} Concluídas</span><br>Próxima Parada: ${next.Sequence}</h3>
        
      </div>
      <p class="text-sm text-gray-600 mb-2 dark:text-gray-400">${endereco}</p>
      
      ${extraInfoHtml ? `
        <hr class="border-gray-200 dark:border-gray-600 my-2">
        <div class="flex items-center space-x-4 overflow-x-auto pb-1">
          ${extraInfoHtml}
        </div>
      ` : ''}
    </div>
  `;
  // --- FIM DA SOLUÇÃO ---
  
  document.getElementById('nextStopInfo').innerHTML = infoHtml;

  document.getElementById('entregueText').textContent = `Entregue (${entreguesCount})`;
  document.getElementById('naoEntregueText').textContent = `Não Entregue (${naoEntreguesCount})`;
  document.getElementById('pendenteText').textContent = `Pendente (${pendentesCount})`;

  nextStopBar.classList.remove("hidden");
}


function changeStatus(deliveryId, newStatus) {
  const delivery = deliveryData.find(d => d.id === deliveryId);
  if (delivery) {
    delivery.status = newStatus;
    const messages = {
      'entregue': { text: `✅ Pacote #${delivery.STOP} marcado como Entregue!`, type: 'success' },
      'naoentregue': { text: `❌ Pacote #${delivery.STOP} marcado como Não Entregue`, type: 'warn' },
      'pendente': { text: `⏸️ Pacote #${delivery.STOP} marcado como Pendente`, type: 'info' }
    };
    if (messages[newStatus]) {
        showToast(messages[newStatus].text, messages[newStatus].type);
    }
    saveState();
    updateUI(); // Essencial para redesenhar tudo, incluindo a rota
  }
}

// --- FUNÇÃO markNext MODIFICADA ---
function markNext(status) {
  const next = deliveryData.find(d => d.status === "pendente");
  if (next) {
    // Reutiliza a nova função para manter a lógica centralizada
    changeStatus(next.id, status);
  }
}

function updateStats() {
  const total = deliveryData.length;
  const entregues = deliveryData.filter(d => d.status === 'entregue').length;
  const naoEntregues = deliveryData.filter(d => d.status === 'naoentregue').length;
  const pendentes = total - entregues - naoEntregues;
  const progress = total > 0 ? Math.round(((entregues + naoEntregues) / total) * 100) : 0;
  
  document.getElementById('routeStats').innerHTML = `
    <div class="space-y-2">
      <div class="flex justify-between">
        <span>Total:</span><span class="font-semibold text-indigo-600 dark:text-indigo-300">${total}</span>
      </div>
      <div class="flex justify-between">
        <span>Entregues:</span><span class="font-semibold text-green-600 dark:text-green-400">${entregues}</span>
      </div>
      <div class="flex justify-between">
        <span>Não Entregues:</span><span class="font-semibold text-red-600 dark:text-red-400">${naoEntregues}</span>
      </div>
      <div class="flex justify-between">
        <span>Pendentes:</span><span class="font-semibold text-yellow-600 dark:text-yellow-400">${pendentes}</span>
      </div>
      <div class="mt-3 pt-2 border-t border-indigo-200 dark:border-gray-700">
        <div class="flex justify-between mb-1">
          <span class="text-sm font-medium">Progresso:</span>
          <span class="text-sm font-semibold">${progress}%</span>
        </div>
        <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2.5">
          <div class="bg-indigo-600 dark:bg-indigo-400 h-2.5 rounded-full" style="width: ${progress}%"></div>
        </div>
      </div>
    </div>`;

}

function updateSideList() {
    document.getElementById('routeList').innerHTML = deliveryData.map(d => {
        const statusConfig = {
            entregue: { bg: 'bg-green-50 border-green-200', text: 'text-green-700', icon: 'fa-check-circle' },
            naoentregue: { bg: 'bg-red-50 border-red-200', text: 'text-red-700', icon: 'fa-times-circle' },
            pendente: { bg: 'bg-yellow-50 border-yellow-200', text: 'text-yellow-700', icon: 'fa-clock' }
        };
        const config = statusConfig[d.status] || statusConfig.pendente;
        
        // CORREÇÃO: Procura por 'Destination Address' ou 'Endereço'
        const endereco = d['Destination Address'] || d['Endereço'] || 'Sem endereço';

        return `
          <div class="p-3 rounded-lg mb-2 border ${config.bg} flex justify-between items-center">
            <div class="flex items-center space-x-3 overflow-hidden">
              <div class="w-10 h-10 bg-indigo-600 text-white rounded-full flex items-center justify-center text-base font-bold flex-shrink-0" title="Parada Otimizada ${d.Sequence}">
                ${d.Sequence}
              </div>
              <div>
                <span class="text-sm font-semibold text-gray-800 truncate block">Pacote: <em>#${d.STOP}</em></span>
                <span class="text-xs text-gray-500 truncate block">${endereco}</span>
              </div>
            </div>
            <div class="flex items-center space-x-2 flex-shrink-0">
              <i class="fas ${config.icon} ${config.text}"></i>
              <span class="${config.text} font-medium capitalize text-xs">${d.status.replace('naoentregue', 'não entregue')}</span>
            </div>
          </div>`;
    }).join('');
}

// =================================================================================
// AÇÕES DO USUÁRIO E EVENTOS
// =================================================================================
function markNext(status) {
  const next = deliveryData.find(d => d.status === "pendente");
  if (next) {
    next.status = status;
    const messages = {
      'entregue': { text: '✅ Entrega Realizada!', type: 'success' },
      'naoentregue': { text: '❌ Entrega Não Realizada', type: 'warn' }
    };
    if (messages[status]) {
        showToast(messages[status].text, messages[status].type);
    }
    saveState();
    updateUI();
  }
}

function openNavigation() {
    const next = deliveryData.find(d => d.status === "pendente");
    if (next) {
        const navApp = localStorage.getItem('navApp') || 'google';
        let url;

        if (navApp === 'waze') {
            url = `https://www.waze.com/ul?ll=${next.Latitude},${next.Longitude}&navigate=yes`;
        } else if (navApp === 'apple' ) {
            url = `http://maps.apple.com/?daddr=${next.Latitude},${next.Longitude}`;
        } else { // Padrão é Google Maps
            url = `https://www.google.com/maps/dir/?api=1&destination=${next.Latitude},${next.Longitude}`;
        }
        
        window.open(url, '_blank' );
    }
}


function startTracking() {
  if (!navigator.geolocation) return;
  const watchOptions = { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 };

  let lastVibrationTime = 0;

  navigator.geolocation.watchPosition(pos => {
    userLocation = { lat: pos.coords.latitude, lng: pos.coords.longitude };
    if (!userMarker) {
      const pulseIcon = L.divIcon({
        className: "",
        html: `<div class="relative"><div class="w-6 h-6 bg-blue-500 rounded-full border-4 border-white shadow-md"></div><div class="absolute inset-0 rounded-full bg-blue-400 opacity-50 animate-ping"></div></div>`
      });
      userMarker = L.marker([userLocation.lat, userLocation.lng], { icon: pulseIcon }).addTo(map).bindPopup("📍 Você está aqui");
    } else {
      userMarker.setLatLng([userLocation.lat, userLocation.lng]);
    }

    const nextDelivery = deliveryData.find(d => d.status === "pendente");
    if (nextDelivery) {
      const distanceToNext = haversine(userLocation, { lat: +nextDelivery.Latitude, lng: +nextDelivery.Longitude });
      const autoZoomEnabled = localStorage.getItem('autoZoom') !== 'false';
      if (autoZoomEnabled && distanceToNext < 0.5) {
        const bounds = L.latLngBounds([userLocation, { lat: +nextDelivery.Latitude, lng: +nextDelivery.Longitude }]);
        map.fitBounds(bounds, { padding: [80, 80], maxZoom: 17 });
      }
      if (distanceToNext < 0.5) {
        const bounds = L.latLngBounds([userLocation, { lat: +nextDelivery.Latitude, lng: +nextDelivery.Longitude }]);
        map.fitBounds(bounds, { padding: [80, 80], maxZoom: 17 });
      }
      const now = Date.now();
      if (distanceToNext < 0.1 && (now - lastVibrationTime > 30000)) {
        if (navigator.vibrate) {
          navigator.vibrate([200, 100, 200]);
          showToast(`Você está chegando na Parada ${nextDelivery.Sequence}!`, 'info');
          lastVibrationTime = now;
        }
      }
    }
  }, () => { showToast("Não foi possível obter sua localização em tempo real.", "error"); }, watchOptions);
}

// Função auxiliar que apenas busca os dados da rota
async function fetchRouteData(points) {
  if (points.length < 2) return null;
  const coords = points.map(p => `${p.lng},${p.lat}`).join(';');
  const url = `https://router.project-osrm.org/route/v1/driving/${coords}?overview=full&geometries=geojson`;
  try {
    const res = await fetch(url );
    if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
    return await res.json();
  } catch (error) {
    console.error('Erro ao buscar dados da rota OSRM:', error);
    showToast('Falha ao traçar a rota. Verifique a conexão.', 'error');
    return null;
  }
}

// NOVA FUNÇÃO CENTRALIZADA PARA DESENHAR TODAS AS ROTAS
async function drawAllRoutes() {
  // Limpa as rotas antigas
  if (routeLayer) map.removeLayer(routeLayer);
  if (nextDeliveryRouteLayer) map.removeLayer(nextDeliveryRouteLayer);

  // 1. Desenha a Rota Completa (Azul)
  if (isRouteOptimized) {
    const allPoints = deliveryData.map(d => ({ lat: +d.Latitude, lng: +d.Longitude }));
    if (userLocation) allPoints.unshift(userLocation);
    
    const routeData = await fetchRouteData(allPoints);
    if (routeData && routeData.routes.length > 0) {
      routeLayer = L.geoJSON(routeData.routes[0].geometry, { style: { color: "#5e33ea", weight: 5, opacity: 0.7 } });
      routeLayer.addTo(map);
    }
  }

  // 2. Desenha a Rota para a Próxima Entrega (Laranja)
  const nextDelivery = deliveryData.find(d => d.status === "pendente");
  if (nextDelivery && userLocation) {
    const nextPoints = [userLocation, { lat: +nextDelivery.Latitude, lng: +nextDelivery.Longitude }];
    const nextRouteData = await fetchRouteData(nextPoints);
    if (nextRouteData && nextRouteData.routes.length > 0) {
      nextDeliveryRouteLayer = L.geoJSON(nextRouteData.routes[0].geometry, { style: { color: "#ff6b35", weight: 7, opacity: 0.9, dashArray: '10, 5' } });
      nextDeliveryRouteLayer.addTo(map);
    }
  }
}

function showMapControls(show) {
    const visibility = show ? 'remove' : 'add';
    ["menuToggleBtn", "centerUserBtn", "reOptimizeBtn", "fullscreenBtn", "settingsBtn"].forEach(id => {
      document.getElementById(id).classList[visibility]("hidden");
    });
}

function toggleMenu(force = null) {
  const sideMenu = document.getElementById("sideMenu");
  const menuOverlay = document.getElementById("menuOverlay");
  // A linha 'optimizeInMenuBtn' foi removida
  const isOpen = !sideMenu.classList.contains("hidden");
  const shouldOpen = force !== null ? force : !isOpen;
  if (shouldOpen) {
    sideMenu.classList.remove("hidden");
    menuOverlay.classList.remove("hidden");
    setTimeout(() => sideMenu.classList.remove("-translate-x-full"), 10);
    // A linha 'optimizeInMenuBtn' foi removida
  } else {
    sideMenu.classList.add("-translate-x-full");
    menuOverlay.classList.add("hidden");
    setTimeout(() => sideMenu.classList.add("hidden"), 300);
  }
}

// =================================================================================
// FUNÇÕES UTILITÁRIAS
// =================================================================================
function haversine(pos1, pos2) {
  const R = 6371; // Raio da Terra em km
  const dLat = (pos2.lat - pos1.lat) * Math.PI / 180;
  const dLon = (pos2.lng - pos1.lng) * Math.PI / 180;
  const a = Math.sin(dLat/2) * Math.sin(dLat/2) + Math.cos(pos1.lat * Math.PI / 180) * Math.cos(pos2.lat * Math.PI / 180) * Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

// Função auxiliar para compatibilidade
function getDistance(point1, point2) {
  if (!point1 || !point2) return 0;
  return haversine(point1, point2); 
  // ou: return await getSmartDistance(point1, point2, false);
}

function showToast(message, type = 'info') {
  const toast = document.getElementById('toast');
  const toastMessage = document.getElementById('toastMessage');
  const toastIcon = document.getElementById('toastIcon');
  
  const icons = {
    info: 'fa-info-circle',
    success: 'fa-check-circle',
    warn: 'fa-exclamation-triangle',
    error: 'fa-times-circle'
  };
  toastIcon.className = `fas ${icons[type]} mr-3`;
  
  toastMessage.textContent = message;
  toast.classList.add('show');
  
  setTimeout(() => { toast.classList.remove('show'); }, 3000);
}

function showConfirmModal(title, message) {
  return new Promise((resolve) => {
    const modal = document.getElementById('confirmModal');
    document.getElementById('confirmTitle').textContent = title;
    document.getElementById('confirmMessage').innerHTML = message; // Usamos innerHTML para permitir quebras de linha com   


    modal.classList.remove('hidden');

    const okBtn = document.getElementById('confirmOkBtn');
    const cancelBtn = document.getElementById('confirmCancelBtn');

    const close = (decision) => {
      modal.classList.add('hidden');
      // Remove os event listeners para evitar múltiplos cliques em futuras chamadas
      okBtn.onclick = null;
      cancelBtn.onclick = null;
      resolve(decision);
    };

    okBtn.onclick = () => close(true);
    cancelBtn.onclick = () => close(false);
  });
}

// =================================================================================
// EVENT LISTENERS
// =================================================================================
// Listener para abrir o modal de configurações
document.getElementById("settingsBtn").addEventListener("click", () => {
  // Carrega as configurações salvas antes de mostrar
  document.getElementById('navAppSelect').value = localStorage.getItem('navApp') || 'google';
  document.getElementById('autoZoomToggle').checked = (localStorage.getItem('autoZoom') !== 'false');
  
  document.getElementById('settingsModal').classList.remove('hidden');
  syncReturnToStartToggle();
});

// Listener para fechar o modal de configurações
document.getElementById("closeSettingsBtn").addEventListener("click", () => {
  document.getElementById('settingsModal').classList.add('hidden');
});

// Listeners para salvar as configurações quando elas mudam
document.getElementById('navAppSelect').addEventListener('change', (e) => {
  localStorage.setItem('navApp', e.target.value);
  showToast('Aplicativo de navegação salvo!', 'success');
});

document.getElementById('autoZoomToggle').addEventListener('change', (e) => {
  localStorage.setItem('autoZoom', e.target.checked);
  showToast(`Zoom automático ${e.target.checked ? 'ativado' : 'desativado'}.`, 'success');
});

document.getElementById("menuToggleBtn").addEventListener("click", () => toggleMenu(true));
document.getElementById("closeMenuBtn").addEventListener("click", () => toggleMenu(false));
document.getElementById("menuOverlay").addEventListener("click", () => toggleMenu(false));

document.getElementById("loadNewFileBtn").addEventListener("click", async () => {
    // --- SOLUÇÃO: FECHA O MENU ANTES DE MOSTRAR O MODAL ---
    toggleMenu(false); 
    
    // Pequeno delay para garantir que a animação de fechar o menu comece
    await delay(100); 

    const confirmed = await showConfirmModal(
        "🚨 Recomeçar Rota",
        "Tem certeza que deseja carregar um novo arquivo? Todos os dados da rota atual serão perdidos e o sistema será reiniciado."
    );

    if (confirmed) {
        showToast('🔄 Reiniciando sistema...', 'info');
        clearState();
    }
});

// --- OUVINTES DE EVENTOS CORRETOS PARA OS BOTÕES FLUTUANTES ---
document.getElementById('reOptimizeBtn').addEventListener('click', reOptimizeFromCurrentLocation);

document.getElementById('centerUserBtn').addEventListener('click', () => {
    if (userLocation) {
        map.setView(userLocation, 16);
        showToast('📍 Centralizado na sua localização', 'info');
    } else {
        showToast('Localização não disponível', 'warn');
    }
});

// Funções para controlar o modal de progresso
function showProgressModal(text) {
  document.getElementById('progressText').textContent = text;
  document.getElementById('progressModal').classList.remove('hidden');
}

function hideProgressModal() {
  document.getElementById('progressModal').classList.add('hidden');
}

// --- Botão de tela cheia ---
document.getElementById("fullscreenBtn").addEventListener("click", () => {
  if (!document.fullscreenElement) {
    document.documentElement.requestFullscreen().catch(err => {
      showToast(`Erro ao ativar tela cheia: ${err.message}`, "error");
    });
  } else {
    document.exitFullscreen();
  }
});

// Função para sincronizar a aparência do switch com o tema atual
function syncThemeSwitch() {
    const html = document.documentElement;
    const toggle = document.getElementById('themeToggleSwitch');
    const knob = toggle.querySelector('span[aria-hidden="true"]');

    if (html.classList.contains('dark')) {
        toggle.classList.remove('bg-gray-200');
        toggle.classList.add('bg-indigo-600');
        knob.classList.remove('translate-x-0');
        knob.classList.add('translate-x-5');
        toggle.setAttribute('aria-checked', 'true');
    } else {
        toggle.classList.remove('bg-indigo-600');
        toggle.classList.add('bg-gray-200');
        knob.classList.remove('translate-x-5');
        knob.classList.add('translate-x-0');
        toggle.setAttribute('aria-checked', 'false');
    }
}

// Listener para o novo switch de tema
document.getElementById("themeToggleSwitch").addEventListener("click", () => {
    const html = document.documentElement;
    if (html.classList.contains("dark")) {
        html.classList.remove("dark");
        localStorage.setItem("theme", "light");
        showToast("☀️ Tema claro ativado", "info");
    } else {
        html.classList.add("dark");
        localStorage.setItem("theme", "dark");
        showToast("🌙 Tema escuro ativado", "info");
    }
    
    syncThemeSwitch(); // Sincroniza o visual do switch após a mudança
    updateMapTheme(); // 🎯 ADICIONE ESTA LINHA para atualizar o mapa
});

// Restaurar tema e sincronizar switch ao carregar a página
if (localStorage.getItem("theme") === "dark") {
  document.documentElement.classList.add("dark");
}
// Chama a sincronização após um pequeno delay para garantir que tudo foi carregado
document.addEventListener('DOMContentLoaded', () => {
    // Restaurar tema salvo
    if (localStorage.getItem("theme") === "dark") {
        document.documentElement.classList.add("dark");
    }
    
    // Sincronizar switch e mapa após um pequeno delay
    setTimeout(() => {
        syncThemeSwitch();
        if (map) {
            updateMapTheme(); // Atualiza o mapa se ele já estiver inicializado
        }
    }, 100);
});

function toggleTheme() {
    const html = document.documentElement;
    if (html.classList.contains("dark")) {
        html.classList.remove("dark");
        localStorage.setItem("theme", "light");
    } else {
        html.classList.add("dark");
        localStorage.setItem("theme", "dark");
    }
    
    syncThemeSwitch();
    updateMapTheme(); // Sempre atualiza o mapa junto
}

// --- NOVOS LISTENERS PARA AS NOVAS CONFIGURAÇÕES ---
document.getElementById("settingsBtn").addEventListener("click", () => {
  // Carrega as configurações salvas antes de mostrar
  document.getElementById('navAppSelect').value = localStorage.getItem('navApp') || 'google';
  syncThemeSwitch();
  
  document.getElementById('settingsModal').classList.remove('hidden');
});

// Função para sincronizar o toggle de retorno
function syncReturnToStartToggle() {
  const useReturn = localStorage.getItem('useReturnToStart') === 'true';
  const toggle = document.getElementById('returnToStartToggle');
  const knob = toggle.querySelector('span[aria-hidden="true"]');

  if (useReturn) {
    toggle.classList.remove('bg-gray-200');
    toggle.classList.add('bg-indigo-600');
    knob.classList.remove('translate-x-0');
    knob.classList.add('translate-x-5');
  } else {
    toggle.classList.remove('bg-indigo-600');
    toggle.classList.add('bg-gray-200');
    knob.classList.remove('translate-x-5');
    knob.classList.add('translate-x-0');
  }
  toggle.setAttribute('aria-checked', useReturn);
}

// Listener para o novo toggle
document.getElementById('returnToStartToggle').addEventListener('click', () => {
  const useReturn = localStorage.getItem('useReturnToStart') === 'true';
  localStorage.setItem('useReturnToStart', !useReturn);
  syncReturnToStartToggle();
  showToast(`Retorno ao ponto inicial ${!useReturn ? 'ativado' : 'desativado'}.`, 'info');
});


const sideMenu = document.getElementById('sideMenu');
const menuOverlay = document.getElementById('menuOverlay');

function openMenu() {
  sideMenu.classList.remove('hidden', '-translate-x-full');
  menuOverlay.classList.remove('hidden');
}

function closeMenu() {
  sideMenu.classList.add('-translate-x-full');
  menuOverlay.classList.add('hidden');
}

menuOverlay.addEventListener('click', closeMenu);
document.getElementById('closeMenuBtn')?.addEventListener('click', closeMenu);


// Fechar o settingsModal ao clicar fora (apenas no fundo escuro)
document.getElementById('settingsModal').addEventListener('click', (e) => {
  if (e.target === document.getElementById('settingsModal')) {
    document.getElementById('settingsModal').classList.add('hidden');
  }
});

// Botão fechar já existente continua funcionando
document.getElementById('closeSettingsBtn')?.addEventListener('click', () => {
  document.getElementById('settingsModal').classList.add('hidden');
});

let sortableInstance = null;

function initializeSortable() {
    const routeList = document.getElementById('routeList');
    
    // Remove instância anterior se existir
    if (sortableInstance) {
        sortableInstance.destroy();
    }
    
    sortableInstance = Sortable.create(routeList, {
        animation: 200,
        ghostClass: 'sortable-ghost',
        chosenClass: 'sortable-chosen',
        dragClass: 'sortable-drag',
        
        onStart: function(evt) {
            evt.item.classList.add('z-50');
        },
        
        onEnd: function(evt) {
            evt.item.classList.remove('z-50');
            
            // Se foi movido para uma nova posição, reordena
            if (evt.oldIndex !== evt.newIndex) {
                reorderDeliveries(evt.oldIndex, evt.newIndex);
            }
        }
    });
    
    // Adiciona listeners para swipe em dispositivos touch
    addSwipeListeners();
}

function addSwipeListeners() {
    const routeItems = document.querySelectorAll('.route-item');
    
    routeItems.forEach(item => {
        let startX = 0;
        let isDragging = false;
        let deleteButton = null;
        
        function createDeleteButton() {
            if (deleteButton) return deleteButton;
            
            deleteButton = document.createElement('div');
            deleteButton.innerHTML = '<i class="fa-solid fa-trash-can"></i>';
            deleteButton.className = 'delete-button';
            deleteButton.style.cssText = `
                position: absolute;
                right: -60px;
                top: 50%;
                transform: translateY(-50%);
                width: 50px;
                height: 50px;
                background: #ef4444;
                color: white;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 20px;
                cursor: pointer;
                z-index: 1000;
                box-shadow: 0 2px 8px rgba(0,0,0,0.3);
                opacity: 0;
                transition: opacity 0.2s ease;
            `;
            
            deleteButton.addEventListener('click', () => {
                const deliveryId = parseInt(item.getAttribute('data-delivery-id'));
                removeDelivery(deliveryId);
            });
            
            item.appendChild(deleteButton);
            return deleteButton;
        }
        
        function resetItem() {
            item.style.transform = '';
            item.style.backgroundColor = '';
            item.style.borderColor = '';
            if (deleteButton) {
                deleteButton.style.opacity = '0';
                setTimeout(() => {
                    if (deleteButton && deleteButton.parentNode) {
                        deleteButton.parentNode.removeChild(deleteButton);
                        deleteButton = null;
                    }
                }, 200);
            }
            isDragging = false;
        }
        
        // Mouse events
        item.addEventListener('mousedown', (e) => {
            if (e.target.classList.contains('delete-button')) return;
            startX = e.clientX;
            isDragging = false;
            
            const handleMouseMove = (e) => {
                const diffX = startX - e.clientX;
                
                if (diffX > 20) {
                    isDragging = true;
                    const moveDistance = Math.min(diffX, 80);
                    item.style.transform = `translateX(-45px)`;
                    item.style.backgroundColor = '#fef2f2';
                    item.style.borderColor = '#fca5a5';
                    
                    if (moveDistance > 30) {
                        const btn = createDeleteButton();
                        btn.style.opacity = '1';
                    }
                    
                    e.preventDefault();
                }
            };
            
            const handleMouseUp = () => {
                if (!isDragging) {
                    resetItem();
                } else if (item.style.transform.includes('translateX')) {
                    // Mantém a posição para mostrar o botão
                }
                
                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);
            };
            
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
        });
        
        // Touch events
        item.addEventListener('touchstart', (e) => {
            if (e.target.classList.contains('delete-button')) return;
            startX = e.touches[0].clientX;
            isDragging = false;
        });
        
        item.addEventListener('touchmove', (e) => {
            const diffX = startX - e.touches[0].clientX;
            
            if (diffX > 20) {
                isDragging = true;
                const moveDistance = Math.min(diffX, 80);
                item.style.transform = `translateX(-${moveDistance}px)`;
                item.style.backgroundColor = '#fef2f2';
                item.style.borderColor = '#fca5a5';
                
                if (moveDistance > 30) {
                    const btn = createDeleteButton();
                    btn.style.opacity = '1';
                }
                
                e.preventDefault();
            }
        });
        
        item.addEventListener('touchend', () => {
            if (!isDragging) {
                resetItem();
            }
        });
        
        // Clique fora para resetar
        document.addEventListener('click', (e) => {
            if (!item.contains(e.target)) {
                resetItem();
            }
        });
    });
}

function reorderDeliveries(oldIndex, newIndex) {
    // Remove o item da posição antiga e insere na nova
    const movedItem = deliveryData.splice(oldIndex, 1)[0];
    deliveryData.splice(newIndex, 0, movedItem);
    
    // Recalcula as sequências
    deliveryData.forEach((delivery, index) => {
        delivery.Sequence = index + 1;
    });
    
    showToast(`Parada reordenada para posição ${newIndex + 1}`, 'success');
    
    // Salva e atualiza
    saveState();
    updateUI();
}

async function removeDelivery(deliveryId) {
  toggleMenu(false); 
    const delivery = deliveryData.find(d => d.id === deliveryId);
    if (!delivery) return;
    
    const confirmed = await showConfirmModal(
        '🚨  Remover Parada',
        `Deseja remover a parada "${delivery.STOP}" da rota?<br><br>Esta ação não pode ser desfeita.`
    );
    
    if (confirmed) {
        // Remove da lista
        deliveryData = deliveryData.filter(d => d.id !== deliveryId);
        
        // Recalcula as sequências
        deliveryData.forEach((delivery, index) => {
            delivery.Sequence = index + 1;
        });
        
        showToast(`Parada #${delivery.STOP} removida da rota`, 'warn');
        
        // Salva e atualiza
        saveState();
        updateUI();
    } else {
        // Se cancelou, atualiza a lista para resetar o visual
        updateSideList();
    }
}

function updateSideList() {
    const container = document.getElementById('routeList');
    container.innerHTML = deliveryData.map(d => {
        const statusConfig = {
            entregue: { bg: 'bg-green-50 border-green-200', text: 'text-green-700', icon: 'fa-check-circle' },
            naoentregue: { bg: 'bg-red-50 border-red-200', text: 'text-red-700', icon: 'fa-times-circle' },
            pendente: { bg: 'bg-yellow-50 border-yellow-200', text: 'text-yellow-700', icon: 'fa-clock' }
        };
        const config = statusConfig[d.status] || statusConfig.pendente;
        
        const endereco = d['Destination Address'] || d['Endereço'] || 'Sem endereço';

        return `
          <div class="route-item p-3 rounded-lg mb-2 border ${config.bg} flex justify-between items-center cursor-move transition-all duration-200 hover:shadow-md" data-delivery-id="${d.id}">
            <div class="flex items-center space-x-3 overflow-hidden">
              <div class="w-10 h-10 bg-indigo-600 text-white rounded-full flex items-center justify-center text-base font-bold flex-shrink-0" title="Parada Otimizada ${d.Sequence}">
                ${d.Sequence}
              </div>
              <div>
                <span class="text-sm font-semibold text-gray-800 truncate block">Pacote: <em>#${d.STOP}</em></span>
                <span class="text-xs text-gray-500 truncate block">${endereco}</span>
              </div>
            </div>
            <div class="flex items-center space-x-2 flex-shrink-0">
              <i class="fas fa-grip-vertical text-gray-400 mr-2"></i>
              <i class="fas ${config.icon} ${config.text}"></i>
              <span class="${config.text} font-medium capitalize text-xs">${d.status.replace('naoentregue', 'não entregue')}</span>
            </div>
          </div>`;
    }).join('');
    
    // Inicializa o Sortable após criar os elementos
    initializeSortable();
}

</script>
</body>
</html>
