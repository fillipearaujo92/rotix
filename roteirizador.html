


<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Roday - Otimizador de Rotas</title>
  <link rel="icon" type="image/png" href="img/favicon.png">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
    
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"/>
  <script>
    tailwind.config = {
      darkMode: 'class'
    }
  </script>

  <style>
    :root { --Roday-blue: #5e33ea; }

    @import url('https://fonts.googleapis.com/css2?family=Rubik:ital,wght@0,600;1,600&display=swap');
    
    #map { height: 100vh; }
    .leaflet-control-zoom, .leaflet-control-attribution { display: none !important; }
    .leaflet-popup-content-wrapper { border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
    .dark .leaflet-popup-content-wrapper {background: #2d3748; }
    .leaflet-popup-content { margin: 15px; font-size: 14px; line-height: 1.6; }
    .leaflet-popup-content b { font-weight: 600; }
    .leaflet-popup-content small { color: #555; }
    .leaflet-popup-tip { box-shadow: none; }

    .toast {
      position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.85);
      backdrop-filter: blur(5px);
      color: #141414; padding: 12px 20px; border-radius: 25px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2); z-index: 10001;
      display: none; align-items: center;
      z-index: 9999;
    }
    .dark .toast {
      background: #2d3748; 
      color: white;
    }
    .toast.show { display: flex; animation: fadeIn 0.3s ease; }
    @keyframes fadeIn { from { opacity: 0; transform: translate(-50%, -20px); } to { opacity: 1; transform: translate(-50%, 0); } }

    .map-floating-btn {
      position: fixed; z-index: 1000; background-color: white;
      width: 48px; height: 48px; border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2); cursor: pointer;
      transition: all 0.2s ease;
    }

    .dark .map-floating-btn {
      background-color: #2d3748; /* cinza escuro */
      color: #f7fafc;            /* texto claro */
    }

    .dark #menuToggleBtn {
      background-color: #4F45E4; /* cinza escuro */
      color: #f7fafc;            /* texto claro */
    }

    .map-floating-btn:hover { transform: scale(1.05); }
    #menuToggleBtn { top: 20px; left: 20px; box-shadow: 5px 5px 20px rgba(0,0,0,0.5); cursor: pointer;}
    #reOptimizeBtn { bottom: 490px; right: 20px; border: 3px solid white; box-shadow: 5px 5px 20px rgba(0,0,0,0.5); cursor: pointer;}
    #centerUserBtn { bottom: 430px; right: 20px; border: 3px solid white; box-shadow: 5px 5px 20px rgba(0,0,0,0.5); cursor: pointer;}
    #fullscreenBtn { bottom: 370px; right: 20px; border: 3px solid white; box-shadow: 5px 5px 20px rgba(0,0,0,0.5); cursor: pointer; }
    #settingsBtn { bottom: 310px; right: 20px; border: 3px solid white; box-shadow: 5px 5px 20px rgba(0,0,0,0.5); cursor: pointer; }    
    #toggleTrackingBtn {bottom: 250px; right: 20px; border: 3px solid white; box-shadow: 5px 5px 20px rgba(0,0,0,0.5);}

    #toggleTrackingBtn.tracking-active {
      background-color: #5E33EA !important; /* Verde quando ativo */
      transform: scale(1.05);
    }

    #toggleTrackingBtn.tracking-inactive {
      background-color: white !important; /* Cinza quando inativo */
    }

    #sideMenu {
        z-index: 9999;
        box-shadow: 6px 0px 20px 0px #0000008a;
        scrollbar-width: none;
    }

    #menuOverlay {background: #141414;}

    /* Estilos para o Modal de Progresso */
    #progressModal.hidden {
      display: none;
    }

    /* Animação do Spinner (Loader) */
    .loader {
      border: 5px solid #f3f3f3; /* Cinza claro */
      border-top: 5px solid #5e33ea; /* Roxo Roday */
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .sortable-ghost {
        opacity: 0.4 !important;
        background: #f3f4f6 !important;
        border: 2px dashed #d1d5db !important;
    }

    .sortable-drag {
        transform: rotate(5deg) !important;
        box-shadow: 0 10px 30px rgba(0,0,0,0.4) !important;
    }

    .route-item {
      position: relative;
      transition: transform 0.2s ease, background-color 0.2s ease, border-color 0.2s ease;
      touch-action: pan-y;
      user-select: none;
      overflow: visible;
    }

    .route-item:hover {
        transform: translateY(-2px);
    }


  </style>
</head>
<body class="bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-white">

  <!-- Toast Notification -->
  <div id="toast" class="toast">
    <i id="toastIcon" class="fas fa-info-circle mr-3"></i>
    <span id="toastMessage"></span>
  </div>

  <!-- Modal de Progresso da Otimização -->
    <div id="progressModal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-[9999] flex items-center justify-center">
        <div class="bg-white dark:bg-gray-800 rounded-2xl shadow-lg p-8 flex flex-col items-center space-y-4 w-68">
            <div class="loader"></div>
            <h3 class="text-gray-700 font-semibold text-lg dark:text-white">Otimizando Rota...</h3>
            <p id="progressText" class="text-gray-500 text-sm dark:text-white">Calculando distâncias...</p>
        </div>
    </div>

    <div id="confirmModal" class="hidden fixed inset-0 bg-black bg-opacity-60 z-[9999] flex items-center justify-center p-4">
    <div class="bg-white dark:bg-gray-800 rounded-2xl shadow-lg p-6 flex flex-col w-full max-w-sm">
        <div class="flex items-center mb-4">
        <!--<i class="fas fa-exclamation-triangle text-yellow-500 text-2xl mr-4"></i>-->
        <h3 id="confirmTitle" class="text-gray-800 font-bold text-lg dark:text-white">Atenção</h3>
        </div>
        <p id="confirmMessage" class="text-gray-600 text-sm mb-6 dark:text-white">Deseja continuar com esta ação?</p>
        <div class="flex justify-end space-x-3">
        <button id="confirmCancelBtn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-semibold py-2 px-5 rounded-lg transition-colors">Cancelar</button>
        <button id="confirmOkBtn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-5 rounded-lg transition-colors">OK</button>
        </div>
    </div>
    </div>

  <!-- Botões Flutuantes do Mapa -->
  <button id="menuToggleBtn" class="map-floating-btn hidden">
    <i class="fas fa-bars text-xl text-gray-600 dark:text-white"></i>
  </button>
  <button id="toggleTrackingBtn" class="map-floating-btn hidden tracking-inactive" title="Alternar Rastreamento">
    <i class="fas fa-location-arrow text-xl text-green-600 dark:text-white"></i>
  </button>
  <button id="settingsBtn" class="map-floating-btn hidden" title="Configurações">
    <i class="fas fa-cog text-xl dark:text-white"></i>
  </button>
  <button id="centerUserBtn" class="map-floating-btn hidden">
    <i class="fas fa-location-crosshairs text-xl text-sky-600 dark:text-white"></i>
  </button>
  <button id="reOptimizeBtn" class="map-floating-btn hidden" title="Reotimizar Rota a partir da sua localização">
    <i class="fas fa-route text-xl text-green-600 dark:text-white"></i>
  </button>
  <button id="fullscreenBtn" class="map-floating-btn hidden" title="Tela Cheia">
    <i class="fas fa-expand text-xl text-sky-600 dark:text-white"></i>
  </button>
  <!--<button id="themeToggleBtn" class="map-floating-btn hidden" title="Alternar Tema">
    <i class="fas fa-sun text-xl text-yellow-500 dark:text-white"></i>
  </button> -->

  <!-- NOVO: Modal de Configurações -->
  <div id="settingsModal" class="hidden fixed inset-0 bg-black bg-opacity-60 z-[9999] flex items-center justify-center p-4">
    <div class="bg-white dark:bg-gray-800 rounded-2xl shadow-lg p-6 flex flex-col w-full max-w-md">
      <div class="flex justify-between items-center mb-6">
          <h3 class="text-gray-800 font-bold text-lg dark:text-white"><i class="fas fa-cog mr-2"></i>Configurações</h3>
          <button id="closeSettingsBtn" class="text-gray-500 hover:text-red-500"><i class="fas fa-times text-xl"></i></button>
      </div>

          <div class="space-y-6">
              <!-- Seção de Navegação -->
              <div>
                  <label for="navAppSelect" class="block text-sm font-medium text-gray-700 dark:text-gray-300">Aplicativo de Navegação Padrão</label>
                  <select id="navAppSelect" class="mt-1 block w-full p-2 border border-gray-300 dark:bg-gray-700 dark:border-gray-600 rounded-md shadow-sm">
                      <option value="google">Google Maps</option>
                      <option value="waze">Waze</option>
                      <option value="apple">Apple Maps (somente iOS)</option>
                  </select>
                  <p class="text-xs text-gray-500 mt-1">O aplicativo será aberto ao clicar em "Navegar".</p>
              </div>

              <!-- Seção de Zoom Automático -->
              <div>
                  <label class="block text-sm font-medium text-gray-700 dark:text-gray-300">Zoom Automático</label>
                  <div class="flex items-center mt-2">
                      <input id="autoZoomToggle" type="checkbox" class="h-4 w-4 text-indigo-600 border-gray-300 rounded" checked>
                      <label for="autoZoomToggle" class="ml-2 block text-sm text-gray-900 dark:text-gray-200">Aproximar mapa ao chegar perto do destino</label>
                  </div>
              </div>
              
            <fieldset class="border-t border-gray-200 dark:border-gray-700 pt-4">
                <legend class="text-sm font-semibold text-gray-900 dark:text-gray-200">Comportamento da Rota</legend>
                
                <div class="mt-4 space-y-4">
                  <div class="mt-2 flex items-center justify-between p-3 rounded-lg">
                        <span class="text-gray-700 dark:text-gray-300">Retornar ao Ponto Inicial</span>
                        <button id="returnToStartToggle" type="button" class="relative inline-flex h-6 w-11 flex-shrink-0 cursor-pointer rounded-full border-2 border-transparent transition-colors duration-200 ease-in-out focus:outline-none bg-gray-200" role="switch" aria-checked="false">
                            <span class="sr-only">Ativar retorno ao ponto inicial</span>
                            <span aria-hidden="true" class="pointer-events-none inline-block h-5 w-5 transform rounded-full bg-white shadow ring-0 transition duration-200 ease-in-out translate-x-0"></span>
                        </button>
                    </div>
                    <p class="text-xs text-gray-500 mt-1">Se ativado, a rota será otimizada para terminar na parada mais próxima do seu ponto de partida.</p>
                    <div id="endPointAddressContainer" class="hidden pl-4 border-l-2 border-indigo-200">
                        <label for="endAddress" class="block text-xs font-medium text-gray-500 dark:text-gray-400">Endereço de Término</label>
                        <textarea id="endAddress" placeholder="Digite o endereço de término" class="mt-1 w-full p-2 border border-gray-300 dark:bg-gray-700 dark:border-gray-600 rounded-md text-sm" rows="2"></textarea>
                        <button id="geocodeEndBtn" class="mt-2 w-full bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded text-sm"><i class="fas fa-search mr-1"></i>Buscar Endereço</button>
                    </div>
                </div>
            </fieldset>

            <!-- Seção de Interface e Experiência -->
            <div class="border-t border-gray-200 dark:border-gray-700 pt-4">
                <legend class="text-sm font-semibold text-gray-900 dark:text-gray-200">Interface e Experiência</legend>

                <div class="mt-4 space-y-4">
                  <div>
                <label class="block text-sm font-medium text-gray-700 dark:text-gray-300">Tema da Interface</label>
                <div class="mt-2 flex items-center justify-between p-3 rounded-lg">
                    <span class="text-gray-800 dark:text-gray-200">Modo Escuro</span>
                    <button id="themeToggleSwitch" type="button" class="relative inline-flex h-6 w-11 flex-shrink-0 cursor-pointer rounded-full border-2 border-transparent transition-colors duration-200 ease-in-out focus:outline-none bg-gray-200 dark:bg-indigo-600" role="switch" aria-checked="false">
                        <span class="sr-only">Use setting</span>
                        <span aria-hidden="true" class="pointer-events-none inline-block h-5 w-5 transform rounded-full bg-white shadow ring-0 transition duration-200 ease-in-out translate-x-0 dark:translate-x-5"></span>
                    </button>
                </div>
                <div class="mt-2 flex items-center justify-between p-3 rounded-lg">
                    <span class="text-gray-800 dark:text-gray-200">Manter tela ligada</span>
                    <label class="relative inline-flex items-center cursor-pointer">
                      <input type="checkbox" id="wakeLockToggle" class="sr-only peer">
                      <div class="w-11 h-6 bg-gray-300 peer-focus:outline-none rounded-full peer
                                  peer-checked:bg-indigo-600
                                  after:content-[''] after:absolute after:top-[2px] after:left-[2px]
                                  after:bg-white after:border after:rounded-full after:h-5 after:w-5 after:transition-all
                                  peer-checked:after:translate-x-full peer-checked:after:border-white">
                      </div>
                    </label>
                  </div>

                </div>
                    
                </div>
              </div>
          </div>
      </div>
  </div>

  <!-- Menu Lateral -->
  <div id="menuOverlay" class="hidden fixed inset-0 bg-black bg-opacity-40 z-40"></div>
  <div id="sideMenu" class="hidden dark:bg-gray-800 fixed top-0 left-0 w-full max-w-sm h-full bg-white z-5000 p-6 overflow-y-auto transform -translate-x-full transition-transform duration-300">
    
    <div class="flex justify-between items-center mb-6">
      <h4 class="font-semibold text-gray-800 dark:text-white text-lg"><i class="fa-solid fa-bars"></i> Menu</h4>
      <button id="closeMenuBtn" class="text-gray-500 hover:text-red-500"><i class="fas fa-times text-xl"></i></button>
    </div>
    
    <div class="mb-6 p-4 bg-red-50 dark:bg-red-900 border-red-300 dark:border-red-700 border border-red-200 rounded-lg">
      <h5 class="font-medium text-red-800 mb-2 dark:text-white"><i class="fas fa-exclamation-triangle mr-2"></i>Recomeçar Rota</h5>
      <p class="text-sm dark:text-white text-red-600 mb-3">Isso apagará a rota atual e voltará ao início.</p>
      <button id="loadNewFileBtn" class="w-full bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-lg font-medium transition"><i class="fas fa-file-upload mr-2"></i>Carregar Novo Arquivo</button>
    </div>

    <button id="validateAddressesBtn" class="w-full bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg font-medium transition mb-3">
      <i class="fas fa-search-location mr-2"></i>Validar Endereços
    </button>

    <!-- SEÇÃO DE CONFIGURAÇÕES DE ROTA FOI REMOVIDA -->
    <div class="mb-6 p-4 rounded-lg border 
            bg-indigo-50 border-indigo-200 text-indigo-700
            dark:bg-gray-800 dark:border-gray-700 dark:text-gray-100">
      <h5 class="font-medium mb-2 text-indigo-800 dark:text-indigo-300">
        <i class="fas fa-chart-bar mr-2"></i>Estatísticas
      </h5>
      <div id="routeStats" class="text-sm"></div>
    </div>
    
    <div class="flex justify-between items-center mb-6">
      <h4 class="font-semibold text-gray-800 dark:text-white text-lg"><i class="fa-regular fa-rectangle-list"></i> Lista de Entregas</h4>
    </div>

    <div id="routeList"></div>
  </div>

  <!-- Etapa 1: Upload -->
  <div id="step1" class="flex-1 flex flex-col items-center justify-center p-6 min-h-screen">
    <div class="bg-white dark:bg-gray-800 rounded-2xl shadow-lg p-10 w-full max-w-md text-center">
      <div class="w-20 h-20 mx-auto mb-6 bg-gradient-to-br from-[var(--Roday-blue)] to-purple-800 rounded-3xl flex items-center justify-center">
        <img src="img/logo.svg" width="45">
        </div>
      <h1 class="text-4xl font-bold tracking-widest text-gray-800 dark:text-white font-logo">Roday</h1>
      <h3 class="text-xs tracking-widest text-gray-500 dark:text-white mb-8">Inteligência em movimento</h3>
      <label for="fileInput" class="cursor-pointer block border-2 border-dashed border-indigo-400 rounded-xl p-10 hover:bg-indigo-50 transition">
  <i class="fas fa-file-import text-4xl text-indigo-500 mb-4 block"></i>
  <span class="text-indigo-600 font-semibold">Clique ou arraste seu arquivo</span>
  <p class="text-xs text-gray-500 mt-2">Excel (.xlsx/.xls), CSV (.csv), JSON (.json) ou XML (.xml)</p>
  <input type="file" id="fileInput" accept=".xlsx,.xls,.csv,.json,.xml" class="hidden"/>
</label>
    </div>
  </div>

  <!-- Etapa 2: Seleção de Colunas (Versão Simplificada) -->
  <div id="step2" class="hidden flex-1 flex flex-col items-center justify-center p-6 min-h-screen">
      <div class="bg-white rounded-2xl shadow-lg p-8 w-full max-w-md dark:bg-gray-800">
          <h2 class="text-xl font-bold text-indigo-600 mb-2 dark:text-white"><i class="fas fa-list-check mr-2"></i>Informações Adicionais</h2>
          <p class="text-gray-500 mb-6 text-sm dark:text-white">Escolha os campos que deseja visualizar nos detalhes da entrega.</p>
          
          <div id="columnsList" class="space-y-3 mb-6 max-h-60 overflow-y-auto p-4 bg-gray-50 rounded-lg dark:bg-gray-800">
              <!-- As checkboxes serão populadas via JavaScript -->
          </div>

          <button id="confirmColumnsBtn" class="w-full bg-indigo-600 text-white py-3 rounded-lg font-semibold hover:bg-indigo-700 transition">
              <i class="fas fa-check mr-2"></i>Confirmar e Otimizar
          </button>
      </div>
  </div>

  <!-- Etapa 3: Mapa -->
  <div id="step3" class="hidden">
    <div id="map"></div>
    <div id="nextStopBar" class="hidden dark:bg-gray-800 dark:text-white fixed bottom-0 left-0 right-0 bg-white shadow-[0_-5px_20px_rgba(0,0,0,0.1)] rounded-t-2xl z-[1001] p-4">
        <div class="w-full max-w-4xl mx-auto">
            <div class="flex justify-between items-start mb-3 dark:text-white">
            <div id="nextStopInfo" class="text-gray-800 mr-4"></div>
            </div>
            <!-- MODIFICAÇÃO: grid-cols-3 para grid-cols-4 e adição do botão Pendente -->
            <div class="grid grid-cols-4 gap-2">
                <button onclick="openNavigation()" class="col-span-1 bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center text-xs dark:bg-gray-800 dark:text-white dark:border-2 dark:border-solid dark:border-indigo-600 dark:hover:bg-indigo-900">
                  <i class="fas fa-diamond-turn-right mr-2 dark:text-indigo-500"></i>Navegar</button>
                
                <!-- Botão ENTREGUE -->
                <button id="entregueBtn" 
                        onclick="changeStatus(getNextDeliveryId(), 'entregue')" 
                        class="col-span-1 bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-3 px-4 rounded-lg flex items-center justify-center text-xs dark:bg-gray-800 dark:text-white dark:border-2 dark:border-solid dark:border-green-600 dark:hover:bg-green-900">
                    <i class="fas fa-check-double mr-2 text-green-500"></i>
                    <span id="entregueText">Entregue</span>
                </button>

                <!-- Botão NÃO ENTREGUE -->
                <button id="naoEntregueBtn" 
                        onclick="changeStatus(getNextDeliveryId(), 'naoentregue')" 
                        class="col-span-1 bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-3 px-4 rounded-lg flex items-center justify-center text-xs dark:bg-gray-800 dark:text-white dark:border-2 dark:border-solid dark:border-red-600 dark:hover:bg-red-900">
                    <i class="fas fa-box mr-2 text-red-500"></i>
                    <span id="naoEntregueText">Não Entregue</span>
                </button>

                <!-- Botão PENDENTE -->
                <button onclick="changeStatus(getNextDeliveryId(), 'pendente')" 
                        class="col-span-1 bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-3 px-4 rounded-lg flex items-center justify-center text-xs dark:bg-gray-800 dark:text-white dark:border-2 dark:border-solid dark:border-yellow-600 dark:hover:bg-yellow-900">
                    <i class="fas fa-clock mr-2 text-yellow-500"></i>
                    <span id="pendenteText">Pendente</span>
                </button>
            </div>
        </div>
    </div>

  </div>

<script>

  // =================================================================================
// FUNÇÃO DEBOUNCE (ADICIONAR NO INÍCIO DO SCRIPT)
// =================================================================================

function getNextDeliveryId() {
  const next = deliveryData.find(d => d.status === "pendente");
  return next ? next.id : null;
}

function debounce(func, wait, immediate) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      timeout = null;
      if (!immediate) func(...args);
    };
    const callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) func(...args);
  };
}

// Criar versões debounced das funções críticas
const debouncedUpdateUI = debounce(updateUI, 200);
const debouncedUpdateSideList = debounce(updateSideList, 150);
const debouncedUpdateMarkers = debounce(updateMarkers, 250);
// =================================================================================
// VARIÁVEIS GLOBAIS
// =================================================================================
let deliveryData = [], userLocation = null, map, markers = [], routeLayer, nextDeliveryRouteLayer, userMarker;
let selectedColumns = [];
let startPoint = null;
let endPoint = null;
let isRouteOptimized = false;
let markerClusterGroup;
let mapTileLayer;

// Variáveis para rastreamento contínuo
let isTrackingActive = false;
let lastManualMapMove = 0;
let autoCenterDelay = 3000; // 3 segundos após movimento manual
let trackingTimer = null;
let watchId = null;

let addressCorrectionsCache = {};

const iconMapping = {
  'cliente': 'fa-user',
  'telefone': 'fa-phone',
  'stop': 'fa-hashtag',
  'sequence': 'fa-list-ol',
  'tn': 'fa-barcode',
  'cod': 'fa-barcode',
  'cep': 'fa-street-view',
  'Zipcode/Postal code': 'fa-street-view',
  'Postal': 'fa-street-view',
  'observação': 'fa-comment-dots',
  'obs': 'fa-comment-dots',
  'default': 'fa-info-circle'
};

// =================================================================================
// INICIALIZAÇÃO E GERENCIAMENTO DE ESTADO
// =================================================================================
window.addEventListener('load', () => {
  loadSavedState();
  initGeolocation();
});

function saveState() {
  try {
    const stateToSave = {
      deliveryData: deliveryData,
      selectedColumns: selectedColumns,
      startPoint: startPoint,
      endPoint: endPoint,
      currentStep: getCurrentStep(),
      isRouteOptimized: isRouteOptimized,
      isTrackingActive: isTrackingActive // ← ADICIONAR ESTA LINHA
    };
    localStorage.setItem('routeOptimizerState', JSON.stringify(stateToSave));
  } catch (e) { 
    console.error('Erro ao salvar estado:', e); 
  }
}

async function loadSavedState() {
  const savedState = localStorage.getItem('routeOptimizerState');
  if (!savedState) return;
  
  try {
    const state = JSON.parse(savedState);
    
    if (state.currentStep === 'step3' && state.deliveryData?.length > 0) {
      deliveryData = state.deliveryData;
      selectedColumns = state.selectedColumns || [];
      startPoint = state.startPoint;
      endPoint = state.endPoint;
      isRouteOptimized = state.isRouteOptimized || false;
      
      // PROBLEMA PODE ESTAR AQUI - vamos ser mais específicos:
      if (state.hasOwnProperty('isTrackingActive')) {
        isTrackingActive = state.isTrackingActive;
      } else {
        isTrackingActive = false; // valor padrão se não existir
      }

      document.getElementById('step1').classList.add('hidden');
      document.getElementById('step3').classList.remove('hidden');
      
      showMapControls(true);
      await initGeolocation();
      initMap();

      if (isRouteOptimized) {
        if (routeLayer) map.removeLayer(routeLayer);
        const allPoints = deliveryData.map(d => ({ lat: +d.Latitude, lng: +d.Longitude }));
        if (userLocation) allPoints.unshift(userLocation);
        
        routeLayer = await drawRoute(allPoints, { style: { color: "#5e33ea", weight: 5, opacity: 0.7 } });
        if (routeLayer) {
          routeLayer.addTo(map);
          setTimeout(() => map.fitBounds(routeLayer.getBounds(), { padding: [50, 50] }), 500);
        }
      }
      
      if (isTrackingActive) {
        startTracking();
      } else {
        if (locationUpdateInterval) clearInterval(locationUpdateInterval);
          locationUpdateInterval = setInterval(updateLocationPeriodically, 30000);
      }
      
      updateTrackingButtonState();
      updateUI();
      showToast('Rota anterior restaurada!', 'success');
    }
  } catch (e) {
    console.error('Erro ao carregar estado:', e);
    clearState();
  }
}

function clearState() {
  localStorage.removeItem('routeOptimizerState');
  window.location.reload();
}

function getCurrentStep() {
  if (!document.getElementById('step1').classList.contains('hidden')) return 'step1';
  if (!document.getElementById('step2').classList.contains('hidden')) return 'step2';
  if (!document.getElementById('step3').classList.contains('hidden')) return 'step3';
  return null;
}

// =================================================================================
// UPLOAD DE ARQUIVO E PREPARAÇÃO
// =================================================================================
document.getElementById('fileInput').addEventListener('change', handleFileUpload);

async function handleFileUpload(e) {
  const file = e.target.files[0];
  if (!file) return;
  
  const fileName = file.name.toLowerCase();
  let jsonData = [];

  try {
    if (fileName.endsWith('.csv')) {
      jsonData = await processCSVFile(file);
    } else if (fileName.endsWith('.json')) {
      jsonData = await processJSONFile(file);
    } else if (fileName.endsWith('.xml')) {
      jsonData = await processXMLFile(file);
    } else if (fileName.endsWith('.xlsx') || fileName.endsWith('.xls')) {
      jsonData = await processExcelFile(file);
    } else {
      return showToast('Formato não suportado. Use: Excel (.xlsx/.xls), CSV (.csv), JSON (.json) ou XML (.xml)', 'error');
    }

    if (jsonData.length === 0) {
      return showToast('Arquivo vazio ou formato inválido', 'error');
    }

    await processDeliveryData(jsonData);
    
  } catch (error) {
    console.error('Erro ao processar arquivo:', error);
    showToast('Erro ao processar o arquivo. Verifique o formato.', 'error');
    hideProgressModal();
  }
}

// Processa os dados independentemente do formato de origem
async function processDeliveryData(jsonData) {
  const headers = Object.keys(jsonData[0]);
  const findHeader = (keys) => headers.find(h => keys.some(key => h.toLowerCase().includes(key)));

  let latHeader = findHeader(['lat', 'latitude']);
  let lngHeader = findHeader(['lon', 'lng', 'longitude']);
  const addressHeader = findHeader(['address', 'endereço', 'rua', 'endereco']);
  const districtHeader = findHeader(['bairro', 'district']);
  const cityHeader = findHeader(['cidade', 'city']);

  // Se não houver lat/lng, mas houver endereço, prepara para geocodificação
  if ((!latHeader || !lngHeader) && addressHeader) {
    showProgressModal('Iniciando geocodificação...', 0);
    await delay(50);

    for (let i = 0; i < jsonData.length; i++) {
      const row = jsonData[i];
      const fullAddress = [row[addressHeader], row[districtHeader], row[cityHeader]].filter(Boolean).join(', ');
      
      const progress = ((i + 1) / jsonData.length) * 100;
      showProgressModal(`Buscando coordenadas para: ${fullAddress}`, progress);
      
      const coords = await geocodeAddress(fullAddress);
      if (coords) {
        row.Latitude = coords.lat;
        row.Longitude = coords.lng;
      } else {
        row.Latitude = null;
        row.Longitude = null;
        console.warn(`Geocodificação falhou para: ${fullAddress}`);
      }
      await delay(200);
    }
    
    hideProgressModal();
    latHeader = 'Latitude';
    lngHeader = 'Longitude';
  }

  // Validação final
  if (!latHeader || !lngHeader) {
    return showToast('Erro: Não foi possível determinar a Latitude e Longitude das entregas.', 'error');
  }

  // Processa os dados finais
  deliveryData = jsonData
    .filter(row => row[latHeader] && row[lngHeader])
    .map((row, index) => ({
      ...row,
      Latitude: row[latHeader],
      Longitude: row[lngHeader],
      Endereço: addressHeader ? row[addressHeader] : 'Endereço não fornecido',
      STOP: findHeader(['stop']) ? row[findHeader(['stop'])] : index + 1,
      id: index,
      status: "pendente",
    }));

  if(deliveryData.length === 0) {
    return showToast('Nenhuma entrega pôde ser localizada. Verifique os endereços.', 'error');
  }

  // Prepara a lista de colunas para seleção
  const processedHeaders = [latHeader, lngHeader, addressHeader].filter(Boolean);
  const cols = headers.filter(h => !processedHeaders.includes(h));
  
  const container = document.getElementById("columnsList");
  container.innerHTML = cols.map(c => `
    <label class="flex items-center space-x-3 cursor-pointer hover:bg-gray-50 dark:hover:bg-indigo-600 p-2 rounded-lg">
      <input type="checkbox" value="${c}" class="columnChk h-5 w-5 text-indigo-600 border-gray-300 rounded" ${['cliente', 'telefone', 'obs', 'stop', 'sequence'].some(kw => c.toLowerCase().includes(kw)) ? 'checked' : ''}/>
      <span class="text-gray-700 dark:text-white">${c}</span>
    </label>`).join('');

  document.getElementById('step1').classList.add('hidden');
  document.getElementById('step2').classList.remove('hidden');
  
  const fileType = detectFileType(jsonData);
  showToast(`${deliveryData.length} entregas carregadas${fileType}!`, 'success');
}

// Função auxiliar para detectar tipo de arquivo pelo conteúdo
function detectFileType(data) {
  if (data.length === 0) return '';
  
  const firstRow = data[0];
  const keys = Object.keys(firstRow);
  
  // Heurística simples baseada nos campos
  if (keys.some(k => k.toLowerCase().includes('xml') || k.includes('xmlns'))) {
    return ' de arquivo XML';
  } else if (keys.length > 10) {
    return ' de arquivo Excel/CSV';
  } else {
    return ' do arquivo';
  }
}

// Função para processar CSV
async function processCSVFile(file) {
  return new Promise((resolve, reject) => {
    Papa.parse(file, {
      header: true,
      skipEmptyLines: true,
      dynamicTyping: true,
      complete: (results) => {
        if (results.errors.length > 0) {
          console.warn('Erros no CSV:', results.errors);
        }
        resolve(results.data);
      },
      error: (error) => reject(error)
    });
  });
}

// Função para processar JSON
async function processJSONFile(file) {
  const text = await file.text();
  const data = JSON.parse(text);
  
  // Se for um objeto com array dentro, tenta extrair o array
  if (Array.isArray(data)) {
    return data;
  } else if (typeof data === 'object' && data !== null) {
    // Procura por arrays dentro do objeto
    const arrayKeys = Object.keys(data).filter(key => Array.isArray(data[key]));
    if (arrayKeys.length > 0) {
      return data[arrayKeys[0]]; // Pega o primeiro array encontrado
    }
  }
  
  throw new Error('JSON deve conter um array de entregas');
}

// Função para processar XML
async function processXMLFile(file) {
  const text = await file.text();
  const parser = new DOMParser();
  const xmlDoc = parser.parseFromString(text, 'text/xml');
  
  // Verifica erros de parsing
  if (xmlDoc.getElementsByTagName('parsererror').length > 0) {
    throw new Error('XML inválido');
  }
  
  const jsonData = [];
  
  // Tenta encontrar elementos que representam entregas
  const possibleRoots = ['delivery', 'entrega', 'item', 'row', 'record'];
  let deliveryElements = [];
  
  for (const rootName of possibleRoots) {
    deliveryElements = xmlDoc.getElementsByTagName(rootName);
    if (deliveryElements.length > 0) break;
  }
  
  // Se não encontrou, pega o primeiro nível de elementos
  if (deliveryElements.length === 0) {
    const rootElement = xmlDoc.documentElement;
    deliveryElements = rootElement.children;
  }
  
  // Converte elementos XML em objetos JSON
  for (let element of deliveryElements) {
    const delivery = {};
    
    // Pega atributos
    for (let attr of element.attributes) {
      delivery[attr.name] = attr.value;
    }
    
    // Pega elementos filhos
    for (let child of element.children) {
      delivery[child.tagName] = child.textContent;
    }
    
    // Se não tem filhos, pega o texto do elemento
    if (element.children.length === 0 && element.textContent.trim()) {
      delivery['value'] = element.textContent.trim();
    }
    
    jsonData.push(delivery);
  }
  
  return jsonData;
}

// Função original do Excel (renomeada)
async function processExcelFile(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (event) => {
      try {
        const data = new Uint8Array(event.target.result);
        const workbook = XLSX.read(data, { type: 'array' });
        const sheetName = workbook.SheetNames[0];
        const worksheet = workbook.Sheets[sheetName];
        const jsonData = XLSX.utils.sheet_to_json(worksheet);
        resolve(jsonData);
      } catch (error) {
        reject(error);
      }
    };
    reader.onerror = () => reject(new Error('Erro ao ler arquivo Excel'));
    reader.readAsArrayBuffer(file);
  });
}

// Substitua o listener do 'confirmMappingBtn' por este
document.getElementById('confirmColumnsBtn')?.addEventListener('click', () => {
  selectedColumns = [...document.querySelectorAll(".columnChk:checked")].map(c => c.value);
  document.getElementById('step2').classList.add('hidden');
  document.getElementById('step3').classList.remove('hidden');
  
  showMapControls(true);
  initMap();
  optimizeRoute();
});

// =================================================================================
// GEOLOCALIZAÇÃO E GEOCODIFICAÇÃO (Nominatim/OSM)
// =================================================================================

function initGeolocation() {
  return new Promise((resolve) => {
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        pos => { 
          userLocation = { lat: pos.coords.latitude, lng: pos.coords.longitude };
          updateUserMarker(); // ← ADICIONAR ESTA LINHA
          resolve();
        },
        () => { 
            userLocation = { lat: -3.73186, lng: -38.5267 }; // Fallback
            updateUserMarker(); // ← ADICIONAR ESTA LINHA
            showToast('Usando localização padrão. Permita o acesso para maior precisão.', 'warn');
            resolve();
        }
      );
    } else {
      userLocation = { lat: -3.73186, lng: -38.5267 }; // Fallback
      updateUserMarker(); // ← ADICIONAR ESTA LINHA
      showToast('Geolocalização não suportada por este navegador.', 'error');
      resolve();
    }
  });
}

// Função para atualização periódica da localização (sem rastreamento contínuo)
function updateLocationPeriodically() {
  if (!navigator.geolocation) return;
  
  navigator.geolocation.getCurrentPosition(
    pos => {
      const newLocation = { lat: pos.coords.latitude, lng: pos.coords.longitude };
      const hasLocationChanged = !userLocation || 
        Math.abs(userLocation.lat - newLocation.lat) > 0.00001 || 
        Math.abs(userLocation.lng - newLocation.lng) > 0.00001;

      if (hasLocationChanged) {
        userLocation = newLocation;
        updateUserMarker();
      }
    },
    error => console.log('Erro ao atualizar localização:', error),
    { enableHighAccuracy: false, timeout: 5000, maximumAge: 30000 }
  );
}

async function geocodeAddress(address) {
  if (!address) return null;
  try {
    const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&addressdetails=1&q=${encodeURIComponent(address)}&countrycodes=br&limit=1`);
    const data = await response.json();
    if (data && data.length > 0) {
      const result = data[0];
      return { 
        lat: parseFloat(result.lat), 
        lng: parseFloat(result.lon), 
        address: result.display_name,
        addressDetails: result.address // contém bairro, postcode, city, etc.
      };
    }
    return null;
  } catch (error) {
    console.error('Erro na geocodificação:', error);
    return null;
  }
}

function compareAddressDetails(item, geocodeDetails) {
  if (!geocodeDetails) return false;

  // Normaliza strings para comparação simples
  const normalize = str => (str || '').toLowerCase().replace(/\s+/g, '').trim();

  const itemBairro = normalize(item.Bairro || item.bairro);
  const itemCEP = normalize(item['Zipcode/Postal code'] || item.CEP || item.cep);

  const geoBairro = normalize(geocodeDetails.suburb || geocodeDetails.neighbourhood || geocodeDetails.city_district || geocodeDetails.village);
  const geoCEP = normalize(geocodeDetails.postcode);

  // Verifica se bairro e/ou CEP batem (pelo menos um deve bater)
  const bairroMatch = itemBairro && geoBairro && itemBairro === geoBairro;
  const cepMatch = itemCEP && geoCEP && itemCEP === geoCEP;

  return bairroMatch || cepMatch;
}


// =================================================================================
// OTIMIZAÇÃO RÁPIDA E INTELIGENTE (HÍBRIDA)
// =================================================================================

// Cache otimizado para distâncias
let fastDistanceCache = new Map();

// Função rápida que usa haversine primeiro e OSRM apenas quando necessário
async function getSmartDistance(point1, point2, useRealRoute = false) {
    const key = `${point1.lat.toFixed(6)},${point1.lng.toFixed(6)}-${point2.lat.toFixed(6)},${point2.lng.toFixed(6)}`;
    
    if (fastDistanceCache.has(key)) {
        return fastDistanceCache.get(key);
    }
    
    let distance;
    
    if (useRealRoute) {
        // Usa OSRM apenas quando solicitado
        try {
            const coords = `${point1.lng},${point1.lat};${point2.lng},${point2.lat}`;
            const url = `https://router.project-osrm.org/route/v1/driving/${coords}?overview=false`;
            const response = await fetch(url);
            
            if (response.ok) {
                const data = await response.json();
                if (data.routes && data.routes.length > 0) {
                    distance = data.routes[0].distance / 1000;
                } else {
                    distance = haversine(point1, point2);
                }
            } else {
                distance = haversine(point1, point2);
            }
        } catch (error) {
            distance = haversine(point1, point2);
        }
    } else {
        // Usa haversine (muito mais rápido)
        distance = haversine(point1, point2);
    }
    
    fastDistanceCache.set(key, distance);
    return distance;
}

// Algoritmo de otimização rápido e inteligente
async function fastOptimizeRoute(route, startPoint) {
    const totalStops = route.length;
    
    // FASE 1: Rota inicial rápida usando haversine
    showProgressModal('Criando rota inicial rápida...', 10);
    await delay(20);
    
    let optimizedRoute = [];
    let remaining = [...route];
    let currentPoint = startPoint;
    
    // Algoritmo guloso rápido
    while (remaining.length > 0) {
        let nearestIndex = 0;
        let minDistance = Infinity;
        
        for (let i = 0; i < remaining.length; i++) {
            const distance = await getSmartDistance(currentPoint, {
                lat: remaining[i].Latitude,
                lng: remaining[i].Longitude
            }, false); // Usa haversine (rápido)
            
            if (distance < minDistance) {
                minDistance = distance;
                nearestIndex = i;
            }
        }
        
        const nextStop = remaining.splice(nearestIndex, 1)[0];
        optimizedRoute.push(nextStop);
        currentPoint = { lat: nextStop.Latitude, lng: nextStop.Longitude };
        
        const progress = 10 + ((totalStops - remaining.length) / totalStops) * 40;
        showProgressModal(`Rota inicial: ${totalStops - remaining.length}/${totalStops}`, progress);
        await delay(5);
    }
    
    // FASE 2: Refinamento 2-opt rápido (apenas algumas iterações)
    showProgressModal('Refinando rota...', 50);
    await delay(20);
    
    let improved = true;
    let iterations = 0;
    const maxIterations = Math.min(10, Math.floor(totalStops / 8)); // Limita iterações
    
    while (improved && iterations < maxIterations) {
        improved = false;
        
        // Testa apenas algumas trocas por iteração para ser mais rápido
        const step = Math.max(1, Math.floor(optimizedRoute.length / 20));
        
        for (let i = 0; i < optimizedRoute.length - 1; i += step) {
            for (let j = i + step; j < optimizedRoute.length; j += step) {
                const current_i = i;
                const next_i = (i + 1) % optimizedRoute.length;
                const current_j = j;
                const next_j = (j + 1) % optimizedRoute.length;
                
                const currentDistance = 
                    await getSmartDistance({lat: optimizedRoute[current_i].Latitude, lng: optimizedRoute[current_i].Longitude}, 
                                         {lat: optimizedRoute[next_i].Latitude, lng: optimizedRoute[next_i].Longitude}, false) +
                    await getSmartDistance({lat: optimizedRoute[current_j].Latitude, lng: optimizedRoute[current_j].Longitude}, 
                                         {lat: optimizedRoute[next_j].Latitude, lng: optimizedRoute[next_j].Longitude}, false);
                
                const newDistance = 
                    await getSmartDistance({lat: optimizedRoute[current_i].Latitude, lng: optimizedRoute[current_i].Longitude}, 
                                         {lat: optimizedRoute[current_j].Latitude, lng: optimizedRoute[current_j].Longitude}, false) +
                    await getSmartDistance({lat: optimizedRoute[next_i].Latitude, lng: optimizedRoute[next_i].Longitude}, 
                                         {lat: optimizedRoute[next_j].Latitude, lng: optimizedRoute[next_j].Longitude}, false);
                
                if (newDistance < currentDistance) {
                    optimizedRoute = twoOptSwap(optimizedRoute, i + 1, j);
                    improved = true;
                }
            }
        }
        
        iterations++;
        const progress = 50 + (iterations / maxIterations) * 40;
        showProgressModal(`Refinando... (${iterations}/${maxIterations})`, progress);
        await delay(10);
    }
    
    return optimizedRoute;
}

// =================================================================================
// OTIMIZAÇÃO MELHORADA - SUBSTITUA AS FUNÇÕES EXISTENTES
// =================================================================================

const delay = ms => new Promise(res => setTimeout(res, ms));

// Algoritmo específico para circuito (TSP - Traveling Salesman Problem)
async function optimizeCircuitRoute(route, startPoint) {
  const totalStops = route.length;
  
  if (totalStops <= 2) return route;
  
  showProgressModal('Otimizando circuito completo...', 5);
  await delay(50);
  
  // 1. Encontrar a primeira parada (mais próxima do início)
  let firstStopIndex = 0;
  let minDistanceToStart = Infinity;
  
  for (let i = 0; i < route.length; i++) {
    const distance = getDistance(startPoint, {
      lat: route[i].Latitude,
      lng: route[i].Longitude
    });
    if (distance < minDistanceToStart) {
      minDistanceToStart = distance;
      firstStopIndex = i;
    }
  }
  
  const firstStop = route[firstStopIndex];
  let remainingStops = route.filter((_, index) => index !== firstStopIndex);
  
  showProgressModal('Primeira parada definida...', 15);
  await delay(50);
  
  // 2. Construir o circuito usando algoritmo de inserção mais próxima
  let circuitRoute = [firstStop];
  
  while (remainingStops.length > 0) {
    let bestInsertPosition = -1;
    let bestStopIndex = -1;
    let minIncreaseDistance = Infinity;
    
    // Para cada parada restante
    for (let stopIndex = 0; stopIndex < remainingStops.length; stopIndex++) {
      const candidateStop = remainingStops[stopIndex];
      
      // Testa inserir em cada posição possível do circuito
      for (let insertPos = 0; insertPos <= circuitRoute.length; insertPos++) {
        const increasedDistance = calculateInsertionCost(
          circuitRoute, candidateStop, insertPos, startPoint
        );
        
        if (increasedDistance < minIncreaseDistance) {
          minIncreaseDistance = increasedDistance;
          bestInsertPosition = insertPos;
          bestStopIndex = stopIndex;
        }
      }
    }
    
    // Insere a melhor parada na melhor posição
    const bestStop = remainingStops.splice(bestStopIndex, 1)[0];
    circuitRoute.splice(bestInsertPosition, 0, bestStop);
    
    const progress = 15 + ((totalStops - remainingStops.length) / totalStops) * 60;
    showProgressModal(`Construindo circuito: ${totalStops - remainingStops.length}/${totalStops}`, progress);
    await delay(30);
  }
  
  showProgressModal('Otimizando circuito com 2-Opt...', 75);
  await delay(50);
  
  // 3. Refinamento com 2-Opt específico para circuito
  circuitRoute = await circuitTwoOpt(circuitRoute, startPoint);
  
  showProgressModal('Verificando última parada...', 90);
  await delay(50);
  
  // 4. Otimização final: garantir que a última parada seja ótima para retorno
  circuitRoute = optimizeLastStop(circuitRoute, startPoint);
  
  return circuitRoute;
}

// Calcula o custo de inserir uma parada em uma posição específica do circuito
function calculateInsertionCost(currentRoute, newStop, insertPosition, startPoint) {
  const newStopPoint = { lat: newStop.Latitude, lng: newStop.Longitude };
  
  if (currentRoute.length === 0) {
    // Primeira inserção: custo é ida + volta
    return 2 * getDistance(startPoint, newStopPoint);
  }
  
  if (insertPosition === 0) {
    // Inserção no início
    const nextPoint = { lat: currentRoute[0].Latitude, lng: currentRoute[0].Longitude };
    const oldCost = getDistance(startPoint, nextPoint);
    const newCost = getDistance(startPoint, newStopPoint) + getDistance(newStopPoint, nextPoint);
    return newCost - oldCost;
  }
  
  if (insertPosition === currentRoute.length) {
    // Inserção no final
    const prevPoint = { lat: currentRoute[currentRoute.length - 1].Latitude, lng: currentRoute[currentRoute.length - 1].Longitude };
    const oldCost = getDistance(prevPoint, startPoint);
    const newCost = getDistance(prevPoint, newStopPoint) + getDistance(newStopPoint, startPoint);
    return newCost - oldCost;
  }
  
  // Inserção no meio
  const prevPoint = { lat: currentRoute[insertPosition - 1].Latitude, lng: currentRoute[insertPosition - 1].Longitude };
  const nextPoint = { lat: currentRoute[insertPosition].Latitude, lng: currentRoute[insertPosition].Longitude };
  
  const oldCost = getDistance(prevPoint, nextPoint);
  const newCost = getDistance(prevPoint, newStopPoint) + getDistance(newStopPoint, nextPoint);
  
  return newCost - oldCost;
}

// 2-Opt específico para circuito (considera retorno ao início)
async function circuitTwoOpt(route, startPoint) {
  let bestRoute = [...route];
  let bestDistance = calculateCircuitDistance(bestRoute, startPoint);
  let improved = true;
  let iterations = 0;
  const maxIterations = Math.min(100, route.length * 3);
  
  while (improved && iterations < maxIterations) {
    improved = false;
    
    for (let i = 0; i < bestRoute.length - 1; i++) {
      for (let j = i + 2; j < bestRoute.length; j++) {
        // Aplica 2-opt swap
        const newRoute = twoOptSwap(bestRoute, i, j);
        const newDistance = calculateCircuitDistance(newRoute, startPoint);
        
        if (newDistance < bestDistance) {
          bestRoute = newRoute;
          bestDistance = newDistance;
          improved = true;
        }
      }
      
      if (i % 5 === 0) await delay(10);
    }
    
    iterations++;
    
    if (iterations % 10 === 0) {
      const progress = 75 + (iterations / maxIterations) * 15;
      showProgressModal(`2-Opt circuito: iteração ${iterations}`, progress);
      await delay(20);
    }
  }
  
  return bestRoute;
}

// Calcula distância total do circuito (inclui retorno ao início)
function calculateCircuitDistance(route, startPoint) {
  if (route.length === 0) return 0;
  if (route.length === 1) {
    const stopPoint = { lat: route[0].Latitude, lng: route[0].Longitude };
    return 2 * getDistance(startPoint, stopPoint);
  }
  
  let totalDistance = 0;
  
  // Distância do início para primeira parada
  const firstStop = { lat: route[0].Latitude, lng: route[0].Longitude };
  totalDistance += getDistance(startPoint, firstStop);
  
  // Distâncias entre paradas consecutivas
  for (let i = 0; i < route.length - 1; i++) {
    const currentStop = { lat: route[i].Latitude, lng: route[i].Longitude };
    const nextStop = { lat: route[i + 1].Latitude, lng: route[i + 1].Longitude };
    totalDistance += getDistance(currentStop, nextStop);
  }
  
  // Distância da última parada de volta ao início
  const lastStop = { lat: route[route.length - 1].Latitude, lng: route[route.length - 1].Longitude };
  totalDistance += getDistance(lastStop, startPoint);
  
  return totalDistance;
}

// Otimiza especificamente a última parada para minimizar retorno
function optimizeLastStop(route, startPoint) {
  if (route.length < 3) return route;
  
  // Considera os últimos 30% das paradas como candidatas a última
  const candidateCount = Math.max(2, Math.ceil(route.length * 0.3));
  const candidates = route.slice(-candidateCount);
  
  let bestLastIndex = -1;
  let minReturnDistance = Infinity;
  
  candidates.forEach((candidate, index) => {
    const candidatePoint = { lat: candidate.Latitude, lng: candidate.Longitude };
    const distanceToStart = getDistance(candidatePoint, startPoint);
    
    if (distanceToStart < minReturnDistance) {
      minReturnDistance = distanceToStart;
      bestLastIndex = route.length - candidateCount + index;
    }
  });
  
  // Se encontrou uma última parada melhor, reordena
  if (bestLastIndex !== route.length - 1) {
    const bestLastStop = route[bestLastIndex];
    const newRoute = route.filter((_, index) => index !== bestLastIndex);
    newRoute.push(bestLastStop);
    return newRoute;
  }
  
  return route;
}

// Algoritmo simples para nearest neighbor sem circuito
async function simpleNearestNeighborRoute(route, startPoint) {
  let optimizedRoute = [];
  let remaining = [...route];
  let currentPoint = startPoint;
  
  while (remaining.length > 0) {
    let nearestIndex = 0;
    let minDistance = Infinity;
    
    for (let i = 0; i < remaining.length; i++) {
      const distance = getDistance(currentPoint, {
        lat: remaining[i].Latitude,
        lng: remaining[i].Longitude
      });
      
      if (distance < minDistance) {
        minDistance = distance;
        nearestIndex = i;
      }
    }
    
    const nextStop = remaining.splice(nearestIndex, 1)[0];
    optimizedRoute.push(nextStop);
    currentPoint = { lat: nextStop.Latitude, lng: nextStop.Longitude };
    
    await delay(10);
  }
  
  return optimizedRoute;
}

// FUNÇÃO PRINCIPAL ATUALIZADA - SUBSTITUA A optimizeRoute EXISTENTE
async function optimizeRoute() {
  if (deliveryData.length < 3) {
    return showToast('São necessárias pelo menos 3 paradas para otimizar.', 'warn');
  }

  const optimizeBtn = document.getElementById('reOptimizeBtn');
  if (optimizeBtn) {
    optimizeBtn.disabled = true;
    optimizeBtn.classList.add('opacity-50', 'cursor-not-allowed');
  }

  await delay(50);

  let startPoint = userLocation;
  if (!startPoint) {
    startPoint = { lat: deliveryData[0].Latitude, lng: deliveryData[0].Longitude };
    showToast('Localização não encontrada. Iniciando da primeira entrega.', 'warn');
  }

  // Reseta status
  deliveryData.forEach(d => d.status = "pendente");

  try {
    // Verifica se deve fazer circuito completo
    const useReturnToStart = localStorage.getItem('useReturnToStart') === 'true';
    
    let optimizedRoute;
    
    if (useReturnToStart) {
      showProgressModal('Otimizando circuito completo (ida e volta)...', 0);
      optimizedRoute = await optimizeCircuitRoute(deliveryData, startPoint);
      
      const circuitDistance = calculateCircuitDistance(optimizedRoute, startPoint);
      showToast(`Circuito otimizado! ${optimizedRoute.length} paradas, distância total: ${circuitDistance.toFixed(1)}km (ida e volta)`, 'success');
    } else {
      showProgressModal('Otimizando rota simples (apenas ida)...', 0);
      optimizedRoute = await simpleNearestNeighborRoute(deliveryData, startPoint);
      
      const simpleDistance = calculateSimpleRouteDistance(optimizedRoute, startPoint);
      showToast(`Rota otimizada! ${optimizedRoute.length} paradas, distância total: ${simpleDistance.toFixed(1)}km`, 'success');
    }

    // Finalização
    deliveryData = optimizedRoute.map((d, i) => ({ ...d, Sequence: i + 1 }));
    isRouteOptimized = true;

    hideProgressModal();

  } catch (error) {
    console.error('Erro na otimização:', error);
    showToast('Erro na otimização. Usando algoritmo simples...', 'error');
    
    // Fallback
    let fallbackRoute = await simpleNearestNeighborRoute(deliveryData, startPoint);
    deliveryData = fallbackRoute.map((d, i) => ({ ...d, Sequence: i + 1 }));
    isRouteOptimized = true;
    hideProgressModal();
  }

  if (optimizeBtn) {
    optimizeBtn.disabled = false;
    optimizeBtn.classList.remove('opacity-50', 'cursor-not-allowed');
  }

  saveState();
  updateUI();
  startTracking();

  setTimeout(() => {
    if (routeLayer && map) {
      map.fitBounds(routeLayer.getBounds(), { padding: [50, 50] });
    }
  }, 1000);
}

// Função auxiliar para calcular distância de rota simples
function calculateSimpleRouteDistance(route, startPoint) {
  if (route.length === 0) return 0;
  
  let totalDistance = 0;
  let currentPoint = startPoint;
  
  for (const stop of route) {
    const stopPoint = { lat: stop.Latitude, lng: stop.Longitude };
    totalDistance += getDistance(currentPoint, stopPoint);
    currentPoint = stopPoint;
  }
  
  return totalDistance;
}

// Função que implementa o algoritmo 2-Opt
async function apply2Opt(route) {
    let bestRoute = [...route];
    let improved = true;
    let iteration = 0;

    while (improved) {
        improved = false;
        for (let i = 0; i < bestRoute.length - 1; i++) {
            for (let j = i + 1; j < bestRoute.length; j++) {
                // Calcula a distância da rota atual e da rota com a troca
                const currentDistance = calculateDistance(bestRoute[i], bestRoute[(i + 1) % bestRoute.length]) + calculateDistance(bestRoute[j], bestRoute[(j + 1) % bestRoute.length]);
                const newDistance = calculateDistance(bestRoute[i], bestRoute[j]) + calculateDistance(bestRoute[(i + 1) % bestRoute.length], bestRoute[(j + 1) % bestRoute.length]);

                if (newDistance < currentDistance) {
                    // Se a troca melhora a rota, realiza o "swap"
                    bestRoute = twoOptSwap(bestRoute, i + 1, j);
                    improved = true;
                }
            }
        }
        iteration++;
        if (iteration % 5 === 0) { // Atualiza a UI a cada 5 iterações para não sobrecarregar
            showProgressModal(`Refinando... (Iteração ${iteration})`, 25 + (iteration % 70));
            await delay(1);
        }
    }
    return bestRoute;
}

// Função que orienta a rota para começar no ponto mais próximo do início
function orientRoute(route, startPoint) {
    let bestStartIndex = 0;
    let minDistance = Infinity;

    route.forEach((stop, index) => {
        const dist = haversine(startPoint, { lat: stop.Latitude, lng: stop.Longitude });
        if (dist < minDistance) {
            minDistance = dist;
            bestStartIndex = index;
        }
    });

    // Gira o array para que a rota comece no ponto mais próximo
    return [...route.slice(bestStartIndex), ...route.slice(0, bestStartIndex)];
}

// Função auxiliar que realiza a troca (inverte um segmento da rota)
function twoOptSwap(route, i, k) {
    const part1 = route.slice(0, i);
    const part2 = route.slice(i, k + 1).reverse();
    const part3 = route.slice(k + 1);
    return [...part1, ...part2, ...part3];
}

// Função auxiliar para calcular a distância (usa a haversine)
function calculateDistance(stop1, stop2) {
    if (!stop1 || !stop2) return 0;
    return haversine({ lat: stop1.Latitude, lng: stop1.Longitude }, { lat: stop2.Latitude, lng: stop2.Longitude });
}

async function reOptimizeFromCurrentLocation() {
  toggleMenu(false);
  showToast('Reotimizando a rota...', 'info');
  await optimizeRoute(); // 🔹 usa exatamente a mesma lógica da otimização inicial
}

// Função para desenhar a rota no mapa
async function drawRoute(points, options) {
  if (points.length < 2) return null;
  const coords = points.map(p => `${p.lng},${p.lat}`).join(';');
  const url = `https://router.project-osrm.org/route/v1/driving/${coords}?overview=full&geometries=geojson`;
  try {
    const res = await fetch(url );
    const data = await res.json();
    if (data.routes && data.routes.length) {
      return L.geoJSON(data.routes[0].geometry, { style: options.style });
    }
  } catch (error) { console.error('Erro ao desenhar rota OSRM:', error); }
  return null;
}


// =================================================================================
// ATUALIZAÇÃO DA INTERFACE (UI)
// =================================================================================

function updateMapTheme() {
    if (!map) return;
    if (mapTileLayer) {
        map.removeLayer(mapTileLayer);
    }

    // Detecta se o tema da interface está em modo escuro
    const isDarkMode = document.documentElement.classList.contains('dark');
    
    let url, attribution;

    if (isDarkMode) {
        // Tema escuro do mapa
        url = 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png';
        attribution = '&copy; OpenStreetMap &copy; CARTO';
    } else {
        // Tema claro do mapa
        url = 'https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png';
        attribution = '&copy; OpenStreetMap &copy; CARTO';
    }

    mapTileLayer = L.tileLayer(url, { attribution, maxZoom: 19 });
    mapTileLayer.addTo(map);
}

// Modifique a função initMap para usar a nova função de tema
function initMap() {
  if (!map) {
      map = L.map('map', { zoomControl: false }).setView(userLocation || [-3.73, -38.52], 13);
      updateMapTheme(); // Usa a função de tema para inicializar
  }
}

function updateUI() {
  if (!map) initMap();
  updateMarkers();
  showNextStop();
  updateStats();
  updateRouteLines();
  updateSideList();
}

async function updateRouteLines() {
  await drawAllRoutes();
}

function updateMarkers() {
  if (!map) return;
  markers.forEach(m => m.remove());
  markers = [];
  const next = deliveryData.find(d => d.status === "pendente");

  deliveryData.forEach(d => {
    const isNext = next && d.id === next.id;
    const color = d.status === "entregue" ? "#28a745" : d.status === "naoentregue" ? "#dc3545" : isNext ? "#ff6b35" : "#007bff";
    const size = isNext ? 38 : 30;
    const zIndex = isNext ? 1000 : 500;

    const iconHtml = `<div style="background-color:${color}; color:white; border-radius:50%; width:${size}px; height:${size}px; display:flex; align-items:center; justify-content:center; font-size:14px; font-weight:bold; border: 2px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3);">${d.Sequence}</div>`;
    const marker = L.marker([+d.Latitude, +d.Longitude], {
      icon: L.divIcon({ className: '', html: iconHtml }),
      zIndexOffset: zIndex
    }).addTo(map);

    // --- SOLUÇÃO: LÓGICA DE ÍCONES PERSONALIZADOS PARA O POPUP ---
    const defaultColumns = ['Destination Address', 'Endereço'];
    const endereco = d['Destination Address'] || d['Endereço'] || 'Sem endereço';

    const extraInfoHtml = selectedColumns
      .filter(col => !defaultColumns.includes(col) && d[col])
      .map(col => {
        // Reutiliza a mesma lógica de mapeamento de ícones
        const lowerCol = col.toLowerCase();
        let iconClass = iconMapping.default;

        for (const key in iconMapping) {
          if (lowerCol.includes(key)) {
            iconClass = iconMapping[key];
            break;
          }
        }
        // Retorna o HTML com o ícone e o valor
        return `<div class="flex items-center mb-1"><i class="fas ${iconClass} w-5 text-center mr-2"></i><span>${d[col]}</span></div>`;
      })
      .join(''); // Junta as divs verticalmente

    let popupContent = `
      <div style="min-width: 200px; font-family: 'Inter', sans-serif;">
        <h2 class="popup-title dark:text-white text-lg"><b>Parada ${d.Sequence}</b></h2>
        <p class="popup-info dark:text-white text-xs">${endereco}</p>
        
        ${extraInfoHtml ? `
          <hr>
          <div class="popup-extra-info mt-2 dark:text-white">
            ${extraInfoHtml}
          </div>
        ` : ''}
        
        <hr>
        
        <div style="display: flex; justify-content: space-around; align-items: center; margin-top: 10px;">
          <button title="Entregue" onclick="changeStatus(${d.id}, 'entregue')" style="background: #10b981; color: white; border: none; border-radius: 50%; width: 36px; height: 36px; cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center;"><i class="fas fa-check"></i></button>
          <button title="Não Entregue" onclick="changeStatus(${d.id}, 'naoentregue')" style="background: #ef4444; color: white; border: none; border-radius: 50%; width: 36px; height: 36px; cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center;"><i class="fas fa-times"></i></button>
          <button title="Pendente" onclick="changeStatus(${d.id}, 'pendente')" style="background: #f59e0b; color: white; border: none; border-radius: 50%; width: 36px; height: 36px; cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center;"><i class="fas fa-clock"></i></button>
        </div>
      </div>
    `;
    // --- FIM DA SOLUÇÃO ---

    marker.bindPopup(popupContent, { className: 'dark-theme-popup' });
    markers.push(marker);
  });
}

function showNextStop() {
  const next = deliveryData.find(d => d.status === "pendente");
  const nextStopBar = document.getElementById('nextStopBar');
  
  if (!next) {
    nextStopBar.classList.add("hidden");
    const allDone = deliveryData.every(d => d.status !== 'pendente');
    if (allDone && deliveryData.length > 0) showToast("🎉 Rota Concluída!", 'success');
    return;
  }

  const entreguesCount = deliveryData.filter(d => d.status === 'entregue').length;
  const naoEntreguesCount = deliveryData.filter(d => d.status === 'naoentregue').length;
  const pendentesCount = deliveryData.filter(d => d.status === 'pendente').length;
  const total = deliveryData.length;
  
  const endereco = next['Destination Address'] || next['Endereço'] || 'Endereço não disponível';

  // --- SOLUÇÃO: LÓGICA DE ÍCONES PERSONALIZADOS INTEGRADA ---
  const defaultColumns = ['Destination Address', 'Endereço'];
  
  const extraInfoHtml = selectedColumns
    .filter(col => !defaultColumns.includes(col) && next[col])
    .map(col => {
      // Procura por uma correspondência no mapeamento de ícones
      const lowerCol = col.toLowerCase();
      let iconClass = iconMapping.default;

      for (const key in iconMapping) {
        if (lowerCol.includes(key)) {
          iconClass = iconMapping[key];
          break;
        }
      }
      
      // Retorna o HTML com o ícone correto e o valor da coluna
      return `<span class="text-xs text-gray-500 dark:text-gray-300 flex items-center flex-shrink-0"><i class="fas ${iconClass} w-4 text-center mr-1"></i>${next[col]}</span>`;
    })
    .join(''); // Remove o separador " | " para usar o espaçamento do flexbox

  let infoHtml = `
    <div>
      <div class="flex justify-between items-center mb-1">
        <h3 class="text-lg font-bold text-gray-800 dark:text-white"><span class="text-sm font-light text-gray-600 dark:text-gray-300">${entreguesCount + naoEntreguesCount} / ${total} Concluídas</span><br>Próxima Parada: ${next.Sequence}</h3>
        
      </div>
      <p class="text-sm text-gray-600 mb-2 dark:text-gray-400">${endereco}</p>
      
      ${extraInfoHtml ? `
        <hr class="border-gray-200 dark:border-gray-600 my-2">
        <div class="flex items-center space-x-4 overflow-x-auto pb-1">
          ${extraInfoHtml}
        </div>
      ` : ''}
    </div>
  `;
  // --- FIM DA SOLUÇÃO ---
  
  document.getElementById('nextStopInfo').innerHTML = infoHtml;

  document.getElementById('entregueText').textContent = `Entregue (${entreguesCount})`;
  document.getElementById('naoEntregueText').textContent = `Não Entregue (${naoEntreguesCount})`;
  document.getElementById('pendenteText').textContent = `Pendente (${pendentesCount})`;

  nextStopBar.classList.remove("hidden");
}

function changeStatus(deliveryId, newStatus) {
  const delivery = deliveryData.find(d => d.id === deliveryId);
  if (delivery) {
    delivery.status = newStatus;
    const messages = {
      'entregue': { text: `Pacote #${delivery.STOP} marcado como Entregue!`, type: 'success' },
      'naoentregue': { text: `Pacote #${delivery.STOP} marcado como Não Entregue`, type: 'warn' },
      'pendente': { text: `Pacote #${delivery.STOP} marcado como Pendente`, type: 'info' }
    };
    if (messages[newStatus]) {
        showToast(messages[newStatus].text, messages[newStatus].type);
    }
    saveState();
    debouncedUpdateUI(); // ← MUDANÇA AQUI
  }
}

// --- FUNÇÃO markNext MODIFICADA ---
function markNext(status) {
  const next = deliveryData.find(d => d.status === "pendente");
  if (next) {
    // Reutiliza a nova função para manter a lógica centralizada
    changeStatus(next.id, status);
  }
}

function updateStats() {
  const total = deliveryData.length;
  const entregues = deliveryData.filter(d => d.status === 'entregue').length;
  const naoEntregues = deliveryData.filter(d => d.status === 'naoentregue').length;
  const pendentes = total - entregues - naoEntregues;
  const progress = total > 0 ? Math.round(((entregues + naoEntregues) / total) * 100) : 0;
  
  document.getElementById('routeStats').innerHTML = `
    <div class="space-y-2">
      <div class="flex justify-between">
        <span>Total:</span><span class="font-semibold text-indigo-600 dark:text-indigo-300">${total}</span>
      </div>
      <div class="flex justify-between">
        <span>Entregues:</span><span class="font-semibold text-green-600 dark:text-green-400">${entregues}</span>
      </div>
      <div class="flex justify-between">
        <span>Não Entregues:</span><span class="font-semibold text-red-600 dark:text-red-400">${naoEntregues}</span>
      </div>
      <div class="flex justify-between">
        <span>Pendentes:</span><span class="font-semibold text-yellow-600 dark:text-yellow-400">${pendentes}</span>
      </div>
      <div class="mt-3 pt-2 border-t border-indigo-200 dark:border-gray-700">
        <div class="flex justify-between mb-1">
          <span class="text-sm font-medium">Progresso:</span>
          <span class="text-sm font-semibold">${progress}%</span>
        </div>
        <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2.5">
          <div class="bg-indigo-600 dark:bg-indigo-400 h-2.5 rounded-full" style="width: ${progress}%"></div>
        </div>
      </div>
    </div>`;

}

function updateSideList() {
    const container = document.getElementById('routeList');
    container.innerHTML = deliveryData.map(d => {
        const statusConfig = {
            entregue: { bg: 'bg-green-50 border-green-200', text: 'text-green-700', icon: 'fa-check-circle' },
            naoentregue: { bg: 'bg-red-50 border-red-200', text: 'text-red-700', icon: 'fa-times-circle' },
            pendente: { bg: 'bg-yellow-50 border-yellow-200', text: 'text-yellow-700', icon: 'fa-clock' }
        };
        const config = statusConfig[d.status] || statusConfig.pendente;
        
        const endereco = d['Destination Address'] || d['Endereço'] || 'Sem endereço';

        return `
          <div class="route-item p-3 rounded-lg mb-2 border ${config.bg} flex justify-between items-center cursor-move transition-all duration-200 hover:shadow-md" data-delivery-id="${d.id}">
            <div class="flex items-center space-x-3 overflow-hidden flex-1">
              <i class="fas fa-grip-vertical text-gray-400"></i>
              <div class="w-10 h-10 bg-indigo-600 text-white rounded-full flex items-center justify-center text-base font-bold flex-shrink-0" title="Parada Otimizada ${d.Sequence}">
                ${d.Sequence}
              </div>
              <div class="flex-1 min-w-0">
                <span class="text-sm font-semibold text-gray-800 truncate block">Pacote: <em>#${d.STOP}</em></span>
                <span class="text-xs text-gray-500 truncate block">${endereco}</span>
              </div>
            </div>
            
            <div class="flex items-center space-x-3 flex-shrink-0">
              <div class="flex items-center space-x-2">
                
                <i class="fas ${config.icon} ${config.text}"></i>
                <span class="${config.text} font-medium capitalize text-xs">${d.status.replace('naoentregue', 'não entregue')}</span>
              </div>
              
              <!-- BOTÃO DE LIXEIRA CORRIGIDO -->
              <button onclick="removeDelivery(${d.id})" 
                      class="w-8 h-8 bg-red-500 hover:bg-red-600 text-white rounded-full flex items-center justify-center transition-colors duration-200 shadow-sm hover:shadow-md"
                      title="Remover parada">
                <i class="fas fa-trash text-xs"></i>
              </button>
            </div>
          </div>`;
    }).join('');
    
    // Inicializa o Sortable após criar os elementos
    initializeSortable();
}

// =================================================================================
// AÇÕES DO USUÁRIO E EVENTOS
// =================================================================================
function markNext(status) {
  const next = deliveryData.find(d => d.status === "pendente");
  if (next) {
    next.status = status;
    const messages = {
      'entregue': { text: 'Entrega Realizada!', type: 'success' },
      'naoentregue': { text: 'Entrega Não Realizada', type: 'warn' }
    };
    if (messages[status]) {
        showToast(messages[status].text, messages[status].type);
    }
    saveState();
    updateUI();
  }
}

function openNavigation() {
    const next = deliveryData.find(d => d.status === "pendente");
    if (next) {
        const navApp = localStorage.getItem('navApp') || 'google';
        let url;

        if (navApp === 'waze') {
            url = `https://www.waze.com/ul?ll=${next.Latitude},${next.Longitude}&navigate=yes`;
        } else if (navApp === 'apple' ) {
            url = `http://maps.apple.com/?daddr=${next.Latitude},${next.Longitude}`;
        } else { // Padrão é Google Maps
            url = `https://www.google.com/maps/dir/?api=1&destination=${next.Latitude},${next.Longitude}`;
        }
        
        window.open(url, '_blank' );
    }
}

function startTracking() {
  if (locationUpdateInterval) {
    clearInterval(locationUpdateInterval);
    locationUpdateInterval = null;
  }

  if (!navigator.geolocation) {
    showToast('Geolocalização não disponível neste dispositivo', 'error');
    return;
  }

  // Para qualquer rastreamento anterior
  if (watchId !== null) {
    navigator.geolocation.clearWatch(watchId);
  }

  const watchOptions = { 
    enableHighAccuracy: true, 
    timeout: 10000, 
    maximumAge: 1000 
  };

  let lastVibrationTime = 0;
  isTrackingActive = true;
  saveState();
  updateUserMarker();

  // Adiciona listener para detectar movimento manual do mapa
  if (map) {
    map.on('movestart', onManualMapMove);
    map.on('zoomstart', onManualMapMove);
  }

  watchId = navigator.geolocation.watchPosition(
    (pos) => {
      const newLocation = { lat: pos.coords.latitude, lng: pos.coords.longitude };
      const hasLocationChanged = !userLocation || 
        Math.abs(userLocation.lat - newLocation.lat) > 0.00001 || 
        Math.abs(userLocation.lng - newLocation.lng) > 0.00001;

      userLocation = newLocation;

      // Atualiza ou cria o marcador do usuário
      updateUserMarker();

      // Centraliza automaticamente se necessário
      if (hasLocationChanged) {
        autoCenterIfNeeded();
      }

      // Verifica proximidade com próxima entrega
      checkProximityToNextDelivery(lastVibrationTime);
    },
    (error) => {
      console.error('Erro de geolocalização:', error);
      showToast(`Erro ao rastrear localização: ${error.message}`, 'error');
    },
    watchOptions
  );

  showToast('Rastreamento ativado - sua localização será centralizada automaticamente', 'success');
  updateTrackingButtonState()
}

function onManualMapMove() {
  lastManualMapMove = Date.now();
  
  // Cancela timer anterior se existir
  if (trackingTimer) {
    clearTimeout(trackingTimer);
  }

  // Programa nova centralização após o delay
  trackingTimer = setTimeout(() => {
    if (isTrackingActive && userLocation) {
      map.setView([userLocation.lat, userLocation.lng], map.getZoom(), {
        animate: true,
        pan: { duration: 1 }
      });
    }
  }, autoCenterDelay);
}

function autoCenterIfNeeded() {
  if (!isTrackingActive || !userLocation || !map) return;

  const now = Date.now();
  const timeSinceManualMove = now - lastManualMapMove;

  // Se não houve movimento manual recente, centraliza imediatamente
  if (timeSinceManualMove > autoCenterDelay || lastManualMapMove === 0) {
    map.setView([userLocation.lat, userLocation.lng], Math.max(map.getZoom(), 15), {
      animate: true,
      pan: { duration: 1 }
    });
  }
}

function updateUserMarker() {
  if (!userLocation || !map) return;

  if (!userMarker) {
    // Ícone diferente baseado no estado do rastreamento
    const createUserIcon = () => {
      if (isTrackingActive) {
        // Ícone animado para rastreamento ativo
        return L.divIcon({
          className: "",
          html: `<div class="relative">
                   <div class="w-6 h-6 bg-blue-500 rounded-full border-4 border-white shadow-md"></div>
                   <div class="absolute inset-0 rounded-full bg-blue-400 opacity-50 animate-ping"></div>
                 </div>`
        });
      } else {
        // Ícone estático para localização sem rastreamento
        return L.divIcon({
          className: "",
          html: `<div class="w-6 h-6 bg-blue-500 rounded-full border-4 border-white shadow-md"></div>`
        });
      }
    };

    userMarker = L.marker([userLocation.lat, userLocation.lng], { 
      icon: createUserIcon(),
      zIndexOffset: 1000
    }).addTo(map).bindPopup("📍 Você está aqui");
  } else {
    userMarker.setLatLng([userLocation.lat, userLocation.lng]);
    
    // Atualiza o ícone baseado no estado do rastreamento
    const newIcon = isTrackingActive ? 
      L.divIcon({
        className: "",
        html: `<div class="relative">
                 <div class="w-6 h-6 bg-blue-500 rounded-full border-4 border-white shadow-md"></div>
                 <div class="absolute inset-0 rounded-full bg-blue-400 opacity-50 animate-ping"></div>
               </div>`
      }) :
      L.divIcon({
        className: "",
        html: `<div class="w-6 h-6 bg-blue-500 rounded-full border-4 border-white shadow-md"></div>`
      });
    
    userMarker.setIcon(newIcon);
  }
}

function checkProximityToNextDelivery(lastVibrationTime) {
  const nextDelivery = deliveryData.find(d => d.status === "pendente");
  if (!nextDelivery || !userLocation) return;

  const distanceToNext = haversine(userLocation, { 
    lat: +nextDelivery.Latitude, 
    lng: +nextDelivery.Longitude 
  });

  // Auto-zoom quando próximo
  const autoZoomEnabled = localStorage.getItem('autoZoom') !== 'false';
  if (autoZoomEnabled && distanceToNext < 0.5) {
    const bounds = L.latLngBounds([
      userLocation, 
      { lat: +nextDelivery.Latitude, lng: +nextDelivery.Longitude }
    ]);
    map.fitBounds(bounds, { padding: [80, 80], maxZoom: 17 });
  }

  // Vibração quando muito próximo
  const now = Date.now();
  if (distanceToNext < 0.1 && (now - lastVibrationTime > 30000)) {
    if (navigator.vibrate) {
      navigator.vibrate([200, 100, 200]);
      showToast(`Você está chegando na Parada ${nextDelivery.Sequence}!`, 'info');
      lastVibrationTime = now;
    }
  }
}

let locationUpdateInterval = null;

function stopTracking() {
  if (watchId !== null) {
    navigator.geolocation.clearWatch(watchId);
    watchId = null;
  }
  
  if (trackingTimer) {
    clearTimeout(trackingTimer);
    trackingTimer = null;
  }
  
  isTrackingActive = false;
  saveState();
  
  // Remove listeners do mapa
  if (map) {
    map.off('movestart', onManualMapMove);
    map.off('zoomstart', onManualMapMove);
  }
  
  // ← ADICIONAR: Inicia atualizações periódicas quando para o rastreamento
  if (locationUpdateInterval) clearInterval(locationUpdateInterval);
  locationUpdateInterval = setInterval(updateLocationPeriodically, 30000); // A cada 30 segundos
  
  updateUserMarker(); // Atualiza o ícone para versão estática
  showToast('Rastreamento desativado', 'info');
  updateTrackingButtonState();
}

function updateTrackingButtonState() {
  const btn = document.getElementById('toggleTrackingBtn');
  const icon = btn.querySelector('i');
  
  if (isTrackingActive) {
    btn.classList.remove('tracking-inactive');
    btn.classList.add('tracking-active');
    btn.title = 'Desativar Rastreamento';
    icon.className = 'fas fa-location-arrow text-xl text-white';
  } else {
    btn.classList.remove('tracking-active');
    btn.classList.add('tracking-inactive');
    btn.title = 'Ativar Rastreamento';
    icon.className = 'fas fa-location-arrow text-xl text-gray-400';
  }
}

// Função auxiliar que apenas busca os dados da rota
async function fetchRouteData(points) {
  if (points.length < 2) return null;
  const coords = points.map(p => `${p.lng},${p.lat}`).join(';');
  const url = `https://router.project-osrm.org/route/v1/driving/${coords}?overview=full&geometries=geojson`;
  try {
    const res = await fetch(url );
    if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
    return await res.json();
  } catch (error) {
    console.error('Erro ao buscar dados da rota OSRM:', error);
    showToast('Falha ao traçar a rota. Verifique a conexão.', 'error');
    return null;
  }
}

// NOVA FUNÇÃO CENTRALIZADA PARA DESENHAR TODAS AS ROTAS
async function drawAllRoutes() {
  // Limpa as rotas antigas
  if (routeLayer) map.removeLayer(routeLayer);
  if (nextDeliveryRouteLayer) map.removeLayer(nextDeliveryRouteLayer);

  // 1. Desenha a Rota Completa (Azul)
  if (isRouteOptimized) {
    const allPoints = deliveryData.map(d => ({ lat: +d.Latitude, lng: +d.Longitude }));
    if (userLocation) allPoints.unshift(userLocation);
    
    const routeData = await fetchRouteData(allPoints);
    if (routeData && routeData.routes.length > 0) {
      routeLayer = L.geoJSON(routeData.routes[0].geometry, { style: { color: "#5e33ea", weight: 5, opacity: 0.7 } });
      routeLayer.addTo(map);
    }
  }

  // 2. Desenha a Rota para a Próxima Entrega (Laranja)
  const nextDelivery = deliveryData.find(d => d.status === "pendente");
  if (nextDelivery && userLocation) {
    const nextPoints = [userLocation, { lat: +nextDelivery.Latitude, lng: +nextDelivery.Longitude }];
    const nextRouteData = await fetchRouteData(nextPoints);
    if (nextRouteData && nextRouteData.routes.length > 0) {
      nextDeliveryRouteLayer = L.geoJSON(nextRouteData.routes[0].geometry, { style: { color: "#ff6b35", weight: 7, opacity: 0.9, dashArray: '10, 5' } });
      nextDeliveryRouteLayer.addTo(map);
    }
  }
}

function showMapControls(show) {
    const visibility = show ? 'remove' : 'add';
    ["menuToggleBtn", "centerUserBtn", "reOptimizeBtn", "fullscreenBtn", "settingsBtn", "toggleTrackingBtn"].forEach(id => {
      document.getElementById(id)?.classList[visibility]("hidden");
    });
}

function toggleMenu(force = null) {
  const sideMenu = document.getElementById("sideMenu");
  const menuOverlay = document.getElementById("menuOverlay");
  // A linha 'optimizeInMenuBtn' foi removida
  const isOpen = !sideMenu.classList.contains("hidden");
  const shouldOpen = force !== null ? force : !isOpen;
  if (shouldOpen) {
    sideMenu.classList.remove("hidden");
    menuOverlay.classList.remove("hidden");
    setTimeout(() => sideMenu.classList.remove("-translate-x-full"), 10);
    // A linha 'optimizeInMenuBtn' foi removida
  } else {
    sideMenu.classList.add("-translate-x-full");
    menuOverlay.classList.add("hidden");
    setTimeout(() => sideMenu.classList.add("hidden"), 300);
  }
}

// =================================================================================
// FUNÇÕES UTILITÁRIAS
// =================================================================================
function haversine(pos1, pos2) {
  const R = 6371; // Raio da Terra em km
  const dLat = (pos2.lat - pos1.lat) * Math.PI / 180;
  const dLon = (pos2.lng - pos1.lng) * Math.PI / 180;
  const a = Math.sin(dLat/2) * Math.sin(dLat/2) + Math.cos(pos1.lat * Math.PI / 180) * Math.cos(pos2.lat * Math.PI / 180) * Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

// Função auxiliar para compatibilidade
function getDistance(point1, point2) {
  if (!point1 || !point2) return 0;
  return haversine(point1, point2); 
  // ou: return await getSmartDistance(point1, point2, false);
}

function showToast(message, type = 'info') {
  const toast = document.getElementById('toast');
  const toastMessage = document.getElementById('toastMessage');
  const toastIcon = document.getElementById('toastIcon');
  
  const icons = {
    info: 'fa-info-circle',
    success: 'fa-check-circle',
    warn: 'fa-exclamation-triangle',
    error: 'fa-times-circle'
  };
  toastIcon.className = `fas ${icons[type]} mr-3`;
  
  toastMessage.textContent = message;
  toast.classList.add('show');
  
  setTimeout(() => { toast.classList.remove('show'); }, 3000);
}

function showConfirmModal(title, message) {
  return new Promise((resolve) => {
    const modal = document.getElementById('confirmModal');
    document.getElementById('confirmTitle').textContent = title;
    document.getElementById('confirmMessage').innerHTML = message; // Usamos innerHTML para permitir quebras de linha com   


    modal.classList.remove('hidden');

    const okBtn = document.getElementById('confirmOkBtn');
    const cancelBtn = document.getElementById('confirmCancelBtn');

    const close = (decision) => {
      modal.classList.add('hidden');
      // Remove os event listeners para evitar múltiplos cliques em futuras chamadas
      okBtn.onclick = null;
      cancelBtn.onclick = null;
      resolve(decision);
    };

    okBtn.onclick = () => close(true);
    cancelBtn.onclick = () => close(false);
  });
}

// =================================================================================
// EVENT LISTENERS
// =================================================================================
// Listener para abrir o modal de configurações
document.getElementById("settingsBtn").addEventListener("click", () => {
  // Carrega as configurações salvas antes de mostrar
  document.getElementById('navAppSelect').value = localStorage.getItem('navApp') || 'google';
  document.getElementById('autoZoomToggle').checked = (localStorage.getItem('autoZoom') !== 'false');
  
  document.getElementById('settingsModal').classList.remove('hidden');
  syncReturnToStartToggle();
  toggleMenu(false);
});

// Listener para fechar o modal de configurações
document.getElementById("closeSettingsBtn").addEventListener("click", () => {
  document.getElementById('settingsModal').classList.add('hidden');
});

// Listeners para salvar as configurações quando elas mudam
document.getElementById('navAppSelect').addEventListener('change', (e) => {
  localStorage.setItem('navApp', e.target.value);
  showToast('Aplicativo de navegação salvo!', 'success');
  
});

document.getElementById('autoZoomToggle').addEventListener('change', (e) => {
  localStorage.setItem('autoZoom', e.target.checked);
  showToast(`Zoom automático ${e.target.checked ? 'ativado' : 'desativado'}.`, 'success');
});

document.getElementById("menuToggleBtn").addEventListener("click", () => toggleMenu(true));
document.getElementById("closeMenuBtn").addEventListener("click", () => toggleMenu(false));
document.getElementById("menuOverlay").addEventListener("click", () => toggleMenu(false));

document.getElementById("loadNewFileBtn").addEventListener("click", async () => {
    // --- SOLUÇÃO: FECHA O MENU ANTES DE MOSTRAR O MODAL ---
    toggleMenu(false); 
    
    // Pequeno delay para garantir que a animação de fechar o menu comece
    await delay(100); 

    const confirmed = await showConfirmModal(
        "🚨 Recomeçar Rota",
        "Tem certeza que deseja carregar um novo arquivo? Todos os dados da rota atual serão perdidos e o sistema será reiniciado."
    );

    if (confirmed) {
        showToast('🔄 Reiniciando sistema...', 'info');
        clearState();
    }
});

// --- OUVINTES DE EVENTOS CORRETOS PARA OS BOTÕES FLUTUANTES ---
document.getElementById('reOptimizeBtn').addEventListener('click', reOptimizeFromCurrentLocation);

document.getElementById('centerUserBtn').addEventListener('click', () => {
    if (userLocation) {
        map.setView(userLocation, 16);
        showToast('Centralizado na sua localização', 'info');
    } else {
        showToast('Localização não disponível', 'warn');
    }
    toggleMenu(false);
});

// Funções para controlar o modal de progresso
function showProgressModal(text) {
  document.getElementById('progressText').textContent = text;
  document.getElementById('progressModal').classList.remove('hidden');
}

function hideProgressModal() {
  document.getElementById('progressModal').classList.add('hidden');
}

// --- Botão de tela cheia ---
document.getElementById("fullscreenBtn").addEventListener("click", () => {
  toggleMenu(false);
  if (!document.fullscreenElement) {
    document.documentElement.requestFullscreen().catch(err => {
      showToast(`Erro ao ativar tela cheia: ${err.message}`, "error");
    });
  } else {
    document.exitFullscreen();
  }
});

// Função para sincronizar a aparência do switch com o tema atual
function syncThemeSwitch() {
    const html = document.documentElement;
    const toggle = document.getElementById('themeToggleSwitch');
    const knob = toggle.querySelector('span[aria-hidden="true"]');

    if (html.classList.contains('dark')) {
        toggle.classList.remove('bg-gray-200');
        toggle.classList.add('bg-indigo-600');
        knob.classList.remove('translate-x-0');
        knob.classList.add('translate-x-5');
        toggle.setAttribute('aria-checked', 'true');
    } else {
        toggle.classList.remove('bg-indigo-600');
        toggle.classList.add('bg-gray-200');
        knob.classList.remove('translate-x-5');
        knob.classList.add('translate-x-0');
        toggle.setAttribute('aria-checked', 'false');
    }
}

// Listener para o novo switch de tema
document.getElementById("themeToggleSwitch").addEventListener("click", () => {
    const html = document.documentElement;
    if (html.classList.contains("dark")) {
        html.classList.remove("dark");
        localStorage.setItem("theme", "light");
    } else {
        html.classList.add("dark");
        localStorage.setItem("theme", "dark");
    }
    
    syncThemeSwitch(); // Sincroniza o visual do switch após a mudança
    updateMapTheme(); // 🎯 ADICIONE ESTA LINHA para atualizar o mapa
});

// Restaurar tema e sincronizar switch ao carregar a página
if (localStorage.getItem("theme") === "dark") {
  document.documentElement.classList.add("dark");
}
// Chama a sincronização após um pequeno delay para garantir que tudo foi carregado
document.addEventListener('DOMContentLoaded', () => {
    // Restaurar tema salvo
    if (localStorage.getItem("theme") === "dark") {
        document.documentElement.classList.add("dark");
    }
    
    // Sincronizar switch e mapa após um pequeno delay
    setTimeout(() => {
        syncThemeSwitch();
        if (map) {
            updateMapTheme(); // Atualiza o mapa se ele já estiver inicializado
        }
    }, 100);
});

function toggleTheme() {
    const html = document.documentElement;
    if (html.classList.contains("dark")) {
        html.classList.remove("dark");
        localStorage.setItem("theme", "light");
    } else {
        html.classList.add("dark");
        localStorage.setItem("theme", "dark");
    }
    
    syncThemeSwitch();
    updateMapTheme(); // Sempre atualiza o mapa junto
}

// --- NOVOS LISTENERS PARA AS NOVAS CONFIGURAÇÕES ---
document.getElementById("settingsBtn").addEventListener("click", () => {
  toggleMenu(false);
  // Carrega as configurações salvas antes de mostrar
  document.getElementById('navAppSelect').value = localStorage.getItem('navApp') || 'google';
  syncThemeSwitch();
  
  document.getElementById('settingsModal').classList.remove('hidden');
});

// Função para sincronizar o toggle de retorno
function syncReturnToStartToggle() {
  const useReturn = localStorage.getItem('useReturnToStart') === 'true';
  const toggle = document.getElementById('returnToStartToggle');
  const knob = toggle.querySelector('span[aria-hidden="true"]');

  if (useReturn) {
    toggle.classList.remove('bg-gray-200');
    toggle.classList.add('bg-indigo-600');
    knob.classList.remove('translate-x-0');
    knob.classList.add('translate-x-5');
  } else {
    toggle.classList.remove('bg-indigo-600');
    toggle.classList.add('bg-gray-200');
    knob.classList.remove('translate-x-5');
    knob.classList.add('translate-x-0');
  }
  toggle.setAttribute('aria-checked', useReturn);
}

// Listener para o novo toggle
document.getElementById('returnToStartToggle').addEventListener('click', () => {
  const useReturn = localStorage.getItem('useReturnToStart') === 'true';
  localStorage.setItem('useReturnToStart', !useReturn);
  syncReturnToStartToggle();
  showToast(`Retorno ao ponto inicial ${!useReturn ? 'ativado' : 'desativado'}.`, 'info');
});


const sideMenu = document.getElementById('sideMenu');
const menuOverlay = document.getElementById('menuOverlay');

function openMenu() {
  sideMenu.classList.remove('hidden', '-translate-x-full');
  menuOverlay.classList.remove('hidden');
}

function closeMenu() {
  sideMenu.classList.add('-translate-x-full');
  menuOverlay.classList.add('hidden');
}

menuOverlay.addEventListener('click', closeMenu);
document.getElementById('closeMenuBtn')?.addEventListener('click', closeMenu);


// Fechar o settingsModal ao clicar fora (apenas no fundo escuro)
document.getElementById('settingsModal').addEventListener('click', (e) => {
  if (e.target === document.getElementById('settingsModal')) {
    document.getElementById('settingsModal').classList.add('hidden');
  }
});

// Botão fechar já existente continua funcionando
document.getElementById('closeSettingsBtn')?.addEventListener('click', () => {
  document.getElementById('settingsModal').classList.add('hidden');
});

let sortableInstance = null;

function initializeSortable() {
    const routeList = document.getElementById('routeList');
    
    // Remove instância anterior se existir
    if (sortableInstance) {
        sortableInstance.destroy();
    }
    
    sortableInstance = Sortable.create(routeList, {
        animation: 200,
        ghostClass: 'sortable-ghost',
        chosenClass: 'sortable-chosen',
        dragClass: 'sortable-drag',
        
        onStart: function(evt) {
            evt.item.classList.add('z-50');
        },
        
        onEnd: function(evt) {
            evt.item.classList.remove('z-50');
            
            // Se foi movido para uma nova posição, reordena
            if (evt.oldIndex !== evt.newIndex) {
                reorderDeliveries(evt.oldIndex, evt.newIndex);
            }
        }
    });
}

function reorderDeliveries(oldIndex, newIndex) {
    // Remove o item da posição antiga e insere na nova
    const movedItem = deliveryData.splice(oldIndex, 1)[0];
    deliveryData.splice(newIndex, 0, movedItem);
    
    // Recalcula as sequências
    deliveryData.forEach((delivery, index) => {
        delivery.Sequence = index + 1;
    });
    
    // USA AS VERSÕES DEBOUNCED
    saveState();
    debouncedUpdateUI(); // ← MUDANÇA AQUI
}

async function removeDelivery(deliveryId) {
  toggleMenu(false); 
    const delivery = deliveryData.find(d => d.id === deliveryId);
    if (!delivery) return;
    
    const confirmed = await showConfirmModal(
        '🚨  Remover Parada',
        `Deseja remover o pacote <b><em>#${delivery.STOP}</em></b> da rota?<br><br>Esta ação não pode ser desfeita.`
    );
    
    if (confirmed) {
        // Remove da lista
        deliveryData = deliveryData.filter(d => d.id !== deliveryId);
        
        // Recalcula as sequências
        deliveryData.forEach((delivery, index) => {
            delivery.Sequence = index + 1;
        });
        
        showToast(`Parada #${delivery.STOP} removida da rota`, 'warn');
        
        // Salva e atualiza
        saveState();
        updateUI();
    } else {
        // Se cancelou, atualiza a lista para resetar o visual
        updateSideList();
    }
}

let wakeLock = null;

async function requestWakeLock() {
  // Verifica se a página está visível antes de tentar
  if (document.hidden || document.visibilityState !== 'visible') {
    console.log('Página não visível, Wake Lock adiado');
    return;
  }

  // Verifica se o navegador suporta Wake Lock
  if (!('wakeLock' in navigator)) {
    showToast('Wake Lock não suportado neste navegador.', 'warn');
    return;
  }

  try {
    wakeLock = await navigator.wakeLock.request('screen');
    
    wakeLock.addEventListener('release', () => {
      wakeLock = null;
    });
    
    showToast('Tela mantida ligada.', 'success');
  } catch (err) {
    console.error(`Wake Lock erro: ${err.name}, ${err.message}`);
    
    // Não mostra erro se a página não estiver visível
    if (err.name !== 'NotAllowedError' || document.visibilityState === 'visible') {
      showToast('Falha ao ativar manter tela ligada.', 'error');
    }
  }
}

function releaseWakeLock() {
  if (wakeLock) {
    wakeLock.release();
    wakeLock = null;
    showToast('A tela pode apagar novamente.', 'info');
  }
}

const wakeLockToggle = document.getElementById('wakeLockToggle');

// Restaurar estado salvo ao carregar
const savedWakeLock = localStorage.getItem('wakeLockEnabled') === 'true';
wakeLockToggle.checked = savedWakeLock;

// Só ativa se a página estiver visível
if (savedWakeLock && document.visibilityState === 'visible') {
  requestWakeLock();
}

// Event listener do toggle
wakeLockToggle.addEventListener('change', async (e) => {
  const enabled = e.target.checked;
  localStorage.setItem('wakeLockEnabled', enabled);
  
  if (enabled) {
    await requestWakeLock();
  } else {
    releaseWakeLock();
  }
});

document.getElementById('toggleTrackingBtn').addEventListener('click', () => {
  if (isTrackingActive) {
    stopTracking();
  } else {
    startTracking();
  }
});

// Reativação inteligente quando a aba volta a ser visível
document.addEventListener('visibilitychange', async () => {
  const wakeLockEnabled = localStorage.getItem('wakeLockEnabled') === 'true';
  
  if (document.visibilityState === 'visible' && wakeLockEnabled && !wakeLock) {
    // Pequeno delay para garantir que a página está totalmente ativa
    setTimeout(() => {
      if (document.visibilityState === 'visible') {
        requestWakeLock();
      }
    }, 500);
  }
});

function releaseWakeLock() {
  if (wakeLock) {
    wakeLock.release();
    wakeLock = null;
    showToast('A tela pode apagar novamente.', 'info');
  }
}

// 🔹 Se a aba perder foco e voltar, reativa se estava ligado
document.addEventListener('visibilitychange', async () => {
  if (wakeLock !== null && document.visibilityState === 'visible') {
    await requestWakeLock();
  }
});

// =================================================================================
// SISTEMA COMPLETO DE CORREÇÃO INTELIGENTE DE ENDEREÇOS
// =================================================================================


// Novo listener que substitui o antigo
document.getElementById("validateAddressesBtn").addEventListener("click", async () => {
    if (deliveryData.length === 0) {
        showToast('Carregue primeiro um arquivo com entregas', 'warn');
        return;
    }
    
    toggleMenu(false);
    await smartAddressCorrection(deliveryData);
});

// Função de similaridade de endereços
function calculateAddressSimilarity(address1, address2) {
    if (!address1 || !address2) return 0;
    
    const normalize = (addr) => addr
        .toLowerCase()
        .replace(/[^\w\s]/g, ' ')
        .replace(/\s+/g, ' ')
        .trim();
    
    const addr1 = normalize(address1);
    const addr2 = normalize(address2);
    
    const extractKeywords = (addr) => {
        const words = addr.split(' ');
        return words.filter(word => 
            word.length > 2 && 
            !['rua', 'avenida', 'av', 'r', 'numero', 'nro', 'no', 'brasil', 'brazil', 'de', 'da', 'do', 'dos', 'das'].includes(word)
        );
    };
    
    const keywords1 = extractKeywords(addr1);
    const keywords2 = extractKeywords(addr2);
    
    if (keywords1.length === 0 || keywords2.length === 0) return 0;
    
    let matches = 0;
    keywords1.forEach(word1 => {
        if (keywords2.some(word2 => 
            word2.includes(word1) || 
            word1.includes(word2) || 
            levenshteinDistance(word1, word2) <= 2
        )) {
            matches++;
        }
    });
    
    return matches / Math.max(keywords1.length, keywords2.length);
}

// Função Levenshtein Distance
function levenshteinDistance(str1, str2) {
    if (str1.length === 0) return str2.length;
    if (str2.length === 0) return str1.length;
    
    const matrix = [];
    
    for (let i = 0; i <= str2.length; i++) {
        matrix[i] = [i];
    }
    
    for (let j = 0; j <= str1.length; j++) {
        matrix[0][j] = j;
    }
    
    for (let i = 1; i <= str2.length; i++) {
        for (let j = 1; j <= str1.length; j++) {
            if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                matrix[i][j] = matrix[i - 1][j - 1];
            } else {
                matrix[i][j] = Math.min(
                    matrix[i - 1][j - 1] + 1,
                    matrix[i][j - 1] + 1,
                    matrix[i - 1][j] + 1
                );
            }
        }
    }
    
    return matrix[str2.length][str1.length];
}

async function smartAddressCorrection(deliveryData) {
    const corrections = [];
    const clusters = findDeliveryGroups(deliveryData);
    
    showProgressModal('Analisando endereços...', 0);
    
    for (let i = 0; i < deliveryData.length; i++) {
        const item = deliveryData[i];
        const progress = ((i + 1) / deliveryData.length) * 100;
        
        showProgressModal(`Verificando ${i + 1}/${deliveryData.length}: Pacote #${item.STOP}`, progress);
        
        if (addressCorrectionsCache[item.id]) {
            corrections.push(addressCorrectionsCache[item.id]);
            continue;
        }
        
        const correction = await analyzeAddressAccuracy(item, clusters);
        if (correction.needsCorrection) {
            corrections.push(correction);
            addressCorrectionsCache[item.id] = correction;
        }
        
        await delay(200);
    }
    
    hideProgressModal();
    
    if (corrections.length > 0) {
        await displayCorrectionInterface(corrections);
    } else {
        showToast('✅ Todos os endereços estão corretos!', 'success');
    }
}


// Agrupa entregas por proximidade geográfica
function findDeliveryGroups(deliveryData) {
    const clusters = [];
    const processed = new Set();
    
    deliveryData.forEach((delivery, index) => {
        if (processed.has(index)) return;
        
        const cluster = [delivery];
        const coords = { lat: parseFloat(delivery.Latitude), lng: parseFloat(delivery.Longitude) };
        
        // Encontra entregas próximas (raio de 2km)
        deliveryData.forEach((other, otherIndex) => {
            if (index === otherIndex || processed.has(otherIndex)) return;
            
            const otherCoords = { lat: parseFloat(other.Latitude), lng: parseFloat(other.Longitude) };
            const distance = haversine(coords, otherCoords);
            
            if (distance <= 2) {
                cluster.push(other);
                processed.add(otherIndex);
            }
        });
        
        if (cluster.length > 0) {
            clusters.push({
                center: calculateClusterCenter(cluster),
                deliveries: cluster,
                avgDistance: calculateAverageDistance(cluster)
            });
        }
        
        processed.add(index);
    });
    
    return clusters;
}

// Calcula centro do cluster
function calculateClusterCenter(cluster) {
    const totalLat = cluster.reduce((sum, d) => sum + parseFloat(d.Latitude), 0);
    const totalLng = cluster.reduce((sum, d) => sum + parseFloat(d.Longitude), 0);
    
    return {
        lat: totalLat / cluster.length,
        lng: totalLng / cluster.length
    };
}

// Calcula distância média no cluster
function calculateAverageDistance(cluster) {
    if (cluster.length < 2) return 0;
    
    let totalDistance = 0;
    let pairs = 0;
    
    for (let i = 0; i < cluster.length; i++) {
        for (let j = i + 1; j < cluster.length; j++) {
            const coords1 = { lat: parseFloat(cluster[i].Latitude), lng: parseFloat(cluster[i].Longitude) };
            const coords2 = { lat: parseFloat(cluster[j].Latitude), lng: parseFloat(cluster[j].Longitude) };
            totalDistance += haversine(coords1, coords2);
            pairs++;
        }
    }
    
    return pairs > 0 ? totalDistance / pairs : 0;
}

async function analyzeAddressAccuracy(item, clusters) {
    const address = buildFullAddress(item);
    const currentCoords = { lat: parseFloat(item.Latitude), lng: parseFloat(item.Longitude) };
    
    if (isNaN(currentCoords.lat) || isNaN(currentCoords.lng)) {
        return { needsCorrection: false, reason: 'Coordenadas inválidas' };
    }
    
    const geocodeResult = await geocodeAddress(address);
    if (!geocodeResult) {
        return { needsCorrection: false, reason: 'Endereço não pôde ser geocodificado' };
    }
    
    const distanceToCorrect = haversine(currentCoords, geocodeResult);
    
    // Verifica se bairro ou CEP batem
    const addressMatch = compareAddressDetails(item, geocodeResult.addressDetails);
    
    // Decide se precisa correção:
    // Corrige se distância > 0.5 km ou se bairro/CEP não batem
    const needsCorrection = distanceToCorrect > 0.5 || !addressMatch;
    
    if (needsCorrection) {
        return {
            needsCorrection: true,
            item: item,
            currentCoords: currentCoords,
            correctCoords: { lat: geocodeResult.lat, lng: geocodeResult.lng },
            distance: distanceToCorrect,
            confidence: 1,
            contextAnalysis: null,
            address: address
        };
    }
    
    return { needsCorrection: false };
}

function buildFullAddress(item) {
    const parts = [
        item['Destination Address'] || item.Endereço || item.endereco || '',
        item.Bairro || item.bairro || '',
        item.City || item.cidade || item.Cidade || '',
        item['Zipcode/Postal code'] || item.CEP || item.cep || ''
    ].filter(part => part && part.trim().length > 0);

    const fullAddress = parts.join(', ');

    console.log(`Endereço completo para geocodificação (Parada #${item.STOP}):`, fullAddress);

    return fullAddress;
}

// Analisa contexto geográfico
function analyzeGeographicContext(item, clusters, correctCoords) {
    let bestCluster = null;
    let minDistanceToCluster = Infinity;
    
    clusters.forEach(cluster => {
        const distanceToCenter = haversine(correctCoords, cluster.center);
        if (distanceToCenter < minDistanceToCluster) {
            minDistanceToCluster = distanceToCenter;
            bestCluster = cluster;
        }
    });
    
    const nearbyDeliveries = findNearbyDeliveries(item, clusters, correctCoords);
    
    return {
        bestCluster: bestCluster,
        distanceToCluster: minDistanceToCluster,
        nearbyDeliveries: nearbyDeliveries,
        isIsolated: minDistanceToCluster > 5,
        hasSimilarAddresses: nearbyDeliveries.length > 0
    };
}

// Encontra entregas próximas
function findNearbyDeliveries(item, clusters, correctCoords) {
    const itemAddress = buildFullAddress(item).toLowerCase();
    const nearby = [];
    
    clusters.forEach(cluster => {
        cluster.deliveries.forEach(delivery => {
            if (delivery.id === item.id) return;
            
            const deliveryAddress = buildFullAddress(delivery).toLowerCase();
            const similarity = calculateAddressSimilarity(itemAddress, deliveryAddress);
            const distance = haversine(correctCoords, {
                lat: parseFloat(delivery.Latitude),
                lng: parseFloat(delivery.Longitude)
            });
            
            if (similarity > 0.6 || distance < 1) {
                nearby.push({
                    delivery: delivery,
                    similarity: similarity,
                    distance: distance
                });
            }
        });
    });
    
    return nearby.sort((a, b) => b.similarity - a.similarity);
}

// Determina se precisa correção
function shouldCorrectAddress(distance, contextAnalysis) {
    if (distance > 1) return true;
    
    if (distance > 0.5 && contextAnalysis.distanceToCluster > 3) {
        return true;
    }
    
    if (contextAnalysis.nearbyDeliveries.length > 0) {
        const bestMatch = contextAnalysis.nearbyDeliveries[0];
        if (bestMatch.similarity > 0.8 && bestMatch.distance < 0.5) {
            return true;
        }
    }
    
    return false;
}

// Calcula confiança da correção
function calculateCorrectionConfidence(distance, contextAnalysis) {
    let confidence = 0;
    
    if (distance > 2) confidence += 0.4;
    else if (distance > 1) confidence += 0.3;
    else if (distance > 0.5) confidence += 0.2;
    else confidence += 0.1;
    
    if (contextAnalysis.nearbyDeliveries.length > 0) {
        const bestMatch = contextAnalysis.nearbyDeliveries[0];
        confidence += (bestMatch.similarity * 0.3);
    }
    
    if (contextAnalysis.distanceToCluster > 5) {
        confidence += 0.2;
    }
    
    return Math.min(confidence, 1);
}

// Interface para correções
async function displayCorrectionInterface(corrections) {
    const highConfidence = corrections.filter(c => c.confidence > 0.7);
    const mediumConfidence = corrections.filter(c => c.confidence >= 0.4 && c.confidence <= 0.7);
    const lowConfidence = corrections.filter(c => c.confidence < 0.4);
    
    const modalHTML = `
        <div id="correctionModal" class="fixed inset-0 bg-black bg-opacity-60 z-[10000] flex items-center justify-center p-4">
            <div class="bg-white dark:bg-gray-800 rounded-2xl shadow-lg max-w-4xl w-full max-h-[90vh] overflow-y-auto">
                <div class="sticky top-0 bg-white dark:bg-gray-800 border-b p-6 rounded-t-2xl">
                    <div class="flex justify-between items-center">
                        <div>
                            <h3 class="text-xl font-bold text-gray-800 dark:text-white">🎯 Correção Inteligente de Endereços</h3>
                            <p class="text-sm text-gray-600 dark:text-gray-300 mt-1">
                                ${corrections.length} endereços precisam de correção
                            </p>
                        </div>
                        <button id="closeCorrectionModal" class="text-gray-500 hover:text-red-500">
                            <i class="fas fa-times text-xl"></i>
                        </button>
                    </div>
                </div>
                
                <div class="p-6 space-y-6">
                    ${highConfidence.length > 0 ? `
                        <div class="space-y-3">
                            <h4 class="font-semibold text-green-700 dark:text-green-400 flex items-center">
                                <i class="fas fa-check-circle mr-2"></i>
                                Correções Automáticas (${highConfidence.length})
                            </h4>
                            <div class="space-y-2">
                                ${highConfidence.map(c => createCorrectionCard(c, 'auto')).join('')}
                            </div>
                            <button id="applyAutoCorrections" class="w-full bg-green-600 hover:bg-green-700 text-white py-2 px-4 rounded-lg">
                                <i class="fas fa-magic mr-2"></i>Aplicar Todas as Correções Automáticas
                            </button>
                        </div>
                    ` : ''}
                    
                    ${mediumConfidence.length > 0 ? `
                        <div class="space-y-3">
                            <h4 class="font-semibold text-yellow-700 dark:text-yellow-400 flex items-center">
                                <i class="fas fa-exclamation-triangle mr-2"></i>
                                Correções Sugeridas (${mediumConfidence.length})
                            </h4>
                            <div class="space-y-2">
                                ${mediumConfidence.map(c => createCorrectionCard(c, 'suggested')).join('')}
                            </div>
                        </div>
                    ` : ''}
                    
                    ${lowConfidence.length > 0 ? `
                        <div class="space-y-3">
                            <h4 class="font-semibold text-red-700 dark:text-red-400 flex items-center">
                                <i class="fas fa-question-circle mr-2"></i>
                                Revisar Manualmente (${lowConfidence.length})
                            </h4>
                            <div class="space-y-2">
                                ${lowConfidence.map(c => createCorrectionCard(c, 'manual')).join('')}
                            </div>
                        </div>
                    ` : ''}
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHTML);
    
    // Event listeners
    document.getElementById('closeCorrectionModal').onclick = () => {
        document.getElementById('correctionModal').remove();
    };
    
    if (highConfidence.length > 0) {
        document.getElementById('applyAutoCorrections').onclick = () => {
            applyMultipleCorrections(highConfidence);
        };
    }
    
    // Listeners individuais
    corrections.forEach(correction => {
        const applyBtn = document.getElementById(`apply-${correction.item.id}`);
        const previewBtn = document.getElementById(`preview-${correction.item.id}`);
        
        if (applyBtn) {
            applyBtn.onclick = () => applySingleCorrection(correction);
        }
        
        if (previewBtn) {
            previewBtn.onclick = () => previewCorrection(correction);
        }
    });
}

// Cria card de correção
function createCorrectionCard(correction, type) {
    const confidencePercent = Math.round(correction.confidence * 100);
    const distanceText = correction.distance < 1 ? 
        `${Math.round(correction.distance * 1000)}m` : 
        `${correction.distance.toFixed(1)}km`;
    
    const confidenceColor = correction.confidence > 0.7 ? 'text-green-600' : 
                           correction.confidence > 0.4 ? 'text-yellow-600' : 'text-red-600';
    
    return `
        <div class="border rounded-lg p-4 ${type === 'auto' ? 'border-green-200 bg-green-50' : 
                                           type === 'suggested' ? 'border-yellow-200 bg-yellow-50' : 
                                           'border-red-200 bg-red-50'} dark:bg-gray-700 dark:border-gray-600">
            <div class="flex justify-between items-start mb-3">
                <div class="flex-1">
                    <h5 class="font-semibold text-gray-800 dark:text-white">
                        Parada #${correction.item.STOP} • Sequência ${correction.item.Sequence}
                    </h5>
                    <div class="flex items-center mt-1 space-x-4">
                        <span class="${confidenceColor} text-sm font-medium">
                            Confiança: ${confidencePercent}%
                        </span>
                        <span class="text-gray-600 dark:text-gray-300 text-sm">
                            Distância: ${distanceText}
                        </span>
                    </div>
                </div>
                <div class="flex space-x-2">
                    <button id="preview-${correction.item.id}" 
                            class="bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded text-sm">
                        <i class="fas fa-eye mr-1"></i>Ver
                    </button>
                    <button id="apply-${correction.item.id}" 
                            class="bg-green-500 hover:bg-green-600 text-white px-3 py-1 rounded text-sm">
                        <i class="fas fa-check mr-1"></i>Aplicar
                    </button>
                </div>
            </div>
            
            <div class="text-sm space-y-1">
                <div class="text-gray-700 dark:text-gray-300">
                    <strong>Endereço:</strong> ${correction.address}
                </div>
                <div class="text-gray-600 dark:text-gray-400">
                    <strong>Atual:</strong> ${correction.currentCoords.lat.toFixed(6)}, ${correction.currentCoords.lng.toFixed(6)}
                </div>
                <div class="text-green-600 dark:text-green-400">
                    <strong>Corrigido:</strong> ${correction.correctCoords.lat.toFixed(6)}, ${correction.correctCoords.lng.toFixed(6)}
                </div>
                
                ${correction.contextAnalysis?.nearbyDeliveries?.length > 0 ? `
                  <div class="mt-2 text-xs text-blue-600 dark:text-blue-400">
                      <i class="fas fa-info-circle mr-1"></i>
                      ${correction.contextAnalysis.nearbyDeliveries.length} entrega(s) similar(es) encontrada(s) na região
                  </div>
              ` : ''}
            </div>
        </div>
    `;
}

// Aplica correção individual
function applySingleCorrection(correction) {
    const item = deliveryData.find(d => d.id === correction.item.id);
    if (item) {
        item.Latitude = correction.correctCoords.lat;
        item.Longitude = correction.correctCoords.lng;
        
        showToast(`✅ Parada #${item.STOP} corrigida!`, 'success');
        
        const card = document.getElementById(`apply-${correction.item.id}`).closest('.border');
        card.style.opacity = '0.5';
        card.style.pointerEvents = 'none';
        
        saveState();
        updateUI();
    }
}

// Aplica múltiplas correções
function applyMultipleCorrections(corrections) {
    let corrected = 0;
    
    corrections.forEach(correction => {
        const item = deliveryData.find(d => d.id === correction.item.id);
        if (item) {
            item.Latitude = correction.correctCoords.lat;
            item.Longitude = correction.correctCoords.lng;
            corrected++;
        }
    });
    
    showToast(`✅ ${corrected} endereços corrigidos automaticamente!`, 'success');
    
    document.getElementById('correctionModal').remove();
    saveState();
    updateUI();
}

// Preview da correção
function previewCorrection(correction) {
    if (!map) return;
    
    const currentMarker = L.marker([correction.currentCoords.lat, correction.currentCoords.lng], {
        icon: L.divIcon({
            className: '',
            html: `<div style="background-color: red; color: white; border-radius: 50%; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: bold; border: 2px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3);">
                     ${correction.item.Sequence}
                   </div>`
        })
    }).bindPopup(`<b>Posição Atual (Incorreta)</b><br>Parada #${correction.item.STOP}`);
    
    const correctMarker = L.marker([correction.correctCoords.lat, correction.correctCoords.lng], {
        icon: L.divIcon({
            className: '',
            html: `<div style="background-color: green; color: white; border-radius: 50%; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: bold; border: 2px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3);">
                     ${correction.item.Sequence}
                   </div>`
        })
    }).bindPopup(`<b>Posição Corrigida</b><br>Parada #${correction.item.STOP}<br>${correction.address}`);
    
    const line = L.polyline([
        [correction.currentCoords.lat, correction.currentCoords.lng],
        [correction.correctCoords.lat, correction.correctCoords.lng]
    ], { color: 'orange', weight: 3, dashArray: '5, 5' });
    
    currentMarker.addTo(map);
    correctMarker.addTo(map);
    line.addTo(map);
    
    const bounds = L.latLngBounds([
        [correction.currentCoords.lat, correction.currentCoords.lng],
        [correction.correctCoords.lat, correction.correctCoords.lng]
    ]);
    map.fitBounds(bounds, { padding: [50, 50] });
    
    setTimeout(() => {
        map.removeLayer(currentMarker);
        map.removeLayer(correctMarker);
        map.removeLayer(line);
    }, 10000);
    
    showToast(`Preview da correção da Parada #${correction.item.STOP}`, 'info');
}
</script>
</body>
</html>
