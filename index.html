
<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Otimizador de Rotas</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"/>
  <style>
    #map { height: calc(100vh - 160px); width: 100%; }
    .leaflet-popup-content button {
      margin: 4px 2px;
      padding: 4px 8px;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      font-size: 0.8rem;
    }
    .leaflet-popup-content .delivered { background: #10b981; color: white; }
    .leaflet-popup-content .notdelivered { background: #ef4444; color: white; }
    .leaflet-popup-content .pending { background: #f59e0b; color: white; }

    /* Toast notification */
    .toast {
      position: fixed;
      top: 60px;
      right: 20px;
      background: #1f2937;
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      transform: translateX(100%);
      transition: transform 0.3s ease;
      z-index: 1000;
    }
    .toast.show { transform: translateX(0); }

    #menuToggleBtn {
        position: fixed;
        z-index: 9999;
    }

    #sideMenu {
        z-index: 9999;
    }

    .leaflet-control-zoom {
        display: none;
    }

    /* Rota destacada para próxima entrega */
    .next-delivery-route {
      color: #ff6b35 !important;
      weight: 8 !important;
      opacity: 0.9 !important;
      dashArray: '10, 5' !important;
    }

    /* Estilo para campos de endereço */
    .address-input {
      min-height: 40px;
      resize: vertical;
    }

  </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col">

  <!-- Toast Notification - Oculto por padrão -->
  <div id="toast" class="toast hidden">
    <i class="fas fa-info-circle mr-2"></i>
    <span id="toastMessage"></span>
  </div>

  <!-- Botão hambúrguer - Oculto por padrão -->
  <button id="menuToggleBtn" class="top-4 left-4 bg-white shadow rounded-lg p-2 hidden">
    <i class="fas fa-bars text-xl text-gray-700"></i>
  </button>
  <button id="centerUserBtn" class="top-4 right-4 bg-white shadow rounded-lg p-2 hidden z-[1000]">
  <i class="fas fa-crosshairs text-xl text-gray-700"></i>
</button>
  <!-- Overlay -->
  <div id="menuOverlay" class="hidden fixed inset-0 bg-black bg-opacity-40 z-40"></div>

  <!-- Menu retrátil -->
  <div id="sideMenu" class="hidden fixed top-0 left-0 w-80 h-full bg-white shadow-2xl z-50 p-6 overflow-y-auto transform -translate-x-full transition-transform duration-300">
    <div class="flex justify-between items-center mb-6">
      <h4 class="font-semibold text-gray-800">
        <i class="fas fa-list mr-2"></i>Lista de Entregas
      </h4>
      <button id="closeMenuBtn" class="text-gray-500 hover:text-red-500">
        <i class="fas fa-times text-xl"></i>
      </button>
    </div>
    
    <!-- Botão para carregar novo arquivo -->
    <div class="mb-6 p-4 bg-red-50 border border-red-200 rounded-lg">
      <h5 class="font-medium text-red-800 mb-2">
        <i class="fas fa-exclamation-triangle mr-2"></i>Recomeçar
      </h5>
      <p class="text-sm text-red-600 mb-3">Isso apagará toda a rota atual e voltará ao início.</p>
      <button id="loadNewFileBtn" class="w-full bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-lg font-medium transition">
        <i class="fas fa-file-upload mr-2"></i>Carregar Novo Arquivo
      </button>
    </div>

    <!-- Configurações de Otimização -->
    <div class="mb-6 p-4 bg-blue-50 border border-blue-200 rounded-lg">
      <h5 class="font-medium text-blue-800 mb-2">
        <i class="fas fa-cogs mr-2"></i>Configurações de Rota
      </h5>
      
      <!-- Ponto de Partida -->
      <div class="mb-4">
        <label class="block text-sm font-medium text-gray-700 mb-2">Ponto de Partida:</label>
        <div class="flex items-center mb-2">
          <input type="checkbox" id="useCurrentLocationStart" class="h-4 w-4 text-indigo-600 border-gray-300 rounded"/>
          <label for="useCurrentLocationStart" class="ml-2 block text-sm text-gray-900">Usar localização atual</label>
        </div>
        <textarea id="startAddress" placeholder="Digite o endereço ou CEP de partida" class="w-full p-2 border border-gray-300 rounded-md text-sm address-input" rows="2"></textarea>
        <div class="flex space-x-2 mt-2">
          <input type="number" id="startLat" placeholder="Latitude" class="flex-1 p-2 border border-gray-300 rounded-md text-sm" step="any"/>
          <input type="number" id="startLng" placeholder="Longitude" class="flex-1 p-2 border border-gray-300 rounded-md text-sm" step="any"/>
        </div>
        <button id="geocodeStartBtn" class="mt-2 w-full bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded text-sm">
          <i class="fas fa-search mr-1"></i>Buscar Endereço
        </button>
      </div>

      <!-- Ponto de Término -->
      <div class="mb-4">
        <label class="block text-sm font-medium text-gray-700 mb-2">Ponto de Término:</label>
        <div class="flex items-center mb-2">
          <input type="checkbox" id="useCurrentLocationEnd" class="h-4 w-4 text-indigo-600 border-gray-300 rounded"/>
          <label for="useCurrentLocationEnd" class="ml-2 block text-sm text-gray-900">Usar localização atual</label>
        </div>
        <textarea id="endAddress" placeholder="Digite o endereço ou CEP de término" class="w-full p-2 border border-gray-300 rounded-md text-sm address-input" rows="2"></textarea>
        <div class="flex space-x-2 mt-2">
          <input type="number" id="endLat" placeholder="Latitude" class="flex-1 p-2 border border-gray-300 rounded-md text-sm" step="any"/>
          <input type="number" id="endLng" placeholder="Longitude" class="flex-1 p-2 border border-gray-300 rounded-md text-sm" step="any"/>
        </div>
        <button id="geocodeEndBtn" class="mt-2 w-full bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded text-sm">
          <i class="fas fa-search mr-1"></i>Buscar Endereço
        </button>
      </div>

      <button id="optimizeInMenuBtn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-2 rounded-lg font-medium transition hidden">
        <i class="fas fa-route mr-2"></i>Otimizar Rota
      </button>
    </div>
    
    <!-- Estatísticas -->
    <div class="mb-6 p-4 bg-indigo-50 border border-indigo-200 rounded-lg">
      <h5 class="font-medium text-indigo-800 mb-2">
        <i class="fas fa-chart-bar mr-2"></i>Estatísticas
      </h5>
      <div id="routeStats" class="text-sm text-indigo-700"></div>
    </div>
    
    <div id="routeList"></div>
  </div>

  <!-- Etapa 1: Upload -->
  <div id="step1" class="flex-1 flex flex-col items-center justify-center p-6">
    <div class="bg-white rounded-2xl shadow-lg p-10 w-full max-w-md text-center">
      <h1 class="text-2xl font-bold text-indigo-600 mb-4">
        <i class="fas fa-truck mr-2"></i>Otimizador de Rotas
      </h1>
      <p class="text-gray-600 mb-6">Carregue seu arquivo XLSX para começar</p>
      <label for="fileInput" class="cursor-pointer block border-2 border-dashed border-indigo-400 rounded-xl p-10 hover:bg-indigo-50 transition">
        <i class="fas fa-file-excel text-3xl text-indigo-600 mb-3 block"></i>
        <span class="text-indigo-600 font-semibold">Clique ou arraste seu arquivo aqui</span>
        <input type="file" id="fileInput" accept=".xlsx,.xls" class="hidden"/>
      </label>
    </div>
  </div>

  <!-- Etapa 2: Seleção de colunas -->
  <div id="step2" class="hidden flex-1 flex flex-col items-center justify-center p-6">
    <div class="bg-white rounded-2xl shadow-lg p-8 w-full max-w-md">
      <h2 class="text-xl font-bold text-indigo-600 mb-4">
        <i class="fas fa-list-check mr-2"></i>Selecione as informações
      </h2>
      <p class="text-gray-500 mb-4 text-sm">Escolha os campos que deseja visualizar durante as entregas</p>
      <div id="columnsList" class="space-y-3 mb-6"></div>
      <button id="confirmColumnsBtn" class="w-full bg-indigo-600 text-white py-2 rounded-lg font-semibold hover:bg-indigo-700 transition">
        <i class="fas fa-check mr-2"></i>Confirmar
      </button>
    </div>
  </div>

  <!-- Etapa 3: Mapa -->
  <div id="step3" class="hidden flex-1 flex flex-col">
    <div id="map"></div>

    <!-- Barra inferior de próxima parada -->
    <div id="nextStopBar" class="hidden fixed bottom-0 left-0 right-0 bg-white rounded-t-2xl shadow-2xl z-50 p-4">
      <div class="flex justify-between items-center">
        <div>
          <h3 class="font-semibold text-gray-800">
            <i class="fas fa-route mr-2 text-indigo-600"></i>Próxima Parada
          </h3>
          <div id="nextStopInfo" class="text-sm text-gray-700"></div>
        </div>
        <div class="flex space-x-2">
          <button class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded-lg shadow" onclick="markNext('entregue')">
            ✅
          </button>
          <button class="bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-lg shadow" onclick="markNext('naoentregue')">
            ❌
          </button>
          <button class="bg-yellow-500 hover:bg-yellow-600 text-white px-4 py-2 rounded-lg shadow" onclick="markNext('pendente')">
            ⏸️
          </button>
        </div>
      </div>
    </div>
  </div>

<script>
let deliveryData=[], userLocation=null, map, markers=[], routeLayer, nextDeliveryRouteLayer, userMarker;
let selectedColumns=[];
let routeState = null; // Estado salvo da rota
let startPoint = null; // Ponto de partida definido pelo usuário
let endPoint = null;   // Ponto de término definido pelo usuário

// ==== Inicialização ====
window.addEventListener('load', () => {
  loadSavedState();
});

// ==== Salvar/Carregar Estado ====

// Salva o estado atual da aplicação no localStorage.
function saveState() {
  try {
    const currentState = {
      deliveryData: deliveryData,
      selectedColumns: selectedColumns,
      userLocation: userLocation,
      startPoint: startPoint,
      endPoint: endPoint,
      // Guarda qual etapa da UI estava ativa.
      currentStep: getCurrentStep() 
    };
    localStorage.setItem('routeOptimizerState', JSON.stringify(currentState));
  } catch (e) {
    console.error('Erro ao salvar estado:', e);
    showToast('Não foi possível salvar o progresso da rota.', 4000);
  }
}

// Carrega o estado salvo do localStorage ao iniciar a página.
function loadSavedState() {
  const savedState = localStorage.getItem('routeOptimizerState');
  if (!savedState) return;

  try {
    const state = JSON.parse(savedState);
    
    // Se a última etapa era o mapa e existem dados de entrega, restaura tudo.
    if (state.currentStep === 'step3' && state.deliveryData && state.deliveryData.length > 0) {
      deliveryData = state.deliveryData;
      selectedColumns = state.selectedColumns || [];
      userLocation = state.userLocation;
      startPoint = state.startPoint;
      endPoint = state.endPoint;

      // Mostra a UI do mapa e esconde as etapas iniciais.
      document.getElementById('step1').classList.add('hidden');
      document.getElementById('step2').classList.add('hidden');
      document.getElementById('step3').classList.remove('hidden');
      
      showMapControls();
      initMap();
      updateUI();
      startTracking();
      
      showToast('Rota anterior restaurada com sucesso!', 3000);
    }
  } catch (e) {
    console.error('Erro ao carregar estado:', e);
    clearState(); // Limpa o estado corrompido.
  }
}

// Limpa o estado salvo e reseta as variáveis.
function clearState() {
  localStorage.removeItem('routeOptimizerState');
  deliveryData = [];
  selectedColumns = [];
  // Não limpe userLocation para poder usá-lo novamente.
  startPoint = null;
  endPoint = null;
  
  // Limpa campos de endereço no menu
  document.getElementById('startAddress').value = '';
  document.getElementById('endAddress').value = '';
  document.getElementById('startLat').value = '';
  document.getElementById('startLng').value = '';
  document.getElementById('endLat').value = '';
  document.getElementById('endLng').value = '';
}

// Função auxiliar para saber qual etapa está visível.
function getCurrentStep() {
  if (!document.getElementById('step1').classList.contains('hidden')) return 'step1';
  if (!document.getElementById('step2').classList.contains('hidden')) return 'step2';
  if (!document.getElementById('step3').classList.contains('hidden')) return 'step3';
  return null;
}


// ==== Mostrar controles do mapa ====
function showMapControls() {
  document.getElementById('menuToggleBtn').classList.remove('hidden');
  document.getElementById('toast').classList.remove('hidden');
}

function hideMapControls() {
  document.getElementById('menuToggleBtn').classList.add('hidden');
  document.getElementById('toast').classList.add('hidden');
}

// ==== Geocodificação ====
async function geocodeAddress(address) {
  try {
    const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}&countrycodes=br&limit=1`);
    const data = await response.json();
    
    if (data && data.length > 0) {
      return {
        lat: parseFloat(data[0].lat),
        lng: parseFloat(data[0].lon),
        display_name: data[0].display_name
      };
    }
    return null;
  } catch (error) {
    console.error('Erro na geocodificação:', error);
    return null;
  }
}

// ==== Event Listeners para Geocodificação ====
document.getElementById('geocodeStartBtn').addEventListener('click', async () => {
  const address = document.getElementById('startAddress').value.trim();
  if (!address) {
    showToast('Digite um endereço para buscar', 3000);
    return;
  }
  
  showToast('Buscando endereço...', 2000);
  const result = await geocodeAddress(address);
  
  if (result) {
    document.getElementById('startLat').value = result.lat;
    document.getElementById('startLng').value = result.lng;
    startPoint = { lat: result.lat, lng: result.lng };
    showToast('Endereço encontrado!', 3000);
    saveState();
  } else {
    showToast('Endereço não encontrado. Tente ser mais específico.', 4000);
  }
});

document.getElementById('geocodeEndBtn').addEventListener('click', async () => {
  const address = document.getElementById('endAddress').value.trim();
  if (!address) {
    showToast('Digite um endereço para buscar', 3000);
    return;
  }
  
  showToast('Buscando endereço...', 2000);
  const result = await geocodeAddress(address);
  
  if (result) {
    document.getElementById('endLat').value = result.lat;
    document.getElementById('endLng').value = result.lng;
    endPoint = { lat: result.lat, lng: result.lng };
    showToast('Endereço encontrado!', 3000);
    saveState();
  } else {
    showToast('Endereço não encontrado. Tente ser mais específico.', 4000);
  }
});

// ==== Upload ====
document.getElementById('fileInput').addEventListener('change', handleFileUpload);
document.getElementById('confirmColumnsBtn')?.addEventListener('click', () => {
  document.getElementById('step2').classList.add('hidden');
  document.getElementById('step3').classList.remove('hidden');
  
  showMapControls();
  saveState(); // Salva o estado após a seleção de colunas
  optimizeRoute(); 
});

// ==== Geolocalização ====
navigator.geolocation.getCurrentPosition(pos=>{
  userLocation={lat:pos.coords.latitude,lng:pos.coords.longitude};
  saveState();
},()=>{
  // Fallback para localização padrão se a geolocalização falhar
  userLocation={lat:-23.55,lng:-46.63};
  showToast('Não foi possível obter sua localização. Usando localização padrão.', 4000);
  saveState();
});

// Event listeners para checkboxes de localização atual
document.getElementById('useCurrentLocationStart').addEventListener('change', (e) => {
  if (e.target.checked) {
    if (userLocation) {
      document.getElementById('startLat').value = userLocation.lat;
      document.getElementById('startLng').value = userLocation.lng;
      startPoint = { lat: userLocation.lat, lng: userLocation.lng };
      document.getElementById('startAddress').value = 'Localização atual';
    } else {
      showToast('Aguardando localização atual...', 3000);
      navigator.geolocation.getCurrentPosition(pos => {
        userLocation = { lat: pos.coords.latitude, lng: pos.coords.longitude };
        document.getElementById('startLat').value = userLocation.lat;
        document.getElementById('startLng').value = userLocation.lng;
        startPoint = { lat: userLocation.lat, lng: userLocation.lng };
        document.getElementById('startAddress').value = 'Localização atual';
        saveState();
      }, () => {
        showToast('Não foi possível obter sua localização.', 3000);
        e.target.checked = false;
      });
    }
  } else {
    document.getElementById('startLat').value = '';
    document.getElementById('startLng').value = '';
    document.getElementById('startAddress').value = '';
    startPoint = null;
  }
  saveState();
});

document.getElementById('useCurrentLocationEnd').addEventListener('change', (e) => {
  if (e.target.checked) {
    if (userLocation) {
      document.getElementById('endLat').value = userLocation.lat;
      document.getElementById('endLng').value = userLocation.lng;
      endPoint = { lat: userLocation.lat, lng: userLocation.lng };
      document.getElementById('endAddress').value = 'Localização atual';
    } else {
      showToast('Aguardando localização atual...', 3000);
      navigator.geolocation.getCurrentPosition(pos => {
        userLocation = { lat: pos.coords.latitude, lng: pos.coords.longitude };
        document.getElementById('endLat').value = userLocation.lat;
        document.getElementById('endLng').value = userLocation.lng;
        endPoint = { lat: userLocation.lat, lng: userLocation.lng };
        document.getElementById('endAddress').value = 'Localização atual';
        saveState();
      }, () => {
        showToast('Não foi possível obter sua localização.', 3000);
        e.target.checked = false;
      });
    }
  } else {
    document.getElementById('endLat').value = '';
    document.getElementById('endLng').value = '';
    document.getElementById('endAddress').value = '';
    endPoint = null;
  }
  saveState();
});

// Event listeners para campos de coordenadas manuais
document.getElementById('startLat').addEventListener('change', updateStartPoint);
document.getElementById('startLng').addEventListener('change', updateStartPoint);
document.getElementById('endLat').addEventListener('change', updateEndPoint);
document.getElementById('endLng').addEventListener('change', updateEndPoint);

function updateStartPoint() {
  const lat = parseFloat(document.getElementById('startLat').value);
  const lng = parseFloat(document.getElementById('startLng').value);
  if (!isNaN(lat) && !isNaN(lng)) {
    startPoint = { lat, lng };
    document.getElementById('useCurrentLocationStart').checked = false;
  } else {
    startPoint = null;
  }
  saveState();
}

function updateEndPoint() {
  const lat = parseFloat(document.getElementById('endLat').value);
  const lng = parseFloat(document.getElementById('endLng').value);
  if (!isNaN(lat) && !isNaN(lng)) {
    endPoint = { lat, lng };
    document.getElementById('useCurrentLocationEnd').checked = false;
  } else {
    endPoint = null;
  }
  saveState();
}

// ==== Upload de arquivo ====
function handleFileUpload(e) {
  const file = e.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = (event) => {
    try {
      const data = new Uint8Array(event.target.result);
      const workbook = XLSX.read(data, { type: 'array' });
      const sheetName = workbook.SheetNames[0];
      const worksheet = workbook.Sheets[sheetName];
      const jsonData = XLSX.utils.sheet_to_json(worksheet);

      if (jsonData.length === 0) {
        showToast('Arquivo vazio ou formato inválido', 4000);
        return;
      }

      // Verificar se há colunas de latitude e longitude
      const firstRow = jsonData[0];
      const hasLatLng = firstRow.hasOwnProperty('Latitude') && firstRow.hasOwnProperty('Longitude');
      
      if (!hasLatLng) {
        showToast('Arquivo deve conter colunas "Latitude" e "Longitude"', 4000);
        return;
      }

      deliveryData = jsonData.map((row, index) => ({
        ...row,
        Sequence: index + 1,
        status: "pendente"
      }));

      // Mostrar seleção de colunas
      const cols = Object.keys(deliveryData[0]).filter(c => c !== 'status');
      const container = document.getElementById("columnsList");
      container.innerHTML = cols.map(c => `
        <label class="flex items-center space-x-2 cursor-pointer hover:bg-gray-50 p-2 rounded">
          <input type="checkbox" value="${c}" class="columnChk text-indigo-600" ${['Destination Address', 'Cliente', 'Endereço'].includes(c) ? 'checked' : ''}/>
          <span>${c}</span>
        </label>`).join('');

      document.getElementById('step1').classList.add('hidden');
      document.getElementById('step2').classList.remove('hidden');
      
      saveState();
      showToast(`${deliveryData.length} entregas carregadas!`, 3000);

    } catch (error) {
      console.error('Erro ao processar arquivo:', error);
      showToast('Erro ao processar arquivo. Verifique o formato.', 4000);
    }
  };
  reader.readAsArrayBuffer(file);
}

// ==== Toast ====
function showToast(message, duration = 3000) {
  const toast = document.getElementById('toast');
  const toastMessage = document.getElementById('toastMessage');
  
  toastMessage.textContent = message;
  toast.classList.remove('hidden');
  toast.classList.add('show');
  
  setTimeout(() => {
    toast.classList.remove('show');
    setTimeout(() => toast.classList.add('hidden'), 300);
  }, duration);
}

// ==== Função de distância ====
function haversine(pos1, pos2) {
  const R = 6371; // Raio da Terra em km
  const dLat = (pos2.lat - pos1.lat) * Math.PI / 180;
  const dLon = (pos2.lng - pos1.lng) * Math.PI / 180;
  const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
    Math.cos(pos1.lat * Math.PI / 180) * Math.cos(pos2.lat * Math.PI / 180) *
    Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

// ==== Otimização de rota ====
async function optimizeRoute() { // Transforme em async
  if (deliveryData.length === 0) {
    showToast('Nenhuma entrega para otimizar', 3000);
    return;
  }

  // Determinar ponto de partida
  let currentStartPoint = startPoint;
  if (!currentStartPoint && userLocation) {
    currentStartPoint = userLocation;
  }
  if (!currentStartPoint) {
    showToast('Defina um ponto de partida ou permita acesso à localização', 4000);
    return;
  }

  // Determinar ponto de término
  let currentEndPoint = endPoint;

  showToast('Otimizando rota...', 2000);

  // Resetar status de todas as entregas
  deliveryData.forEach(d => d.status = "pendente");

  const unvisitedIndices = deliveryData.map((_, i) => i);
  let order = [];
  let currentPoint = currentStartPoint;

  // Encontrar a primeira entrega mais próxima do ponto de partida
  let firstStopIndex = -1;
  let minDistanceFromStart = Infinity;
  unvisitedIndices.forEach(idx => {
    const delivery = deliveryData[idx];
    const dist = haversine(currentPoint, { lat: +delivery.Latitude, lng: +delivery.Longitude });
    if (dist < minDistanceFromStart) {
      minDistanceFromStart = dist;
      firstStopIndex = idx;
    }
  });

  if (firstStopIndex !== -1) {
    order.push(firstStopIndex);
    unvisitedIndices.splice(unvisitedIndices.indexOf(firstStopIndex), 1);
    currentPoint = { lat: +deliveryData[firstStopIndex].Latitude, lng: +deliveryData[firstStopIndex].Longitude };
  } else {
    showToast('Nenhuma entrega encontrada para otimizar.', 4000);
    return;
  }

  // Algoritmo do Vizinho Mais Próximo para o restante das entregas
  while (unvisitedIndices.length > 0) {
    let bestNextIndex = -1;
    let minDistance = Infinity;

    unvisitedIndices.forEach(idx => {
      const delivery = deliveryData[idx];
      const dist = haversine(currentPoint, { lat: +delivery.Latitude, lng: +delivery.Longitude });
      if (dist < minDistance) {
        minDistance = dist;
        bestNextIndex = idx;
      }
    });

    if (bestNextIndex !== -1) {
      order.push(bestNextIndex);
      unvisitedIndices.splice(unvisitedIndices.indexOf(bestNextIndex), 1);
      currentPoint = { lat: +deliveryData[bestNextIndex].Latitude, lng: +deliveryData[bestNextIndex].Longitude };
    } else {
      break;
    }
  }

  // Reordenar deliveryData com base na nova ordem
  deliveryData = order.map((originalIndex, newSequence) => ({
    ...deliveryData[originalIndex],
    Sequence: newSequence + 1,
    status: "pendente"
  }));

  showToast(`Rota otimizada com ${deliveryData.length} entregas!`, 4000);
  
  initMap();
  updateUI(); // Isso vai desenhar os marcadores e a rota sem ajustar o zoom
  startTracking();
  saveState();

  // ADICIONE ESTE BLOCO NO FINAL DA FUNÇÃO
  // Agora, após a rota ser desenhada pela primeira vez, ajustamos o zoom.
  // Usamos um pequeno delay para garantir que a camada da rota (routeLayer) já foi criada.
  setTimeout(() => {
    if (routeLayer) {
      map.fitBounds(routeLayer.getBounds(), { padding: [50, 50] }); // Adiciona um preenchimento para melhor visualização
    }
  }, 500); // 500ms de espera
}

// ==== Inicializar mapa ====
function initMap(){
  if(!map){
    map=L.map('map').setView([userLocation.lat,userLocation.lng],13);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19}).addTo(map);
  }
}

// ==== Atualizar estatísticas e UI ====
function updateUI(){
  updateMarkers();
  showNextStop();
  drawFullRoute();
  drawNextDeliveryRoute(); // Nova função para destacar rota até próxima entrega
  updateStats();

  document.getElementById('routeList').innerHTML=deliveryData.map(d=>{
    let bg=d.status==="entregue"?"bg-green-50 border-green-200":d.status==="naoentregue"?"bg-red-50 border-red-200":"bg-yellow-50 border-yellow-200";
    let text=d.status==="entregue"?"text-green-700":d.status==="naoentregue"?"text-red-700":"text-yellow-700";
    let icon=d.status==="entregue"?"fas fa-check-circle":d.status==="naoentregue"?"fas fa-times-circle":"fas fa-clock";
    
    return `<div class="p-3 rounded-lg mb-2 border ${bg} flex justify-between items-center">
              <div class="flex items-center space-x-3">
                <div class="w-8 h-8 bg-indigo-600 text-white rounded-full flex items-center justify-center text-xs font-bold">
                  ${d.Sequence}
                </div>
                <span class="text-sm">${d['Destination Address']||'Sem endereço'}</span>
              </div>
              <div class="flex items-center space-x-2">
                <i class="${icon} ${text}"></i>
                <span class="${text} font-medium capitalize text-xs">${d.status.replace('naoentregue', 'não entregue')}</span>
              </div>
            </div>`;
  }).join('');
}

// ==== Atualizar estatísticas ====
function updateStats() {
  const total = deliveryData.length;
  const entregues = deliveryData.filter(d => d.status === 'entregue').length;
  const naoEntregues = deliveryData.filter(d => d.status === 'naoentregue').length;
  const pendentes = deliveryData.filter(d => d.status === 'pendente').length;
  
  const progress = total > 0 ? Math.round((entregues / total) * 100) : 0;
  
  document.getElementById('routeStats').innerHTML = `
    <div class="space-y-2">
      <div class="flex justify-between">
        <span>Total:</span>
        <span class="font-semibold">${total}</span>
      </div>
      <div class="flex justify-between">
        <span class="text-green-600">Entregues:</span>
        <span class="font-semibold text-green-600">${entregues}</span>
      </div>
      <div class="flex justify-between">
        <span class="text-red-600">Não entregues:</span>
        <span class="font-semibold text-red-600">${naoEntregues}</span>
      </div>
      <div class="flex justify-between">
        <span class="text-yellow-600">Pendentes:</span>
        <span class="font-semibold text-yellow-600">${pendentes}</span>
      </div>
      <div class="mt-3 pt-2 border-t border-indigo-200">
        <div class="flex justify-between mb-1">
          <span class="text-sm font-medium">Progresso:</span>
          <span class="text-sm font-semibold">${progress}%</span>
        </div>
        <div class="w-full bg-gray-200 rounded-full h-2">
          <div class="bg-indigo-600 h-2 rounded-full transition-all duration-300" style="width: ${progress}%"></div>
        </div>
      </div>
    </div>
  `;
}

// ==== Marcadores ====
function updateMarkers(){
  markers.forEach(m=>map.removeLayer(m)); markers=[];
  const next=deliveryData.find(d=>d.status==="pendente");
  deliveryData.forEach(d=>{
    let color=d.status==="entregue"?"green":d.status==="naoentregue"?"red":"blue";
    let size=28;
    if(next && d.Sequence===next.Sequence && d.status==="pendente"){ color="orange"; size=36; }
    const icon=L.divIcon({className:'',html:`<div style="background:${color};color:white;border-radius:50%;width:${size}px;height:${size}px;display:flex;align-items:center;justify-content:center;font-size:12px;border:2px solid white;box-shadow:0 2px 4px rgba(0,0,0,0.2)">${d.Sequence}</div>`});
    const mk=L.marker([+d.Latitude,+d.Longitude],{icon}).addTo(map);
    mk.bindPopup(`<b>Parada ${d.Sequence}</b><br>${d['Destination Address']||''}<br>
      <button class="delivered" onclick="changeStatus(${d.Sequence},'entregue')"><i class="fas fa-check"></i></button>
      <button class="notdelivered" onclick="changeStatus(${d.Sequence},'naoentregue')"><i class="fas fa-times"></i></button>
      <button class="pending" onclick="changeStatus(${d.Sequence},'pendente')"><i class="fas fa-pause"></i></button>`);
    markers.push(mk);
  });

  // Adicionar marcador para o ponto de partida se definido
  if (startPoint) {
    const startIcon = L.divIcon({className:'',html:`<div style="background:#007bff;color:white;border-radius:50%;width:32px;height:32px;display:flex;align-items:center;justify-content:center;font-size:14px;border:2px solid white;box-shadow:0 2px 4px rgba(0,0,0,0.2)"><i class="fas fa-play"></i></div>`});
    const startMk = L.marker([startPoint.lat, startPoint.lng], {icon: startIcon}).addTo(map);
    startMk.bindPopup('<b>Ponto de Partida</b>');
    markers.push(startMk);
  }

  // Adicionar marcador para o ponto de término se definido
  if (endPoint) {
    const endIcon = L.divIcon({className:'',html:`<div style="background:#dc3545;color:white;border-radius:50%;width:32px;height:32px;display:flex;align-items:center;justify-content:center;font-size:14px;border:2px solid white;box-shadow:0 2px 4px rgba(0,0,0,0.2)"><i class="fas fa-flag-checkered"></i></div>`});
    const endMk = L.marker([endPoint.lat, endPoint.lng], {icon: endIcon}).addTo(map);
    endMk.bindPopup('<b>Ponto de Término</b>');
    markers.push(endMk);
  }
}

// ==== Barra próxima parada ====
function showNextStop(){
  const next=deliveryData.find(d=>d.status==="pendente");
  if(!next){
    document.getElementById('nextStopBar').classList.add("hidden");
    showToast("🎉 Todas as entregas foram processadas!");
    return;
  }
  document.getElementById('nextStopBar').classList.remove("hidden");

  selectedColumns=[...document.querySelectorAll(".columnChk:checked")].map(c=>c.value);
  let extraInfo=selectedColumns.map(c=>`<i class="fas fa-info-circle mr-1"></i>${c}: ${next[c]||''}`).join("<br>");

  document.getElementById('nextStopInfo').innerHTML=`
    <div class="flex flex-col space-y-1">
      <div class="font-medium text-gray-800">${next['Destination Address']||'Sem endereço'}</div>
      <div class="text-xs text-gray-500 mt-1">${extraInfo}</div>
    </div>
  `;
}

// ==== Rota completa ====
async function drawFullRoute(){
  if (routeLayer) map.removeLayer(routeLayer);

  const routePoints = [];

  // Adiciona o ponto de partida se definido
  if (startPoint) {
    routePoints.push(startPoint);
  } else if (userLocation) {
    routePoints.push(userLocation);
  }

  // Adiciona todas as entregas na ordem otimizada
  deliveryData.forEach(d => {
    routePoints.push({ lat: +d.Latitude, lng: +d.Longitude });
  });

  // Adiciona o ponto de término se definido
  if (endPoint) {
    routePoints.push(endPoint);
  }

  if (routePoints.length < 2) {
    return;
  }

  const coords = routePoints.map(p => `${p.lng},${p.lat}`).join(';');
  const url = `https://router.project-osrm.org/route/v1/driving/${coords}?overview=full&geometries=geojson`;

  try {
    const res = await fetch(url );
    const data = await res.json();
    if (data.routes && data.routes.length) {
      routeLayer = L.geoJSON(data.routes[0].geometry, { 
        style: { color: "#4f46e5", weight: 4, opacity: 0.6 } 
      }).addTo(map);
      // A LINHA ABAIXO FOI REMOVIDA DESTA FUNÇÃO
      // map.fitBounds(routeLayer.getBounds()); 
    } else {
      showToast('Não foi possível traçar a rota completa.', 3000);
    }
  } catch (error) {
    console.error('Erro ao buscar rota do OSRM:', error);
    showToast('Erro ao traçar a rota. Verifique sua conexão ou os pontos.', 3000);
  }
}

// ==== Nova função: Rota destacada até próxima entrega ====
async function drawNextDeliveryRoute(){
  if (nextDeliveryRouteLayer) map.removeLayer(nextDeliveryRouteLayer);

  const nextDelivery = deliveryData.find(d => d.status === "pendente");
  if (!nextDelivery || !userLocation) {
    return;
  }

  const routePoints = [
    userLocation,
    { lat: +nextDelivery.Latitude, lng: +nextDelivery.Longitude }
  ];

  const coords = routePoints.map(p => `${p.lng},${p.lat}`).join(';');
  const url = `https://router.project-osrm.org/route/v1/driving/${coords}?overview=full&geometries=geojson`;

  try {
    const res = await fetch(url);
    const data = await res.json();
    if (data.routes && data.routes.length) {
      nextDeliveryRouteLayer = L.geoJSON(data.routes[0].geometry, { 
        style: { 
          color: "#ff6b35", 
          weight: 8, 
          opacity: 0.9,
          dashArray: '10, 5'
        } 
      }).addTo(map);
    }
  } catch (error) {
    console.error('Erro ao buscar rota para próxima entrega:', error);
  }
}

// ==== Localização em tempo real ====
function startTracking() {
  if (!navigator.geolocation) return;

  // Mostra o botão de centralizar no usuário
  const centerBtn = document.getElementById('centerUserBtn');
  centerBtn.classList.remove('hidden');
  centerBtn.addEventListener('click', () => {
    if (userLocation) {
      map.setView([userLocation.lat, userLocation.lng], 16); // Centraliza com um zoom fixo de 16
    }
  });

  navigator.geolocation.watchPosition(pos => {
    const { latitude, longitude } = pos.coords;
    userLocation = { lat: latitude, lng: longitude };
    saveState();

    if (!userMarker) {
      const pulseIcon = L.divIcon({
        className: "",
        html: `<div class="relative"><div class="w-6 h-6 bg-blue-500 rounded-full border-4 border-white shadow-md"></div><div class="absolute inset-0 rounded-full bg-blue-400 opacity-50 animate-ping"></div></div>`
      });
      userMarker = L.marker([latitude, longitude], { icon: pulseIcon }).addTo(map).bindPopup("📍 Você está aqui");
    } else {
      userMarker.setLatLng([latitude, longitude]);
    }
    
    // Atualizar rota destacada para próxima entrega
    drawNextDeliveryRoute();

    // --- LÓGICA DE ZOOM AUTOMÁTICO ---
    const nextDelivery = deliveryData.find(d => d.status === "pendente");
    if (nextDelivery) {
      const distanceToNext = haversine(userLocation, { lat: +nextDelivery.Latitude, lng: +nextDelivery.Longitude });

      // Se estiver a menos de 1 km (1000 metros) da próxima parada...
      if (distanceToNext < 1) {
        // Ajusta o zoom para focar em você e na próxima entrega
        const bounds = L.latLngBounds([
          [userLocation.lat, userLocation.lng],
          [+nextDelivery.Latitude, +nextDelivery.Longitude]
        ]);
        map.fitBounds(bounds, { padding: [70, 70], maxZoom: 17 }); // maxZoom evita um zoom excessivo
      }
    }
    // --- FIM DA LÓGICA DE ZOOM ---

  }, err => {
    console.error("Erro de geolocalização:", err);
    showToast("Erro ao obter sua localização.", 3000);
  }, { 
    enableHighAccuracy: true, // Pede a localização mais precisa possível
    maximumAge: 5000,         // Não aceita posições mais antigas que 5 segundos
    timeout: 10000            // Tempo máximo para obter a posição
  });
}


// ==== Status ====
function markNext(status){
  const next=deliveryData.find(d=>d.status==="pendente");
  if(next){
    next.status=status; 
    updateUI();
    saveState();
    const messages = {
      'entregue': '✅ Entrega realizada!',
      'naoentregue': '❌ Entrega não realizada',
      'pendente': '⏸️ Entrega como pendente'
    };
    showToast(messages[status]);
  }
}

function changeStatus(seq,status){
  const stop=deliveryData.find(d=>d.Sequence===seq);
  if(stop){
    stop.status=status; 
    updateUI();
    saveState();
  }
}

// ==== Menu lateral ====
const menuBtn = document.getElementById("menuToggleBtn");
const sideMenu = document.getElementById("sideMenu");
const overlay = document.getElementById("menuOverlay");
const closeBtn = document.getElementById("closeMenuBtn");
const loadNewFileBtn = document.getElementById("loadNewFileBtn");
const optimizeInMenuBtn = document.getElementById("optimizeInMenuBtn");

function toggleMenu(force = null) {
  const isOpen = !sideMenu.classList.contains("hidden");
  const shouldOpen = force !== null ? force : !isOpen;

  if (shouldOpen) {
    sideMenu.classList.remove("hidden");
    overlay.classList.remove("hidden");
    setTimeout(() => sideMenu.classList.remove("-translate-x-full"), 10);
    
    // Mostrar o botão de otimização dentro do menu
    optimizeInMenuBtn.classList.remove('hidden');

  } else {
    sideMenu.classList.add("-translate-x-full");
    overlay.classList.add("hidden");
    setTimeout(() => sideMenu.classList.add("hidden"), 300);

    // Esconder o botão de otimização dentro do menu
    optimizeInMenuBtn.classList.add('hidden');
  }
}

function resetApp() {
  if (confirm('Tem certeza que deseja recomeçar? Todos os dados da rota atual serão perdidos.')) {
    clearState();
    
    hideMapControls();
    
    toggleMenu(false);
    
    // Voltar para etapa inicial
    document.getElementById('step3').classList.add('hidden');
    document.getElementById('step2').classList.add('hidden');
    document.getElementById('step1').classList.remove('hidden');
    
    // Limpar input de arquivo
    document.getElementById('fileInput').value = '';
    
    showToast('Aplicação reiniciada!', 2000);
    window.location.reload();
  }
}

function handleOptimizeClick() {
  // Fechar menu se estiver aberto
  toggleMenu(false);
  
  // Executar otimização
  optimizeRoute();
}

menuBtn.addEventListener("click", () => toggleMenu());
closeBtn.addEventListener("click", () => toggleMenu(false));
overlay.addEventListener("click", () => toggleMenu(false));
loadNewFileBtn.addEventListener("click", resetApp);
optimizeInMenuBtn.addEventListener("click", handleOptimizeClick);
</script>
</body>
</html>

