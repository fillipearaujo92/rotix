

<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Rotix - Otimizador de Rotas</title>
  <link rel="icon" type="image/png" href="img/favicon.png">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
    
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"/>
  <script>
    tailwind.config = {
      darkMode: 'class'
    }
  </script>

  <style>
    :root { --rotix-blue: #5e33ea; }
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap' );
    body { font-family: 'Inter', sans-serif; }
    #map { height: 100vh; }
    .leaflet-control-zoom, .leaflet-control-attribution { display: none !important; }
    .leaflet-popup-content-wrapper { border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
    .dark .leaflet-popup-content-wrapper {background: #2d3748; }
    .leaflet-popup-content { margin: 15px; font-size: 14px; line-height: 1.6; }
    .leaflet-popup-content b { font-weight: 600; }
    .leaflet-popup-content small { color: #555; }
    .leaflet-popup-tip { box-shadow: none; }

    .toast {
      position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.85);
      backdrop-filter: blur(5px);
      color: #141414; padding: 12px 20px; border-radius: 25px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2); z-index: 10001;
      display: none; align-items: center;
      z-index: 9999;
    }
    .dark .toast {
      background: #2d3748; 
      color: white;
    }
    .toast.show { display: flex; animation: fadeIn 0.3s ease; }
    @keyframes fadeIn { from { opacity: 0; transform: translate(-50%, -20px); } to { opacity: 1; transform: translate(-50%, 0); } }

    .map-floating-btn {
      position: fixed; z-index: 1000; background-color: white;
      width: 48px; height: 48px; border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2); cursor: pointer;
      transition: all 0.2s ease;
    }

    .dark .map-floating-btn {
      background-color: #2d3748; /* cinza escuro */
      color: #f7fafc;            /* texto claro */
    }

    .map-floating-btn:hover { transform: scale(1.05); }
    #menuToggleBtn { top: 20px; left: 20px; border: 3px solid white; box-shadow: 5px 5px 20px rgba(0,0,0,0.5); cursor: pointer;}
    #settingsBtn { bottom: 250px; right: 20px; border: 3px solid white; box-shadow: 5px 5px 20px rgba(0,0,0,0.5); cursor: pointer; }    
    #reOptimizeBtn { bottom: 430px; right: 20px; border: 3px solid white; box-shadow: 5px 5px 20px rgba(0,0,0,0.5); cursor: pointer;}
    #centerUserBtn { bottom: 370px; right: 20px; border: 3px solid white; box-shadow: 5px 5px 20px rgba(0,0,0,0.5); cursor: pointer;}
    #fullscreenBtn { bottom: 310px; right: 20px; border: 3px solid white; box-shadow: 5px 5px 20px rgba(0,0,0,0.5); cursor: pointer; }
    #themeToggleBtn { bottom: 250px; right: 20px; border: 3px solid white; box-shadow: 5px 5px 20px rgba(0,0,0,0.5); cursor: pointer; }

    #sideMenu {
        z-index: 9999;
        box-shadow: 6px 0px 20px 0px #0000008a;
        scrollbar-width: none;
    }

    #menuOverlay {background: #141414;}

    /* Estilos para o Modal de Progresso */
    #progressModal.hidden {
      display: none;
    }

    /* Animaﾃｧﾃ｣o do Spinner (Loader) */
    .loader {
      border: 5px solid #f3f3f3; /* Cinza claro */
      border-top: 5px solid #5e33ea; /* Roxo Rotix */
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

  </style>
</head>
<body class="bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-white">

  <!-- Toast Notification -->
  <div id="toast" class="toast">
    <i id="toastIcon" class="fas fa-info-circle mr-3"></i>
    <span id="toastMessage"></span>
  </div>

  <!-- Modal de Progresso da Otimizaﾃｧﾃ｣o -->
    <div id="progressModal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-[9999] flex items-center justify-center">
        <div class="bg-white dark:bg-gray-800 rounded-2xl shadow-lg p-8 flex flex-col items-center space-y-4 w-64">
            <div class="loader"></div>
            <h3 class="text-gray-700 font-semibold text-lg dark:text-white">Otimizando Rota...</h3>
            <p id="progressText" class="text-gray-500 text-sm dark:text-white">Calculando distﾃ｢ncias...</p>
        </div>
    </div>

    <div id="confirmModal" class="hidden fixed inset-0 bg-black bg-opacity-60 z-[9999] flex items-center justify-center p-4">
    <div class="bg-white dark:bg-gray-800 rounded-2xl shadow-lg p-6 flex flex-col w-full max-w-sm">
        <div class="flex items-center mb-4">
        <!--<i class="fas fa-exclamation-triangle text-yellow-500 text-2xl mr-4"></i>-->
        <h3 id="confirmTitle" class="text-gray-800 font-bold text-lg dark:text-white">Atenﾃｧﾃ｣o</h3>
        </div>
        <p id="confirmMessage" class="text-gray-600 text-sm mb-6 dark:text-white">Deseja continuar com esta aﾃｧﾃ｣o?</p>
        <div class="flex justify-end space-x-3">
        <button id="confirmCancelBtn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-semibold py-2 px-5 rounded-lg transition-colors">Cancelar</button>
        <button id="confirmOkBtn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-5 rounded-lg transition-colors">OK</button>
        </div>
    </div>
    </div>

  <!-- Botﾃｵes Flutuantes do Mapa -->
  <button id="menuToggleBtn" class="map-floating-btn hidden">
    <i class="fas fa-bars text-xl text-gray-600 dark:text-white"></i>
  </button>
  <button id="settingsBtn" class="map-floating-btn hidden" title="Configuraﾃｧﾃｵes">
    <i class="fas fa-cog text-xl dark:text-white"></i>
  </button>
  <button id="centerUserBtn" class="map-floating-btn hidden">
    <i class="fas fa-location-crosshairs text-xl text-sky-600 dark:text-white"></i>
  </button>
  <button id="reOptimizeBtn" class="map-floating-btn hidden" title="Reotimizar Rota a partir da sua localizaﾃｧﾃ｣o">
    <i class="fas fa-route text-xl text-green-600 dark:text-white"></i>
  </button>
  <button id="fullscreenBtn" class="map-floating-btn hidden" title="Tela Cheia">
    <i class="fas fa-expand text-xl text-sky-600 dark:text-white"></i>
  </button>
  <!--<button id="themeToggleBtn" class="map-floating-btn hidden" title="Alternar Tema">
    <i class="fas fa-sun text-xl text-yellow-500 dark:text-white"></i>
  </button> -->

  <!-- NOVO: Modal de Configuraﾃｧﾃｵes -->
  <div id="settingsModal" class="hidden fixed inset-0 bg-black bg-opacity-60 z-[9999] flex items-center justify-center p-4">
      <div class="bg-white dark:bg-gray-800 rounded-2xl shadow-lg p-6 flex flex-col w-full max-w-md">
          <div class="flex justify-between items-center mb-6">
              <h3 class="text-gray-800 font-bold text-lg dark:text-white"><i class="fas fa-cog mr-2"></i>Configuraﾃｧﾃｵes</h3>
              <button id="closeSettingsBtn" class="text-gray-500 hover:text-red-500"><i class="fas fa-times text-xl"></i></button>
          </div>

          <div class="space-y-6">
              <!-- Seﾃｧﾃ｣o de Navegaﾃｧﾃ｣o -->
              <div>
                  <label for="navAppSelect" class="block text-sm font-medium text-gray-700 dark:text-gray-300">Aplicativo de Navegaﾃｧﾃ｣o Padrﾃ｣o</label>
                  <select id="navAppSelect" class="mt-1 block w-full p-2 border border-gray-300 dark:bg-gray-700 dark:border-gray-600 rounded-md shadow-sm">
                      <option value="google">Google Maps</option>
                      <option value="waze">Waze</option>
                      <option value="apple">Apple Maps (somente iOS)</option>
                  </select>
                  <p class="text-xs text-gray-500 mt-1">O aplicativo serﾃ｡ aberto ao clicar em "Navegar".</p>
              </div>

              <!-- Seﾃｧﾃ｣o de Zoom Automﾃ｡tico -->
              <div>
                  <label class="block text-sm font-medium text-gray-700 dark:text-gray-300">Zoom Automﾃ｡tico</label>
                  <div class="flex items-center mt-2">
                      <input id="autoZoomToggle" type="checkbox" class="h-4 w-4 text-indigo-600 border-gray-300 rounded" checked>
                      <label for="autoZoomToggle" class="ml-2 block text-sm text-gray-900 dark:text-gray-200">Aproximar mapa ao chegar perto do destino</label>
                  </div>
              </div>
              
            <fieldset class="border-t border-gray-200 dark:border-gray-700 pt-4">
                <legend class="text-sm font-semibold text-gray-900 dark:text-gray-200">Comportamento da Rota</legend>
                
                <div class="mt-4 space-y-4">
                  <div class="flex items-center justify-between">
                        <span class="text-sm font-medium text-gray-700 dark:text-gray-300">Retornar ao Ponto Inicial</span>
                        <button id="returnToStartToggle" type="button" class="relative inline-flex h-6 w-11 flex-shrink-0 cursor-pointer rounded-full border-2 border-transparent transition-colors duration-200 ease-in-out focus:outline-none bg-gray-200" role="switch" aria-checked="false">
                            <span class="sr-only">Ativar retorno ao ponto inicial</span>
                            <span aria-hidden="true" class="pointer-events-none inline-block h-5 w-5 transform rounded-full bg-white shadow ring-0 transition duration-200 ease-in-out translate-x-0"></span>
                        </button>
                    </div>
                    <p class="text-xs text-gray-500 mt-1">Se ativado, a rota serﾃ｡ otimizada para terminar na parada mais prﾃｳxima do seu ponto de partida.</p>
                    <div id="endPointAddressContainer" class="hidden pl-4 border-l-2 border-indigo-200">
                        <label for="endAddress" class="block text-xs font-medium text-gray-500 dark:text-gray-400">Endereﾃｧo de Tﾃｩrmino</label>
                        <textarea id="endAddress" placeholder="Digite o endereﾃｧo de tﾃｩrmino" class="mt-1 w-full p-2 border border-gray-300 dark:bg-gray-700 dark:border-gray-600 rounded-md text-sm" rows="2"></textarea>
                        <button id="geocodeEndBtn" class="mt-2 w-full bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded text-sm"><i class="fas fa-search mr-1"></i>Buscar Endereﾃｧo</button>
                    </div>
                    <!-- NOVO: Tempo de Serviﾃｧo -->
                    <div>
                        <label for="serviceTimeInput" class="block text-sm font-medium text-gray-700 dark:text-gray-300">Tempo de Serviﾃｧo por Parada (minutos)</label>
                        <input type="number" id="serviceTimeInput" value="5" class="mt-1 block w-full p-2 border border-gray-300 dark:bg-gray-700 dark:border-gray-600 rounded-md shadow-sm">
                        <p class="text-xs text-gray-500 mt-1">Adiciona um tempo fixo a cada parada para uma estimativa de duraﾃｧﾃ｣o mais precisa.</p>
                    </div>
                </div>
            </fieldset>

            <!-- Seﾃｧﾃ｣o de Interface e Experiﾃｪncia -->
            <div class="border-t border-gray-200 dark:border-gray-700 pt-4">
                <legend class="text-sm font-semibold text-gray-900 dark:text-gray-200">Interface e Experiﾃｪncia</legend>

                <div class="mt-4 space-y-4">
                  <div>
                <label class="block text-sm font-medium text-gray-700 dark:text-gray-300">Tema da Interface</label>
                <div class="mt-2 flex items-center justify-between p-3 rounded-lg">
                    <span class="text-gray-800 dark:text-gray-200">Modo Escuro</span>
                    <button id="themeToggleSwitch" type="button" class="relative inline-flex h-6 w-11 flex-shrink-0 cursor-pointer rounded-full border-2 border-transparent transition-colors duration-200 ease-in-out focus:outline-none bg-gray-200 dark:bg-indigo-600" role="switch" aria-checked="false">
                        <span class="sr-only">Use setting</span>
                        <span aria-hidden="true" class="pointer-events-none inline-block h-5 w-5 transform rounded-full bg-white shadow ring-0 transition duration-200 ease-in-out translate-x-0 dark:translate-x-5"></span>
                    </button>
                </div>
            </div>
                    <!-- NOVO: Tema do Mapa -->
                    <div>
                        <label for="mapThemeSelect" class="block text-sm font-medium text-gray-700 dark:text-gray-300">Tema do Mapa</label>
                        <select id="mapThemeSelect" class="mt-1 block w-full p-2 border border-gray-300 dark:bg-gray-700 dark:border-gray-600 rounded-md shadow-sm">
                            <option value="voyager">Claro (Padrﾃ｣o)</option>
                            <option value="dark_matter">Escuro</option>
                            <option value="hybrid">Satﾃｩlite com Ruas</option>
                        </select>
                    </div>
                </div>
              </div>
          </div>
      </div>
  </div>

  <!-- Menu Lateral -->
  <div id="menuOverlay" class="hidden fixed inset-0 bg-black bg-opacity-40 z-40"></div>
  <div id="sideMenu" class="hidden dark:bg-gray-800 fixed top-0 left-0 w-full max-w-sm h-full bg-white z-5000 p-6 overflow-y-auto transform -translate-x-full transition-transform duration-300">
    
    <div class="flex justify-between items-center mb-6">
      <h4 class="font-semibold text-gray-800 dark:text-white text-lg"><i class="fa-solid fa-bars"></i> Menu</h4>
      <button id="closeMenuBtn" class="text-gray-500 hover:text-red-500"><i class="fas fa-times text-xl"></i></button>
    </div>
    
    <div class="mb-6 p-4 bg-red-50 dark:bg-red-900 border-red-300 dark:border-red-700 border border-red-200 rounded-lg">
      <h5 class="font-medium text-red-800 mb-2 dark:text-white"><i class="fas fa-exclamation-triangle mr-2"></i>Recomeﾃｧar Rota</h5>
      <p class="text-sm dark:text-white text-red-600 mb-3">Isso apagarﾃ｡ a rota atual e voltarﾃ｡ ao inﾃｭcio.</p>
      <button id="loadNewFileBtn" class="w-full bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-lg font-medium transition"><i class="fas fa-file-upload mr-2"></i>Carregar Novo Arquivo</button>
    </div>

    <!-- SEﾃﾃグ DE CONFIGURAﾃﾃ髭S DE ROTA FOI REMOVIDA -->
    <div class="mb-6 p-4 bg-indigo-50 border border-indigo-200 rounded-lg">
      <h5 class="font-medium text-indigo-800 mb-2"><i class="fas fa-chart-bar mr-2"></i>Estatﾃｭsticas</h5>
      <div id="routeStats" class="text-sm text-indigo-700"></div>
    </div>
    
    <div class="flex justify-between items-center mb-6">
      <h4 class="font-semibold text-gray-800 dark:text-white text-lg"><i class="fa-regular fa-rectangle-list"></i> Lista de Entregas</h4>
    </div>

    <div id="routeList"></div>
  </div>

  <!-- Etapa 1: Upload -->
  <div id="step1" class="flex-1 flex flex-col items-center justify-center p-6 min-h-screen">
    <div class="bg-white dark:bg-gray-800 rounded-2xl shadow-lg p-10 w-full max-w-md text-center">
      <div class="w-20 h-20 mx-auto mb-6 bg-gradient-to-br from-[var(--rotix-blue)] to-purple-800 rounded-3xl flex items-center justify-center">
        <img src="img/logo.svg" width="45">
        </div>
      <h1 class="text-4xl font-bold tracking-widest text-gray-800 dark:text-white">Rotix</h1>
      <h3 class="text-xs tracking-widest text-gray-500 dark:text-white mb-8">Inteligﾃｪncia em movimento</h3>
      <label for="fileInput" class="cursor-pointer block border-2 border-dashed border-indigo-400 rounded-xl p-10 hover:bg-indigo-50 transition">
        <i class="fas fa-file-excel text-4xl text-indigo-500 mb-4 block"></i>
        <span class="text-indigo-600 font-semibold">Clique ou arraste seu arquivo</span>
        <input type="file" id="fileInput" accept=".xlsx,.xls" class="hidden"/>
      </label>
    </div>
  </div>

  <!-- Etapa 2: Seleﾃｧﾃ｣o de Colunas (Versﾃ｣o Simplificada) -->
  <div id="step2" class="hidden flex-1 flex flex-col items-center justify-center p-6 min-h-screen">
      <div class="bg-white rounded-2xl shadow-lg p-8 w-full max-w-md dark:bg-gray-800">
          <h2 class="text-xl font-bold text-indigo-600 mb-2 dark:text-white"><i class="fas fa-list-check mr-2"></i>Informaﾃｧﾃｵes Adicionais</h2>
          <p class="text-gray-500 mb-6 text-sm dark:text-white">Escolha os campos que deseja visualizar nos detalhes da entrega.</p>
          
          <div id="columnsList" class="space-y-3 mb-6 max-h-60 overflow-y-auto p-4 bg-gray-50 rounded-lg dark:bg-gray-800">
              <!-- As checkboxes serﾃ｣o populadas via JavaScript -->
          </div>

          <button id="confirmColumnsBtn" class="w-full bg-indigo-600 text-white py-3 rounded-lg font-semibold hover:bg-indigo-700 transition">
              <i class="fas fa-check mr-2"></i>Confirmar e Otimizar
          </button>
      </div>
  </div>

  <!-- Etapa 3: Mapa -->
  <div id="step3" class="hidden">
    <div id="map"></div>
    <div id="nextStopBar" class="hidden dark:bg-gray-800 dark:text-white fixed bottom-0 left-0 right-0 bg-white shadow-[0_-5px_20px_rgba(0,0,0,0.1)] rounded-t-2xl z-[1001] p-4">
        <div class="w-full max-w-4xl mx-auto">
            <div class="flex justify-between items-start mb-3 dark:text-white">
            <div id="nextStopInfo" class="text-gray-800 mr-4"></div>
            </div>
            <!-- MODIFICAﾃﾃグ: grid-cols-3 para grid-cols-4 e adiﾃｧﾃ｣o do botﾃ｣o Pendente -->
            <div class="grid grid-cols-4 gap-2">
                <button onclick="openNavigation()" class="col-span-1 bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center text-xs"><i class="fas fa-diamond-turn-right mr-2"></i>Navegar</button>
                
                <button id="entregueBtn" onclick="markNext('entregue')" class="col-span-1 bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-3 px-4 rounded-lg flex items-center justify-center text-xs">
                    <i class="fas fa-check-double mr-2 text-green-500"></i>
                    <span id="entregueText">Entregue</span>
                </button>

                <button id="naoEntregueBtn" onclick="markNext('naoentregue')" class="col-span-1 bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-3 px-4 rounded-lg flex items-center justify-center text-xs">
                    <i class="fas fa-box mr-2 text-red-500"></i>
                    <span id="naoEntregueText">Nﾃ｣o Entregue</span>
                </button>
                
                <button onclick="markNext('pendente')" class="col-span-1 bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-3 px-4 rounded-lg flex items-center justify-center text-xs">
                    <i class="fas fa-clock mr-2 text-yellow-500"></i>
                    <span id="pendenteText">Pendente</span>
                </button>
            </div>
        </div>
    </div>

  </div>

<script>
// =================================================================================
// VARIﾃ〃EIS GLOBAIS
// =================================================================================
let deliveryData = [], userLocation = null, map, markers = [], routeLayer, nextDeliveryRouteLayer, userMarker;
let selectedColumns = [];
let startPoint = null;
let endPoint = null;
let isRouteOptimized = false;
let markerClusterGroup;
let mapTileLayer;

const iconMapping = {
  'cliente': 'fa-user',
  'telefone': 'fa-phone',
  'stop': 'fa-hashtag',
  'sequence': 'fa-list-ol',
  'tn': 'fa-barcode',
  'cod': 'fa-barcode',
  'cep': 'fa-street-view',
  'Zipcode/Postal code': 'fa-street-view',
  'Postal': 'fa-street-view',
  'observaﾃｧﾃ｣o': 'fa-comment-dots',
  'obs': 'fa-comment-dots',
  'default': 'fa-info-circle'
};

// =================================================================================
// INICIALIZAﾃﾃグ E GERENCIAMENTO DE ESTADO
// =================================================================================
window.addEventListener('load', () => {
  loadSavedState();
  initGeolocation();
});

function saveState() {
  try {
    const stateToSave = {
      deliveryData: deliveryData,
      selectedColumns: selectedColumns,
      startPoint: startPoint,
      endPoint: endPoint,
      currentStep: getCurrentStep(),
      isRouteOptimized: isRouteOptimized // <-- ADICIONAR ESTA LINHA
    };
    localStorage.setItem('routeOptimizerState', JSON.stringify(stateToSave));
  } catch (e) { console.error('Erro ao salvar estado:', e); }
}

async function loadSavedState() { // <-- TORNAR A FUNﾃﾃグ ASYNC
  const savedState = localStorage.getItem('routeOptimizerState');
  if (!savedState) return;
  try {
    const state = JSON.parse(savedState);
    if (state.currentStep === 'step3' && state.deliveryData?.length > 0) {
      deliveryData = state.deliveryData;
      selectedColumns = state.selectedColumns || [];
      startPoint = state.startPoint;
      endPoint = state.endPoint;
      isRouteOptimized = state.isRouteOptimized || false; // <-- RESTAURAR O ESTADO DE OTIMIZAﾃﾃグ

      document.getElementById('step1').classList.add('hidden');
      document.getElementById('step3').classList.remove('hidden');
      
      showMapControls(true);
      await initGeolocation(); // Espera a geolocalizaﾃｧﾃ｣o para ter o userLocation
      initMap();

      // --- SOLUﾃﾃグ: DESENHA A ROTA COMPLETA AO RECARREGAR ---
      if (isRouteOptimized) {
        if (routeLayer) map.removeLayer(routeLayer);
        const allPoints = deliveryData.map(d => ({ lat: +d.Latitude, lng: +d.Longitude }));
        if (userLocation) allPoints.unshift(userLocation); // Adiciona a localizaﾃｧﾃ｣o atual ao traﾃｧado
        
        routeLayer = await drawRoute(allPoints, { style: { color: "#5e33ea", weight: 5, opacity: 0.7 } });
        if (routeLayer) {
          routeLayer.addTo(map);
          // Ajusta o zoom para a rota completa
          setTimeout(() => map.fitBounds(routeLayer.getBounds(), { padding: [50, 50] }), 500);
        }
      }
      // --- FIM DA SOLUﾃﾃグ ---

      updateUI();
      startTracking();
      showToast('Rota anterior restaurada!', 'success');
    }
  } catch (e) {
    console.error('Erro ao carregar estado:', e);
    clearState();
  }
}

function clearState() {
  localStorage.removeItem('routeOptimizerState');
  window.location.reload();
}

function getCurrentStep() {
  if (!document.getElementById('step1').classList.contains('hidden')) return 'step1';
  if (!document.getElementById('step2').classList.contains('hidden')) return 'step2';
  if (!document.getElementById('step3').classList.contains('hidden')) return 'step3';
  return null;
}

// =================================================================================
// UPLOAD DE ARQUIVO E PREPARAﾃﾃグ
// =================================================================================
document.getElementById('fileInput').addEventListener('change', handleFileUpload);

async function handleFileUpload(e) {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = async (event) => { // <-- Tornar a funﾃｧﾃ｣o async
    try {
      const data = new Uint8Array(event.target.result);
      const workbook = XLSX.read(data, { type: 'array' });
      const sheetName = workbook.SheetNames[0];
      const worksheet = workbook.Sheets[sheetName];
      const jsonData = XLSX.utils.sheet_to_json(worksheet);

      if (jsonData.length === 0) return showToast('Arquivo vazio ou formato invﾃ｡lido', 'error');

      const headers = Object.keys(jsonData[0]);
      const findHeader = (keys) => headers.find(h => keys.some(key => h.toLowerCase().includes(key)));

      let latHeader = findHeader(['lat', 'latitude']);
      let lngHeader = findHeader(['lon', 'lng', 'longitude']);
      const addressHeader = findHeader(['address', 'endereﾃｧo', 'rua']);
      const districtHeader = findHeader(['bairro']);
      const cityHeader = findHeader(['cidade']);

      // Se nﾃ｣o houver lat/lng, mas houver endereﾃｧo, prepara para geocodificaﾃｧﾃ｣o
      if ((!latHeader || !lngHeader) && addressHeader) {
        showProgressModal('Iniciando geocodificaﾃｧﾃ｣o...', 0);
        await delay(50);

        for (let i = 0; i < jsonData.length; i++) {
          const row = jsonData[i];
          const fullAddress = [row[addressHeader], row[districtHeader], row[cityHeader]].filter(Boolean).join(', ');
          
          const progress = ((i + 1) / jsonData.length) * 100;
          showProgressModal(`Buscando coordenadas para: ${fullAddress}`, progress);
          
          const coords = await geocodeAddress(fullAddress);
          if (coords) {
            row.Latitude = coords.lat;
            row.Longitude = coords.lng;
          } else {
            row.Latitude = null;
            row.Longitude = null;
            console.warn(`Geocodificaﾃｧﾃ｣o falhou para: ${fullAddress}`);
          }
          await delay(200); // Delay para nﾃ｣o sobrecarregar a API de geocodificaﾃｧﾃ｣o
        }
        
        hideProgressModal();
        // Define os novos headers de lat/lng
        latHeader = 'Latitude';
        lngHeader = 'Longitude';
      }

      // Validaﾃｧﾃ｣o final
      if (!latHeader || !lngHeader) {
        return showToast('Erro: Nﾃ｣o foi possﾃｭvel determinar a Latitude e Longitude das entregas.', 'error');
      }

      // Processa os dados finais
      deliveryData = jsonData
        .filter(row => row[latHeader] && row[lngHeader]) // Filtra entregas que nﾃ｣o puderam ser geocodificadas
        .map((row, index) => ({
          ...row,
          Latitude: row[latHeader],
          Longitude: row[lngHeader],
          Endereﾃｧo: addressHeader ? row[addressHeader] : 'Endereﾃｧo nﾃ｣o fornecido',
          STOP: findHeader(['stop']) ? row[findHeader(['stop'])] : index + 1,
          id: index,
          status: "pendente",
        }));

      if(deliveryData.length === 0) {
        return showToast('Nenhuma entrega pﾃｴde ser localizada. Verifique os endereﾃｧos.', 'error');
      }

      // Prepara a lista de colunas para seleﾃｧﾃ｣o
      const processedHeaders = [latHeader, lngHeader, addressHeader].filter(Boolean);
      const cols = headers.filter(h => !processedHeaders.includes(h));
      
      const container = document.getElementById("columnsList");
      container.innerHTML = cols.map(c => `
        <label class="flex items-center space-x-3 cursor-pointer hover:bg-gray-50 dark:hover:bg-indigo-600 p-2 rounded-lg">
          <input type="checkbox" value="${c}" class="columnChk h-5 w-5 text-indigo-600 border-gray-300 rounded" ${['cliente', 'telefone', 'obs', 'stop', 'sequence'].some(kw => c.toLowerCase().includes(kw)) ? 'checked' : ''}/>
          <span class="text-gray-700 dark:text-white">${c}</span>
        </label>`).join('');

      document.getElementById('step1').classList.add('hidden');
      document.getElementById('step2').classList.remove('hidden');
      showToast(`${deliveryData.length} entregas carregadas e localizadas!`, 'success');

    } catch (error) {
      console.error('Erro ao processar arquivo:', error);
      showToast('Erro fatal ao processar o arquivo.', 'error');
      hideProgressModal();
    }
  };
  reader.readAsArrayBuffer(file);
}

// Substitua o listener do 'confirmMappingBtn' por este
document.getElementById('confirmColumnsBtn')?.addEventListener('click', () => {
  selectedColumns = [...document.querySelectorAll(".columnChk:checked")].map(c => c.value);
  document.getElementById('step2').classList.add('hidden');
  document.getElementById('step3').classList.remove('hidden');
  
  showMapControls(true);
  initMap();
  optimizeRoute();
});

// =================================================================================
// GEOLOCALIZAﾃﾃグ E GEOCODIFICAﾃﾃグ (Nominatim/OSM)
// =================================================================================
function initGeolocation() {
  return new Promise((resolve) => {
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        pos => { 
          userLocation = { lat: pos.coords.latitude, lng: pos.coords.longitude };
          resolve();
        },
        () => { 
            userLocation = { lat: -3.73186, lng: -38.5267 }; // Fallback
            showToast('Usando localizaﾃｧﾃ｣o padrﾃ｣o. Permita o acesso para maior precisﾃ｣o.', 'warn');
            resolve();
        }
      );
    } else {
      userLocation = { lat: -3.73186, lng: -38.5267 }; // Fallback
      showToast('Geolocalizaﾃｧﾃ｣o nﾃ｣o suportada por este navegador.', 'error');
      resolve();
    }
  });
}

async function geocodeAddress(address) {
  if (!address) return null;
  try {
    const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address )}&countrycodes=br&limit=1`);
    const data = await response.json();
    if (data && data.length > 0) {
      return { lat: parseFloat(data[0].lat), lng: parseFloat(data[0].lon), address: data[0].display_name };
    }
    return null;
  } catch (error) {
    console.error('Erro na geocodificaﾃｧﾃ｣o:', error);
    return null;
  }
}

// =================================================================================
// OTIMIZAﾃﾃグ Rﾃ￣IDA E INTELIGENTE (Hﾃ坑RIDA)
// =================================================================================

// Cache otimizado para distﾃ｢ncias
let fastDistanceCache = new Map();

// Funﾃｧﾃ｣o rﾃ｡pida que usa haversine primeiro e OSRM apenas quando necessﾃ｡rio
async function getSmartDistance(point1, point2, useRealRoute = false) {
    const key = `${point1.lat.toFixed(6)},${point1.lng.toFixed(6)}-${point2.lat.toFixed(6)},${point2.lng.toFixed(6)}`;
    
    if (fastDistanceCache.has(key)) {
        return fastDistanceCache.get(key);
    }
    
    let distance;
    
    if (useRealRoute) {
        // Usa OSRM apenas quando solicitado
        try {
            const coords = `${point1.lng},${point1.lat};${point2.lng},${point2.lat}`;
            const url = `https://router.project-osrm.org/route/v1/driving/${coords}?overview=false`;
            const response = await fetch(url);
            
            if (response.ok) {
                const data = await response.json();
                if (data.routes && data.routes.length > 0) {
                    distance = data.routes[0].distance / 1000;
                } else {
                    distance = haversine(point1, point2);
                }
            } else {
                distance = haversine(point1, point2);
            }
        } catch (error) {
            distance = haversine(point1, point2);
        }
    } else {
        // Usa haversine (muito mais rﾃ｡pido)
        distance = haversine(point1, point2);
    }
    
    fastDistanceCache.set(key, distance);
    return distance;
}

// Algoritmo de otimizaﾃｧﾃ｣o rﾃ｡pido e inteligente
async function fastOptimizeRoute(route, startPoint) {
    const totalStops = route.length;
    
    // FASE 1: Rota inicial rﾃ｡pida usando haversine
    showProgressModal('Criando rota inicial rﾃ｡pida...', 10);
    await delay(20);
    
    let optimizedRoute = [];
    let remaining = [...route];
    let currentPoint = startPoint;
    
    // Algoritmo guloso rﾃ｡pido
    while (remaining.length > 0) {
        let nearestIndex = 0;
        let minDistance = Infinity;
        
        for (let i = 0; i < remaining.length; i++) {
            const distance = await getSmartDistance(currentPoint, {
                lat: remaining[i].Latitude,
                lng: remaining[i].Longitude
            }, false); // Usa haversine (rﾃ｡pido)
            
            if (distance < minDistance) {
                minDistance = distance;
                nearestIndex = i;
            }
        }
        
        const nextStop = remaining.splice(nearestIndex, 1)[0];
        optimizedRoute.push(nextStop);
        currentPoint = { lat: nextStop.Latitude, lng: nextStop.Longitude };
        
        const progress = 10 + ((totalStops - remaining.length) / totalStops) * 40;
        showProgressModal(`Rota inicial: ${totalStops - remaining.length}/${totalStops}`, progress);
        await delay(5);
    }
    
    // FASE 2: Refinamento 2-opt rﾃ｡pido (apenas algumas iteraﾃｧﾃｵes)
    showProgressModal('Refinando rota...', 50);
    await delay(20);
    
    let improved = true;
    let iterations = 0;
    const maxIterations = Math.min(10, Math.floor(totalStops / 8)); // Limita iteraﾃｧﾃｵes
    
    while (improved && iterations < maxIterations) {
        improved = false;
        
        // Testa apenas algumas trocas por iteraﾃｧﾃ｣o para ser mais rﾃ｡pido
        const step = Math.max(1, Math.floor(optimizedRoute.length / 20));
        
        for (let i = 0; i < optimizedRoute.length - 1; i += step) {
            for (let j = i + step; j < optimizedRoute.length; j += step) {
                const current_i = i;
                const next_i = (i + 1) % optimizedRoute.length;
                const current_j = j;
                const next_j = (j + 1) % optimizedRoute.length;
                
                const currentDistance = 
                    await getSmartDistance({lat: optimizedRoute[current_i].Latitude, lng: optimizedRoute[current_i].Longitude}, 
                                         {lat: optimizedRoute[next_i].Latitude, lng: optimizedRoute[next_i].Longitude}, false) +
                    await getSmartDistance({lat: optimizedRoute[current_j].Latitude, lng: optimizedRoute[current_j].Longitude}, 
                                         {lat: optimizedRoute[next_j].Latitude, lng: optimizedRoute[next_j].Longitude}, false);
                
                const newDistance = 
                    await getSmartDistance({lat: optimizedRoute[current_i].Latitude, lng: optimizedRoute[current_i].Longitude}, 
                                         {lat: optimizedRoute[current_j].Latitude, lng: optimizedRoute[current_j].Longitude}, false) +
                    await getSmartDistance({lat: optimizedRoute[next_i].Latitude, lng: optimizedRoute[next_i].Longitude}, 
                                         {lat: optimizedRoute[next_j].Latitude, lng: optimizedRoute[next_j].Longitude}, false);
                
                if (newDistance < currentDistance) {
                    optimizedRoute = twoOptSwap(optimizedRoute, i + 1, j);
                    improved = true;
                }
            }
        }
        
        iterations++;
        const progress = 50 + (iterations / maxIterations) * 40;
        showProgressModal(`Refinando... (${iterations}/${maxIterations})`, progress);
        await delay(10);
    }
    
    return optimizedRoute;
}

// =================================================================================
// OTIMIZAﾃﾃグ MELHORADA - SUBSTITUA AS FUNﾃﾃ髭S EXISTENTES
// =================================================================================

const delay = ms => new Promise(res => setTimeout(res, ms));

// Algoritmo especﾃｭfico para circuito (TSP - Traveling Salesman Problem)
async function optimizeCircuitRoute(route, startPoint) {
  const totalStops = route.length;
  
  if (totalStops <= 2) return route;
  
  showProgressModal('Otimizando circuito completo...', 5);
  await delay(50);
  
  // 1. Encontrar a primeira parada (mais prﾃｳxima do inﾃｭcio)
  let firstStopIndex = 0;
  let minDistanceToStart = Infinity;
  
  for (let i = 0; i < route.length; i++) {
    const distance = getDistance(startPoint, {
      lat: route[i].Latitude,
      lng: route[i].Longitude
    });
    if (distance < minDistanceToStart) {
      minDistanceToStart = distance;
      firstStopIndex = i;
    }
  }
  
  const firstStop = route[firstStopIndex];
  let remainingStops = route.filter((_, index) => index !== firstStopIndex);
  
  showProgressModal('Primeira parada definida...', 15);
  await delay(50);
  
  // 2. Construir o circuito usando algoritmo de inserﾃｧﾃ｣o mais prﾃｳxima
  let circuitRoute = [firstStop];
  
  while (remainingStops.length > 0) {
    let bestInsertPosition = -1;
    let bestStopIndex = -1;
    let minIncreaseDistance = Infinity;
    
    // Para cada parada restante
    for (let stopIndex = 0; stopIndex < remainingStops.length; stopIndex++) {
      const candidateStop = remainingStops[stopIndex];
      
      // Testa inserir em cada posiﾃｧﾃ｣o possﾃｭvel do circuito
      for (let insertPos = 0; insertPos <= circuitRoute.length; insertPos++) {
        const increasedDistance = calculateInsertionCost(
          circuitRoute, candidateStop, insertPos, startPoint
        );
        
        if (increasedDistance < minIncreaseDistance) {
          minIncreaseDistance = increasedDistance;
          bestInsertPosition = insertPos;
          bestStopIndex = stopIndex;
        }
      }
    }
    
    // Insere a melhor parada na melhor posiﾃｧﾃ｣o
    const bestStop = remainingStops.splice(bestStopIndex, 1)[0];
    circuitRoute.splice(bestInsertPosition, 0, bestStop);
    
    const progress = 15 + ((totalStops - remainingStops.length) / totalStops) * 60;
    showProgressModal(`Construindo circuito: ${totalStops - remainingStops.length}/${totalStops}`, progress);
    await delay(30);
  }
  
  showProgressModal('Otimizando circuito com 2-Opt...', 75);
  await delay(50);
  
  // 3. Refinamento com 2-Opt especﾃｭfico para circuito
  circuitRoute = await circuitTwoOpt(circuitRoute, startPoint);
  
  showProgressModal('Verificando ﾃｺltima parada...', 90);
  await delay(50);
  
  // 4. Otimizaﾃｧﾃ｣o final: garantir que a ﾃｺltima parada seja ﾃｳtima para retorno
  circuitRoute = optimizeLastStop(circuitRoute, startPoint);
  
  return circuitRoute;
}

// Calcula o custo de inserir uma parada em uma posiﾃｧﾃ｣o especﾃｭfica do circuito
function calculateInsertionCost(currentRoute, newStop, insertPosition, startPoint) {
  const newStopPoint = { lat: newStop.Latitude, lng: newStop.Longitude };
  
  if (currentRoute.length === 0) {
    // Primeira inserﾃｧﾃ｣o: custo ﾃｩ ida + volta
    return 2 * getDistance(startPoint, newStopPoint);
  }
  
  if (insertPosition === 0) {
    // Inserﾃｧﾃ｣o no inﾃｭcio
    const nextPoint = { lat: currentRoute[0].Latitude, lng: currentRoute[0].Longitude };
    const oldCost = getDistance(startPoint, nextPoint);
    const newCost = getDistance(startPoint, newStopPoint) + getDistance(newStopPoint, nextPoint);
    return newCost - oldCost;
  }
  
  if (insertPosition === currentRoute.length) {
    // Inserﾃｧﾃ｣o no final
    const prevPoint = { lat: currentRoute[currentRoute.length - 1].Latitude, lng: currentRoute[currentRoute.length - 1].Longitude };
    const oldCost = getDistance(prevPoint, startPoint);
    const newCost = getDistance(prevPoint, newStopPoint) + getDistance(newStopPoint, startPoint);
    return newCost - oldCost;
  }
  
  // Inserﾃｧﾃ｣o no meio
  const prevPoint = { lat: currentRoute[insertPosition - 1].Latitude, lng: currentRoute[insertPosition - 1].Longitude };
  const nextPoint = { lat: currentRoute[insertPosition].Latitude, lng: currentRoute[insertPosition].Longitude };
  
  const oldCost = getDistance(prevPoint, nextPoint);
  const newCost = getDistance(prevPoint, newStopPoint) + getDistance(newStopPoint, nextPoint);
  
  return newCost - oldCost;
}

// 2-Opt especﾃｭfico para circuito (considera retorno ao inﾃｭcio)
async function circuitTwoOpt(route, startPoint) {
  let bestRoute = [...route];
  let bestDistance = calculateCircuitDistance(bestRoute, startPoint);
  let improved = true;
  let iterations = 0;
  const maxIterations = Math.min(100, route.length * 3);
  
  while (improved && iterations < maxIterations) {
    improved = false;
    
    for (let i = 0; i < bestRoute.length - 1; i++) {
      for (let j = i + 2; j < bestRoute.length; j++) {
        // Aplica 2-opt swap
        const newRoute = twoOptSwap(bestRoute, i, j);
        const newDistance = calculateCircuitDistance(newRoute, startPoint);
        
        if (newDistance < bestDistance) {
          bestRoute = newRoute;
          bestDistance = newDistance;
          improved = true;
        }
      }
      
      if (i % 5 === 0) await delay(10);
    }
    
    iterations++;
    
    if (iterations % 10 === 0) {
      const progress = 75 + (iterations / maxIterations) * 15;
      showProgressModal(`2-Opt circuito: iteraﾃｧﾃ｣o ${iterations}`, progress);
      await delay(20);
    }
  }
  
  return bestRoute;
}

// Calcula distﾃ｢ncia total do circuito (inclui retorno ao inﾃｭcio)
function calculateCircuitDistance(route, startPoint) {
  if (route.length === 0) return 0;
  if (route.length === 1) {
    const stopPoint = { lat: route[0].Latitude, lng: route[0].Longitude };
    return 2 * getDistance(startPoint, stopPoint);
  }
  
  let totalDistance = 0;
  
  // Distﾃ｢ncia do inﾃｭcio para primeira parada
  const firstStop = { lat: route[0].Latitude, lng: route[0].Longitude };
  totalDistance += getDistance(startPoint, firstStop);
  
  // Distﾃ｢ncias entre paradas consecutivas
  for (let i = 0; i < route.length - 1; i++) {
    const currentStop = { lat: route[i].Latitude, lng: route[i].Longitude };
    const nextStop = { lat: route[i + 1].Latitude, lng: route[i + 1].Longitude };
    totalDistance += getDistance(currentStop, nextStop);
  }
  
  // Distﾃ｢ncia da ﾃｺltima parada de volta ao inﾃｭcio
  const lastStop = { lat: route[route.length - 1].Latitude, lng: route[route.length - 1].Longitude };
  totalDistance += getDistance(lastStop, startPoint);
  
  return totalDistance;
}

// Otimiza especificamente a ﾃｺltima parada para minimizar retorno
function optimizeLastStop(route, startPoint) {
  if (route.length < 3) return route;
  
  // Considera os ﾃｺltimos 30% das paradas como candidatas a ﾃｺltima
  const candidateCount = Math.max(2, Math.ceil(route.length * 0.3));
  const candidates = route.slice(-candidateCount);
  
  let bestLastIndex = -1;
  let minReturnDistance = Infinity;
  
  candidates.forEach((candidate, index) => {
    const candidatePoint = { lat: candidate.Latitude, lng: candidate.Longitude };
    const distanceToStart = getDistance(candidatePoint, startPoint);
    
    if (distanceToStart < minReturnDistance) {
      minReturnDistance = distanceToStart;
      bestLastIndex = route.length - candidateCount + index;
    }
  });
  
  // Se encontrou uma ﾃｺltima parada melhor, reordena
  if (bestLastIndex !== route.length - 1) {
    const bestLastStop = route[bestLastIndex];
    const newRoute = route.filter((_, index) => index !== bestLastIndex);
    newRoute.push(bestLastStop);
    return newRoute;
  }
  
  return route;
}

// Algoritmo simples para nearest neighbor sem circuito
async function simpleNearestNeighborRoute(route, startPoint) {
  let optimizedRoute = [];
  let remaining = [...route];
  let currentPoint = startPoint;
  
  while (remaining.length > 0) {
    let nearestIndex = 0;
    let minDistance = Infinity;
    
    for (let i = 0; i < remaining.length; i++) {
      const distance = getDistance(currentPoint, {
        lat: remaining[i].Latitude,
        lng: remaining[i].Longitude
      });
      
      if (distance < minDistance) {
        minDistance = distance;
        nearestIndex = i;
      }
    }
    
    const nextStop = remaining.splice(nearestIndex, 1)[0];
    optimizedRoute.push(nextStop);
    currentPoint = { lat: nextStop.Latitude, lng: nextStop.Longitude };
    
    await delay(10);
  }
  
  return optimizedRoute;
}

// FUNﾃﾃグ PRINCIPAL ATUALIZADA - SUBSTITUA A optimizeRoute EXISTENTE
async function optimizeRoute() {
  if (deliveryData.length < 3) {
    return showToast('Sﾃ｣o necessﾃ｡rias pelo menos 3 paradas para otimizar.', 'warn');
  }

  const optimizeBtn = document.getElementById('reOptimizeBtn');
  if (optimizeBtn) {
    optimizeBtn.disabled = true;
    optimizeBtn.classList.add('opacity-50', 'cursor-not-allowed');
  }

  await delay(50);

  let startPoint = userLocation;
  if (!startPoint) {
    startPoint = { lat: deliveryData[0].Latitude, lng: deliveryData[0].Longitude };
    showToast('Localizaﾃｧﾃ｣o nﾃ｣o encontrada. Iniciando da primeira entrega.', 'warn');
  }

  // Reseta status
  deliveryData.forEach(d => d.status = "pendente");

  try {
    // Verifica se deve fazer circuito completo
    const useReturnToStart = localStorage.getItem('useReturnToStart') === 'true';
    
    let optimizedRoute;
    
    if (useReturnToStart) {
      showProgressModal('Otimizando circuito completo (ida e volta)...', 0);
      optimizedRoute = await optimizeCircuitRoute(deliveryData, startPoint);
      
      const circuitDistance = calculateCircuitDistance(optimizedRoute, startPoint);
      showToast(`Circuito otimizado! ${optimizedRoute.length} paradas, distﾃ｢ncia total: ${circuitDistance.toFixed(1)}km (ida e volta)`, 'success');
    } else {
      showProgressModal('Otimizando rota simples (apenas ida)...', 0);
      optimizedRoute = await simpleNearestNeighborRoute(deliveryData, startPoint);
      
      const simpleDistance = calculateSimpleRouteDistance(optimizedRoute, startPoint);
      showToast(`Rota otimizada! ${optimizedRoute.length} paradas, distﾃ｢ncia total: ${simpleDistance.toFixed(1)}km`, 'success');
    }

    // Finalizaﾃｧﾃ｣o
    deliveryData = optimizedRoute.map((d, i) => ({ ...d, Sequence: i + 1 }));
    isRouteOptimized = true;

    hideProgressModal();

  } catch (error) {
    console.error('Erro na otimizaﾃｧﾃ｣o:', error);
    showToast('Erro na otimizaﾃｧﾃ｣o. Usando algoritmo simples...', 'error');
    
    // Fallback
    let fallbackRoute = await simpleNearestNeighborRoute(deliveryData, startPoint);
    deliveryData = fallbackRoute.map((d, i) => ({ ...d, Sequence: i + 1 }));
    isRouteOptimized = true;
    hideProgressModal();
  }

  if (optimizeBtn) {
    optimizeBtn.disabled = false;
    optimizeBtn.classList.remove('opacity-50', 'cursor-not-allowed');
  }

  saveState();
  updateUI();
  startTracking();

  setTimeout(() => {
    if (routeLayer && map) {
      map.fitBounds(routeLayer.getBounds(), { padding: [50, 50] });
    }
  }, 1000);
}

// Funﾃｧﾃ｣o auxiliar para calcular distﾃ｢ncia de rota simples
function calculateSimpleRouteDistance(route, startPoint) {
  if (route.length === 0) return 0;
  
  let totalDistance = 0;
  let currentPoint = startPoint;
  
  for (const stop of route) {
    const stopPoint = { lat: stop.Latitude, lng: stop.Longitude };
    totalDistance += getDistance(currentPoint, stopPoint);
    currentPoint = stopPoint;
  }
  
  return totalDistance;
}

// Funﾃｧﾃ｣o que implementa o algoritmo 2-Opt
async function apply2Opt(route) {
    let bestRoute = [...route];
    let improved = true;
    let iteration = 0;

    while (improved) {
        improved = false;
        for (let i = 0; i < bestRoute.length - 1; i++) {
            for (let j = i + 1; j < bestRoute.length; j++) {
                // Calcula a distﾃ｢ncia da rota atual e da rota com a troca
                const currentDistance = calculateDistance(bestRoute[i], bestRoute[(i + 1) % bestRoute.length]) + calculateDistance(bestRoute[j], bestRoute[(j + 1) % bestRoute.length]);
                const newDistance = calculateDistance(bestRoute[i], bestRoute[j]) + calculateDistance(bestRoute[(i + 1) % bestRoute.length], bestRoute[(j + 1) % bestRoute.length]);

                if (newDistance < currentDistance) {
                    // Se a troca melhora a rota, realiza o "swap"
                    bestRoute = twoOptSwap(bestRoute, i + 1, j);
                    improved = true;
                }
            }
        }
        iteration++;
        if (iteration % 5 === 0) { // Atualiza a UI a cada 5 iteraﾃｧﾃｵes para nﾃ｣o sobrecarregar
            showProgressModal(`Refinando... (Iteraﾃｧﾃ｣o ${iteration})`, 25 + (iteration % 70));
            await delay(1);
        }
    }
    return bestRoute;
}

// Funﾃｧﾃ｣o que orienta a rota para comeﾃｧar no ponto mais prﾃｳximo do inﾃｭcio
function orientRoute(route, startPoint) {
    let bestStartIndex = 0;
    let minDistance = Infinity;

    route.forEach((stop, index) => {
        const dist = haversine(startPoint, { lat: stop.Latitude, lng: stop.Longitude });
        if (dist < minDistance) {
            minDistance = dist;
            bestStartIndex = index;
        }
    });

    // Gira o array para que a rota comece no ponto mais prﾃｳximo
    return [...route.slice(bestStartIndex), ...route.slice(0, bestStartIndex)];
}

// Funﾃｧﾃ｣o auxiliar que realiza a troca (inverte um segmento da rota)
function twoOptSwap(route, i, k) {
    const part1 = route.slice(0, i);
    const part2 = route.slice(i, k + 1).reverse();
    const part3 = route.slice(k + 1);
    return [...part1, ...part2, ...part3];
}

// Funﾃｧﾃ｣o auxiliar para calcular a distﾃ｢ncia (usa a haversine)
function calculateDistance(stop1, stop2) {
    if (!stop1 || !stop2) return 0;
    return haversine({ lat: stop1.Latitude, lng: stop1.Longitude }, { lat: stop2.Latitude, lng: stop2.Longitude });
}

async function reOptimizeFromCurrentLocation() {
  showToast('Reotimizando a rota...', 'info');
  await optimizeRoute(); // 隼 usa exatamente a mesma lﾃｳgica da otimizaﾃｧﾃ｣o inicial
}

// Funﾃｧﾃ｣o para desenhar a rota no mapa
async function drawRoute(points, options) {
  if (points.length < 2) return null;
  const coords = points.map(p => `${p.lng},${p.lat}`).join(';');
  const url = `https://router.project-osrm.org/route/v1/driving/${coords}?overview=full&geometries=geojson`;
  try {
    const res = await fetch(url );
    const data = await res.json();
    if (data.routes && data.routes.length) {
      return L.geoJSON(data.routes[0].geometry, { style: options.style });
    }
  } catch (error) { console.error('Erro ao desenhar rota OSRM:', error); }
  return null;
}


// =================================================================================
// ATUALIZAﾃﾃグ DA INTERFACE (UI)
// =================================================================================

function updateMapTheme() {
    if (!map) return;
    if (mapTileLayer) {
        map.removeLayer(mapTileLayer);
    }

    const theme = localStorage.getItem('mapTheme') || 'voyager';
    let url, attribution;

    switch (theme) {
        case 'dark_matter':
            url = 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png';
            attribution = '&copy; OpenStreetMap &copy; CARTO';
            break;
        case 'hybrid':
            url = 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png'; // Vocﾃｪ pode substituir por um tile de satﾃｩlite melhor
            attribution = '&copy; OpenStreetMap contributors';
            break;
        default: // 'voyager'
            url = 'https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png';
            attribution = '&copy; OpenStreetMap &copy; CARTO';
    }

    mapTileLayer = L.tileLayer(url, { attribution, maxZoom: 19 } );
    mapTileLayer.addTo(map);
}

// Modifique a funﾃｧﾃ｣o initMap para usar a nova funﾃｧﾃ｣o de tema
function initMap() {
  if (!map) {
    map = L.map('map', { zoomControl: false }).setView(userLocation || [-3.73, -38.52], 13);
    updateMapTheme(); // Usa a funﾃｧﾃ｣o de tema para inicializar
  }
}


function updateUI() {
  if (!map) initMap();
  updateMarkers();
  showNextStop();
  updateStats();
  updateRouteLines();
  updateSideList();
}

async function updateRouteLines() {
  await drawAllRoutes();
}

function updateMarkers() {
  if (!map) return;
  markers.forEach(m => m.remove());
  markers = [];
  const next = deliveryData.find(d => d.status === "pendente");

  deliveryData.forEach(d => {
    const isNext = next && d.id === next.id;
    const color = d.status === "entregue" ? "#28a745" : d.status === "naoentregue" ? "#dc3545" : isNext ? "#ff6b35" : "#007bff";
    const size = isNext ? 38 : 30;
    const zIndex = isNext ? 1000 : 500;

    const iconHtml = `<div style="background-color:${color}; color:white; border-radius:50%; width:${size}px; height:${size}px; display:flex; align-items:center; justify-content:center; font-size:14px; font-weight:bold; border: 2px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3);">${d.Sequence}</div>`;
    const marker = L.marker([+d.Latitude, +d.Longitude], {
      icon: L.divIcon({ className: '', html: iconHtml }),
      zIndexOffset: zIndex
    }).addTo(map);

    // --- SOLUﾃﾃグ: Lﾃ敵ICA DE ﾃ垢ONES PERSONALIZADOS PARA O POPUP ---
    const defaultColumns = ['Destination Address', 'Endereﾃｧo'];
    const endereco = d['Destination Address'] || d['Endereﾃｧo'] || 'Sem endereﾃｧo';

    const extraInfoHtml = selectedColumns
      .filter(col => !defaultColumns.includes(col) && d[col])
      .map(col => {
        // Reutiliza a mesma lﾃｳgica de mapeamento de ﾃｭcones
        const lowerCol = col.toLowerCase();
        let iconClass = iconMapping.default;

        for (const key in iconMapping) {
          if (lowerCol.includes(key)) {
            iconClass = iconMapping[key];
            break;
          }
        }
        // Retorna o HTML com o ﾃｭcone e o valor
        return `<div class="flex items-center mb-1"><i class="fas ${iconClass} w-5 text-center mr-2"></i><span>${d[col]}</span></div>`;
      })
      .join(''); // Junta as divs verticalmente

    let popupContent = `
      <div style="min-width: 200px; font-family: 'Inter', sans-serif;">
        <h2 class="popup-title dark:text-white text-lg"><b>Parada ${d.Sequence}</b></h2>
        <p class="popup-info dark:text-white text-xs">${endereco}</p>
        
        ${extraInfoHtml ? `
          <hr>
          <div class="popup-extra-info mt-2 dark:text-white">
            ${extraInfoHtml}
          </div>
        ` : ''}
        
        <hr>
        
        <div style="display: flex; justify-content: space-around; align-items: center; margin-top: 10px;">
          <button title="Entregue" onclick="changeStatus(${d.id}, 'entregue')" style="background: #10b981; color: white; border: none; border-radius: 50%; width: 36px; height: 36px; cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center;"><i class="fas fa-check"></i></button>
          <button title="Nﾃ｣o Entregue" onclick="changeStatus(${d.id}, 'naoentregue')" style="background: #ef4444; color: white; border: none; border-radius: 50%; width: 36px; height: 36px; cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center;"><i class="fas fa-times"></i></button>
          <button title="Pendente" onclick="changeStatus(${d.id}, 'pendente')" style="background: #f59e0b; color: white; border: none; border-radius: 50%; width: 36px; height: 36px; cursor: pointer; font-size: 16px; display: flex; align-items: center; justify-content: center;"><i class="fas fa-clock"></i></button>
        </div>
      </div>
    `;
    // --- FIM DA SOLUﾃﾃグ ---

    marker.bindPopup(popupContent, { className: 'dark-theme-popup' });
    markers.push(marker);
  });
}



function showNextStop() {
  const next = deliveryData.find(d => d.status === "pendente");
  const nextStopBar = document.getElementById('nextStopBar');
  
  if (!next) {
    nextStopBar.classList.add("hidden");
    const allDone = deliveryData.every(d => d.status !== 'pendente');
    if (allDone && deliveryData.length > 0) showToast("脂 Rota Concluﾃｭda!", 'success');
    return;
  }

  const entreguesCount = deliveryData.filter(d => d.status === 'entregue').length;
  const naoEntreguesCount = deliveryData.filter(d => d.status === 'naoentregue').length;
  const pendentesCount = deliveryData.filter(d => d.status === 'pendente').length;
  const total = deliveryData.length;
  
  const endereco = next['Destination Address'] || next['Endereﾃｧo'] || 'Endereﾃｧo nﾃ｣o disponﾃｭvel';

  // --- SOLUﾃﾃグ: Lﾃ敵ICA DE ﾃ垢ONES PERSONALIZADOS INTEGRADA ---
  const defaultColumns = ['Destination Address', 'Endereﾃｧo'];
  
  const extraInfoHtml = selectedColumns
    .filter(col => !defaultColumns.includes(col) && next[col])
    .map(col => {
      // Procura por uma correspondﾃｪncia no mapeamento de ﾃｭcones
      const lowerCol = col.toLowerCase();
      let iconClass = iconMapping.default;

      for (const key in iconMapping) {
        if (lowerCol.includes(key)) {
          iconClass = iconMapping[key];
          break;
        }
      }
      
      // Retorna o HTML com o ﾃｭcone correto e o valor da coluna
      return `<span class="text-xs text-gray-500 dark:text-gray-300 flex items-center flex-shrink-0"><i class="fas ${iconClass} w-4 text-center mr-1"></i>${next[col]}</span>`;
    })
    .join(''); // Remove o separador " | " para usar o espaﾃｧamento do flexbox

  let infoHtml = `
    <div>
      <div class="flex justify-between items-center mb-1">
        <h3 class="text-lg font-bold text-gray-800 dark:text-white"><span class="text-sm font-light text-gray-600 dark:text-gray-300">${entreguesCount + naoEntreguesCount} / ${total} Concluﾃｭdas</span><br>Prﾃｳxima Parada: ${next.Sequence}</h3>
        
      </div>
      <p class="text-sm text-gray-600 mb-2 dark:text-gray-400">${endereco}</p>
      
      ${extraInfoHtml ? `
        <hr class="border-gray-200 dark:border-gray-600 my-2">
        <div class="flex items-center space-x-4 overflow-x-auto pb-1">
          ${extraInfoHtml}
        </div>
      ` : ''}
    </div>
  `;
  // --- FIM DA SOLUﾃﾃグ ---
  
  document.getElementById('nextStopInfo').innerHTML = infoHtml;

  document.getElementById('entregueText').textContent = `Entregue (${entreguesCount})`;
  document.getElementById('naoEntregueText').textContent = `Nﾃ｣o Entregue (${naoEntreguesCount})`;
  document.getElementById('pendenteText').textContent = `Pendente (${pendentesCount})`;

  nextStopBar.classList.remove("hidden");
}


function changeStatus(deliveryId, newStatus) {
  const delivery = deliveryData.find(d => d.id === deliveryId);
  if (delivery) {
    delivery.status = newStatus;
    const messages = {
      'entregue': { text: `笨 Pacote #${delivery.STOP} marcado como Entregue!`, type: 'success' },
      'naoentregue': { text: `笶 Pacote #${delivery.STOP} marcado como Nﾃ｣o Entregue`, type: 'warn' },
      'pendente': { text: `竢ｸｸ Pacote #${delivery.STOP} marcado como Pendente`, type: 'info' }
    };
    if (messages[newStatus]) {
        showToast(messages[newStatus].text, messages[newStatus].type);
    }
    saveState();
    updateUI(); // Essencial para redesenhar tudo, incluindo a rota
  }
}

// --- FUNﾃﾃグ markNext MODIFICADA ---
function markNext(status) {
  const next = deliveryData.find(d => d.status === "pendente");
  if (next) {
    // Reutiliza a nova funﾃｧﾃ｣o para manter a lﾃｳgica centralizada
    changeStatus(next.id, status);
  }
}

function updateStats() {
  const total = deliveryData.length;
  const entregues = deliveryData.filter(d => d.status === 'entregue').length;
  const naoEntregues = deliveryData.filter(d => d.status === 'naoentregue').length;
  const pendentes = total - entregues - naoEntregues;
  const progress = total > 0 ? Math.round(((entregues + naoEntregues) / total) * 100) : 0;
  
  document.getElementById('routeStats').innerHTML = `
    <div class="space-y-2">
      <div class="flex justify-between"><span>Total:</span><span class="font-semibold">${total}</span></div>
      <div class="flex justify-between text-green-600"><span>Entregues:</span><span class="font-semibold">${entregues}</span></div>
      <div class="flex justify-between text-red-600"><span>Nﾃ｣o Entregues:</span><span class="font-semibold">${naoEntregues}</span></div>
      <div class="flex justify-between text-yellow-600"><span>Pendentes:</span><span class="font-semibold">${pendentes}</span></div>
      <div class="mt-3 pt-2 border-t border-indigo-200">
        <div class="flex justify-between mb-1"><span class="text-sm font-medium">Progresso:</span><span class="text-sm font-semibold">${progress}%</span></div>
        <div class="w-full bg-gray-200 rounded-full h-2.5"><div class="bg-indigo-600 h-2.5 rounded-full" style="width: ${progress}%"></div></div>
      </div>
    </div>`;
}

function updateSideList() {
    document.getElementById('routeList').innerHTML = deliveryData.map(d => {
        const statusConfig = {
            entregue: { bg: 'bg-green-50 border-green-200', text: 'text-green-700', icon: 'fa-check-circle' },
            naoentregue: { bg: 'bg-red-50 border-red-200', text: 'text-red-700', icon: 'fa-times-circle' },
            pendente: { bg: 'bg-yellow-50 border-yellow-200', text: 'text-yellow-700', icon: 'fa-clock' }
        };
        const config = statusConfig[d.status] || statusConfig.pendente;
        
        // CORREﾃﾃグ: Procura por 'Destination Address' ou 'Endereﾃｧo'
        const endereco = d['Destination Address'] || d['Endereﾃｧo'] || 'Sem endereﾃｧo';

        return `
          <div class="p-3 rounded-lg mb-2 border ${config.bg} flex justify-between items-center">
            <div class="flex items-center space-x-3 overflow-hidden">
              <div class="w-10 h-10 bg-indigo-600 text-white rounded-full flex items-center justify-center text-base font-bold flex-shrink-0" title="Parada Otimizada ${d.Sequence}">
                ${d.Sequence}
              </div>
              <div>
                <span class="text-sm font-semibold text-gray-800 truncate block">Pacote: <em>#${d.STOP}</em></span>
                <span class="text-xs text-gray-500 truncate block">${endereco}</span>
              </div>
            </div>
            <div class="flex items-center space-x-2 flex-shrink-0">
              <i class="fas ${config.icon} ${config.text}"></i>
              <span class="${config.text} font-medium capitalize text-xs">${d.status.replace('naoentregue', 'nﾃ｣o entregue')}</span>
            </div>
          </div>`;
    }).join('');
}

// =================================================================================
// Aﾃﾃ髭S DO USUﾃヽIO E EVENTOS
// =================================================================================
function markNext(status) {
  const next = deliveryData.find(d => d.status === "pendente");
  if (next) {
    next.status = status;
    const messages = {
      'entregue': { text: '笨 Entrega Realizada!', type: 'success' },
      'naoentregue': { text: '笶 Entrega Nﾃ｣o Realizada', type: 'warn' }
    };
    if (messages[status]) {
        showToast(messages[status].text, messages[status].type);
    }
    saveState();
    updateUI();
  }
}

function openNavigation() {
    const next = deliveryData.find(d => d.status === "pendente");
    if (next) {
        const navApp = localStorage.getItem('navApp') || 'google';
        let url;

        if (navApp === 'waze') {
            url = `https://www.waze.com/ul?ll=${next.Latitude},${next.Longitude}&navigate=yes`;
        } else if (navApp === 'apple' ) {
            url = `http://maps.apple.com/?daddr=${next.Latitude},${next.Longitude}`;
        } else { // Padrﾃ｣o ﾃｩ Google Maps
            url = `https://www.google.com/maps/dir/?api=1&destination=${next.Latitude},${next.Longitude}`;
        }
        
        window.open(url, '_blank' );
    }
}


function startTracking() {
  if (!navigator.geolocation) return;
  const watchOptions = { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 };

  let lastVibrationTime = 0;

  navigator.geolocation.watchPosition(pos => {
    userLocation = { lat: pos.coords.latitude, lng: pos.coords.longitude };
    if (!userMarker) {
      const pulseIcon = L.divIcon({
        className: "",
        html: `<div class="relative"><div class="w-6 h-6 bg-blue-500 rounded-full border-4 border-white shadow-md"></div><div class="absolute inset-0 rounded-full bg-blue-400 opacity-50 animate-ping"></div></div>`
      });
      userMarker = L.marker([userLocation.lat, userLocation.lng], { icon: pulseIcon }).addTo(map).bindPopup("桃 Vocﾃｪ estﾃ｡ aqui");
    } else {
      userMarker.setLatLng([userLocation.lat, userLocation.lng]);
    }

    const nextDelivery = deliveryData.find(d => d.status === "pendente");
    if (nextDelivery) {
      const distanceToNext = haversine(userLocation, { lat: +nextDelivery.Latitude, lng: +nextDelivery.Longitude });
      const autoZoomEnabled = localStorage.getItem('autoZoom') !== 'false';
      if (autoZoomEnabled && distanceToNext < 0.5) {
        const bounds = L.latLngBounds([userLocation, { lat: +nextDelivery.Latitude, lng: +nextDelivery.Longitude }]);
        map.fitBounds(bounds, { padding: [80, 80], maxZoom: 17 });
      }
      if (distanceToNext < 0.5) {
        const bounds = L.latLngBounds([userLocation, { lat: +nextDelivery.Latitude, lng: +nextDelivery.Longitude }]);
        map.fitBounds(bounds, { padding: [80, 80], maxZoom: 17 });
      }
      const now = Date.now();
      if (distanceToNext < 0.1 && (now - lastVibrationTime > 30000)) {
        if (navigator.vibrate) {
          navigator.vibrate([200, 100, 200]);
          showToast(`Vocﾃｪ estﾃ｡ chegando na Parada ${nextDelivery.Sequence}!`, 'info');
          lastVibrationTime = now;
        }
      }
    }
  }, () => { showToast("Nﾃ｣o foi possﾃｭvel obter sua localizaﾃｧﾃ｣o em tempo real.", "error"); }, watchOptions);
}

// Funﾃｧﾃ｣o auxiliar que apenas busca os dados da rota
async function fetchRouteData(points) {
  if (points.length < 2) return null;
  const coords = points.map(p => `${p.lng},${p.lat}`).join(';');
  const url = `https://router.project-osrm.org/route/v1/driving/${coords}?overview=full&geometries=geojson`;
  try {
    const res = await fetch(url );
    if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
    return await res.json();
  } catch (error) {
    console.error('Erro ao buscar dados da rota OSRM:', error);
    showToast('Falha ao traﾃｧar a rota. Verifique a conexﾃ｣o.', 'error');
    return null;
  }
}

// NOVA FUNﾃﾃグ CENTRALIZADA PARA DESENHAR TODAS AS ROTAS
async function drawAllRoutes() {
  // Limpa as rotas antigas
  if (routeLayer) map.removeLayer(routeLayer);
  if (nextDeliveryRouteLayer) map.removeLayer(nextDeliveryRouteLayer);

  // 1. Desenha a Rota Completa (Azul)
  if (isRouteOptimized) {
    const allPoints = deliveryData.map(d => ({ lat: +d.Latitude, lng: +d.Longitude }));
    if (userLocation) allPoints.unshift(userLocation);
    
    const routeData = await fetchRouteData(allPoints);
    if (routeData && routeData.routes.length > 0) {
      routeLayer = L.geoJSON(routeData.routes[0].geometry, { style: { color: "#5e33ea", weight: 5, opacity: 0.7 } });
      routeLayer.addTo(map);
    }
  }

  // 2. Desenha a Rota para a Prﾃｳxima Entrega (Laranja)
  const nextDelivery = deliveryData.find(d => d.status === "pendente");
  if (nextDelivery && userLocation) {
    const nextPoints = [userLocation, { lat: +nextDelivery.Latitude, lng: +nextDelivery.Longitude }];
    const nextRouteData = await fetchRouteData(nextPoints);
    if (nextRouteData && nextRouteData.routes.length > 0) {
      nextDeliveryRouteLayer = L.geoJSON(nextRouteData.routes[0].geometry, { style: { color: "#ff6b35", weight: 7, opacity: 0.9, dashArray: '10, 5' } });
      nextDeliveryRouteLayer.addTo(map);
    }
  }
}

function showMapControls(show) {
    const visibility = show ? 'remove' : 'add';
    ["menuToggleBtn", "centerUserBtn", "reOptimizeBtn", "fullscreenBtn", "settingsBtn"].forEach(id => {
      document.getElementById(id).classList[visibility]("hidden");
    });
}

function toggleMenu(force = null) {
  const sideMenu = document.getElementById("sideMenu");
  const menuOverlay = document.getElementById("menuOverlay");
  // A linha 'optimizeInMenuBtn' foi removida
  const isOpen = !sideMenu.classList.contains("hidden");
  const shouldOpen = force !== null ? force : !isOpen;
  if (shouldOpen) {
    sideMenu.classList.remove("hidden");
    menuOverlay.classList.remove("hidden");
    setTimeout(() => sideMenu.classList.remove("-translate-x-full"), 10);
    // A linha 'optimizeInMenuBtn' foi removida
  } else {
    sideMenu.classList.add("-translate-x-full");
    menuOverlay.classList.add("hidden");
    setTimeout(() => sideMenu.classList.add("hidden"), 300);
  }
}

// =================================================================================
// FUNﾃﾃ髭S UTILITﾃヽIAS
// =================================================================================
function haversine(pos1, pos2) {
  const R = 6371; // Raio da Terra em km
  const dLat = (pos2.lat - pos1.lat) * Math.PI / 180;
  const dLon = (pos2.lng - pos1.lng) * Math.PI / 180;
  const a = Math.sin(dLat/2) * Math.sin(dLat/2) + Math.cos(pos1.lat * Math.PI / 180) * Math.cos(pos2.lat * Math.PI / 180) * Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

// Funﾃｧﾃ｣o auxiliar para compatibilidade
function getDistance(point1, point2) {
  if (!point1 || !point2) return 0;
  return haversine(point1, point2); 
  // ou: return await getSmartDistance(point1, point2, false);
}

function showToast(message, type = 'info') {
  const toast = document.getElementById('toast');
  const toastMessage = document.getElementById('toastMessage');
  const toastIcon = document.getElementById('toastIcon');
  
  const icons = {
    info: 'fa-info-circle',
    success: 'fa-check-circle',
    warn: 'fa-exclamation-triangle',
    error: 'fa-times-circle'
  };
  toastIcon.className = `fas ${icons[type]} mr-3`;
  
  toastMessage.textContent = message;
  toast.classList.add('show');
  
  setTimeout(() => { toast.classList.remove('show'); }, 3000);
}

function showConfirmModal(title, message) {
  return new Promise((resolve) => {
    const modal = document.getElementById('confirmModal');
    document.getElementById('confirmTitle').textContent = title;
    document.getElementById('confirmMessage').innerHTML = message; // Usamos innerHTML para permitir quebras de linha com   


    modal.classList.remove('hidden');

    const okBtn = document.getElementById('confirmOkBtn');
    const cancelBtn = document.getElementById('confirmCancelBtn');

    const close = (decision) => {
      modal.classList.add('hidden');
      // Remove os event listeners para evitar mﾃｺltiplos cliques em futuras chamadas
      okBtn.onclick = null;
      cancelBtn.onclick = null;
      resolve(decision);
    };

    okBtn.onclick = () => close(true);
    cancelBtn.onclick = () => close(false);
  });
}

// =================================================================================
// EVENT LISTENERS
// =================================================================================
// Listener para abrir o modal de configuraﾃｧﾃｵes
document.getElementById("settingsBtn").addEventListener("click", () => {
  // Carrega as configuraﾃｧﾃｵes salvas antes de mostrar
  document.getElementById('navAppSelect').value = localStorage.getItem('navApp') || 'google';
  document.getElementById('autoZoomToggle').checked = (localStorage.getItem('autoZoom') !== 'false');
  
  document.getElementById('settingsModal').classList.remove('hidden');
  syncReturnToStartToggle();
});

// Listener para fechar o modal de configuraﾃｧﾃｵes
document.getElementById("closeSettingsBtn").addEventListener("click", () => {
  document.getElementById('settingsModal').classList.add('hidden');
});

// Listeners para salvar as configuraﾃｧﾃｵes quando elas mudam
document.getElementById('navAppSelect').addEventListener('change', (e) => {
  localStorage.setItem('navApp', e.target.value);
  showToast('Aplicativo de navegaﾃｧﾃ｣o salvo!', 'success');
});

document.getElementById('autoZoomToggle').addEventListener('change', (e) => {
  localStorage.setItem('autoZoom', e.target.checked);
  showToast(`Zoom automﾃ｡tico ${e.target.checked ? 'ativado' : 'desativado'}.`, 'success');
});

document.getElementById("menuToggleBtn").addEventListener("click", () => toggleMenu(true));
document.getElementById("closeMenuBtn").addEventListener("click", () => toggleMenu(false));
document.getElementById("menuOverlay").addEventListener("click", () => toggleMenu(false));

document.getElementById("loadNewFileBtn").addEventListener("click", async () => {
    // --- SOLUﾃﾃグ: FECHA O MENU ANTES DE MOSTRAR O MODAL ---
    toggleMenu(false); 
    
    // Pequeno delay para garantir que a animaﾃｧﾃ｣o de fechar o menu comece
    await delay(100); 

    const confirmed = await showConfirmModal(
        "圷 Recomeﾃｧar Rota",
        "Tem certeza que deseja carregar um novo arquivo? Todos os dados da rota atual serﾃ｣o perdidos e o sistema serﾃ｡ reiniciado."
    );

    if (confirmed) {
        showToast('売 Reiniciando sistema...', 'info');
        clearState();
    }
});

// --- OUVINTES DE EVENTOS CORRETOS PARA OS BOTﾃ髭S FLUTUANTES ---
document.getElementById('reOptimizeBtn').addEventListener('click', reOptimizeFromCurrentLocation);

document.getElementById('centerUserBtn').addEventListener('click', () => {
    if (userLocation) {
        map.setView(userLocation, 16);
        showToast('桃 Centralizado na sua localizaﾃｧﾃ｣o', 'info');
    } else {
        showToast('Localizaﾃｧﾃ｣o nﾃ｣o disponﾃｭvel', 'warn');
    }
});

// Funﾃｧﾃｵes para controlar o modal de progresso
function showProgressModal(text) {
  document.getElementById('progressText').textContent = text;
  document.getElementById('progressModal').classList.remove('hidden');
}

function hideProgressModal() {
  document.getElementById('progressModal').classList.add('hidden');
}

// --- Botﾃ｣o de tela cheia ---
document.getElementById("fullscreenBtn").addEventListener("click", () => {
  if (!document.fullscreenElement) {
    document.documentElement.requestFullscreen().catch(err => {
      showToast(`Erro ao ativar tela cheia: ${err.message}`, "error");
    });
  } else {
    document.exitFullscreen();
  }
});

// Funﾃｧﾃ｣o para sincronizar a aparﾃｪncia do switch com o tema atual
function syncThemeSwitch() {
  const html = document.documentElement;
  const toggle = document.getElementById('themeToggleSwitch');
  const knob = toggle.querySelector('span[aria-hidden="true"]');

  if (html.classList.contains('dark')) {
    toggle.classList.remove('bg-gray-200');
    toggle.classList.add('bg-indigo-600');
    knob.classList.remove('translate-x-0');
    knob.classList.add('translate-x-5');
    toggle.setAttribute('aria-checked', 'true');
  } else {
    toggle.classList.remove('bg-indigo-600');
    toggle.classList.add('bg-gray-200');
    knob.classList.remove('translate-x-5');
    knob.classList.add('translate-x-0');
    toggle.setAttribute('aria-checked', 'false');
  }
}

// Listener para o novo switch de tema
document.getElementById("themeToggleSwitch").addEventListener("click", () => {
  const html = document.documentElement;
  if (html.classList.contains("dark")) {
    html.classList.remove("dark");
    localStorage.setItem("theme", "light");
    showToast("笘ｸ Tema claro ativado", "info");
  } else {
    html.classList.add("dark");
    localStorage.setItem("theme", "dark");
    showToast("嫌 Tema escuro ativado", "info");
  }
  syncThemeSwitch(); // Sincroniza o visual do switch apﾃｳs a mudanﾃｧa
});

// Restaurar tema e sincronizar switch ao carregar a pﾃ｡gina
if (localStorage.getItem("theme") === "dark") {
  document.documentElement.classList.add("dark");
}
// Chama a sincronizaﾃｧﾃ｣o apﾃｳs um pequeno delay para garantir que tudo foi carregado
document.addEventListener('DOMContentLoaded', () => {
    setTimeout(syncThemeSwitch, 100);
});

// --- NOVOS LISTENERS PARA AS NOVAS CONFIGURAﾃﾃ髭S ---
document.getElementById("settingsBtn").addEventListener("click", () => {
  // Carrega as configuraﾃｧﾃｵes salvas antes de mostrar
  document.getElementById('navAppSelect').value = localStorage.getItem('navApp') || 'google';
  document.getElementById('serviceTimeInput').value = localStorage.getItem('serviceTime') || '5';
  document.getElementById('mapThemeSelect').value = localStorage.getItem('mapTheme') || 'voyager';
  syncThemeSwitch();
  
  document.getElementById('settingsModal').classList.remove('hidden');
});

document.getElementById('serviceTimeInput').addEventListener('input', (e) => {
  localStorage.setItem('serviceTime', e.target.value);
  // Nﾃ｣o precisa de toast para nﾃ｣o poluir a tela a cada dﾃｭgito
});

document.getElementById('mapThemeSelect').addEventListener('change', (e) => {
  localStorage.setItem('mapTheme', e.target.value);
  updateMapTheme(); // Chama a nova funﾃｧﾃ｣o para trocar o tema do mapa
  showToast('Tema do mapa atualizado!', 'success');
});

// Funﾃｧﾃ｣o para sincronizar o toggle de retorno
function syncReturnToStartToggle() {
  const useReturn = localStorage.getItem('useReturnToStart') === 'true';
  const toggle = document.getElementById('returnToStartToggle');
  const knob = toggle.querySelector('span[aria-hidden="true"]');

  if (useReturn) {
    toggle.classList.remove('bg-gray-200');
    toggle.classList.add('bg-indigo-600');
    knob.classList.remove('translate-x-0');
    knob.classList.add('translate-x-5');
  } else {
    toggle.classList.remove('bg-indigo-600');
    toggle.classList.add('bg-gray-200');
    knob.classList.remove('translate-x-5');
    knob.classList.add('translate-x-0');
  }
  toggle.setAttribute('aria-checked', useReturn);
}

// Listener para o novo toggle
document.getElementById('returnToStartToggle').addEventListener('click', () => {
  const useReturn = localStorage.getItem('useReturnToStart') === 'true';
  localStorage.setItem('useReturnToStart', !useReturn);
  syncReturnToStartToggle();
  showToast(`Retorno ao ponto inicial ${!useReturn ? 'ativado' : 'desativado'}.`, 'info');
});


const sideMenu = document.getElementById('sideMenu');
const menuOverlay = document.getElementById('menuOverlay');

function openMenu() {
  sideMenu.classList.remove('hidden', '-translate-x-full');
  menuOverlay.classList.remove('hidden');
}

function closeMenu() {
  sideMenu.classList.add('-translate-x-full');
  menuOverlay.classList.add('hidden');
}

menuOverlay.addEventListener('click', closeMenu);
document.getElementById('closeMenuBtn')?.addEventListener('click', closeMenu);


// Fechar o settingsModal ao clicar fora (apenas no fundo escuro)
document.getElementById('settingsModal').addEventListener('click', (e) => {
  if (e.target === document.getElementById('settingsModal')) {
    document.getElementById('settingsModal').classList.add('hidden');
  }
});

// Botﾃ｣o fechar jﾃ｡ existente continua funcionando
document.getElementById('closeSettingsBtn')?.addEventListener('click', () => {
  document.getElementById('settingsModal').classList.add('hidden');
});

</script>
</body>
</html>
