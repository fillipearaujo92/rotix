<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Rotix - Otimizador de Rotas</title>
  <link rel="icon" type="image/png" href="img/favicon.png">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"/>
  <style>
    :root { --rotix-blue: #5e33ea; }
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap' );
    body { font-family: 'Inter', sans-serif; }
    #map { height: 100vh; }
    .leaflet-control-zoom, .leaflet-control-attribution { display: none !important; }
    .leaflet-popup-content-wrapper { border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
    .leaflet-popup-content { margin: 15px; font-size: 14px; line-height: 1.6; }
    .leaflet-popup-content b { font-weight: 600; }
    .leaflet-popup-content small { color: #555; }
    .leaflet-popup-tip { box-shadow: none; }

    .toast {
      position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
      background: rgba(20, 20, 20, 0.85); backdrop-filter: blur(5px);
      color: white; padding: 12px 20px; border-radius: 25px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2); z-index: 10001;
      display: none; align-items: center;
      z-index: 9999;
    }
    .toast.show { display: flex; animation: fadeIn 0.3s ease; }
    @keyframes fadeIn { from { opacity: 0; transform: translate(-50%, -20px); } to { opacity: 1; transform: translate(-50%, 0); } }

    .map-floating-btn {
      position: fixed; z-index: 1000; background-color: white;
      width: 48px; height: 48px; border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2); cursor: pointer;
      transition: all 0.2s ease;
    }
    .map-floating-btn:hover { transform: scale(1.05); }
    #menuToggleBtn { top: 20px; left: 20px; }
    #centerUserBtn { bottom: 200px; right: 20px; }
    #reOptimizeBtn { bottom: 260px; right: 20px; background: linear-gradient(135deg, #5e33ea, #8b5cf6); color: white; }
    #sideMenu {
        z-index: 9999;
    }
  </style>
</head>
<body class="bg-gray-100">

  <!-- Toast Notification -->
  <div id="toast" class="toast">
    <i id="toastIcon" class="fas fa-info-circle mr-3"></i>
    <span id="toastMessage"></span>
  </div>

  <!-- Botões Flutuantes do Mapa -->
  <button id="menuToggleBtn" class="map-floating-btn hidden">
    <i class="fas fa-bars text-xl text-gray-700"></i>
  </button>
  <button id="centerUserBtn" class="map-floating-btn hidden">
    <i class="fas fa-location-crosshairs text-xl text-blue-500"></i>
  </button>
  <button id="reOptimizeBtn" class="map-floating-btn hidden" title="Reotimizar Rota a partir da sua localização">
    <i class="fas fa-route text-xl"></i>
  </button>

  <!-- Menu Lateral -->
  <div id="menuOverlay" class="hidden fixed inset-0 bg-black bg-opacity-40 z-4000"></div>
  <div id="sideMenu" class="hidden fixed top-0 left-0 w-full max-w-sm h-full bg-white shadow-2xl z-5000 p-6 overflow-y-auto transform -translate-x-full transition-transform duration-300">
    <div class="flex justify-between items-center mb-6">
      <h4 class="font-semibold text-gray-800 text-lg"><i class="fas fa-list mr-2"></i>Lista de Entregas</h4>
      <button id="closeMenuBtn" class="text-gray-500 hover:text-red-500"><i class="fas fa-times text-xl"></i></button>
    </div>
    
    <div class="mb-6 p-4 bg-red-50 border border-red-200 rounded-lg">
      <h5 class="font-medium text-red-800 mb-2"><i class="fas fa-exclamation-triangle mr-2"></i>Recomeçar Rota</h5>
      <p class="text-sm text-red-600 mb-3">Isso apagará a rota atual e voltará ao início.</p>
      <button id="loadNewFileBtn" class="w-full bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-lg font-medium transition"><i class="fas fa-file-upload mr-2"></i>Carregar Novo Arquivo</button>
    </div>

    <div class="mb-6 p-4 bg-blue-50 border border-blue-200 rounded-lg">
      <h5 class="font-medium text-blue-800 mb-2"><i class="fas fa-cogs mr-2"></i>Configurações de Rota</h5>
      <div class="mb-4">
        <label class="block text-sm font-medium text-gray-700 mb-2">Ponto de Partida:</label>
        <div class="flex items-center mb-2">
          <input type="checkbox" id="useCurrentLocationStart" class="h-4 w-4 text-indigo-600 border-gray-300 rounded"/>
          <label for="useCurrentLocationStart" class="ml-2 block text-sm text-gray-900">Usar localização atual</label>
        </div>
        <textarea id="startAddress" placeholder="Opcional: Digite um endereço de partida" class="w-full p-2 border border-gray-300 rounded-md text-sm" rows="2"></textarea>
        <button id="geocodeStartBtn" class="mt-2 w-full bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded text-sm"><i class="fas fa-search mr-1"></i>Buscar Endereço</button>
      </div>
      <div class="mb-4">
        <label class="block text-sm font-medium text-gray-700 mb-2">Ponto de Término:</label>
        <textarea id="endAddress" placeholder="Opcional: Digite um endereço de término" class="w-full p-2 border border-gray-300 rounded-md text-sm" rows="2"></textarea>
        <button id="geocodeEndBtn" class="mt-2 w-full bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded text-sm"><i class="fas fa-search mr-1"></i>Buscar Endereço</button>
      </div>
      <button id="optimizeInMenuBtn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-2 rounded-lg font-medium transition"><i class="fas fa-route mr-2"></i>Otimizar Rota</button>
    </div>
    
    <div class="mb-6 p-4 bg-indigo-50 border border-indigo-200 rounded-lg">
      <h5 class="font-medium text-indigo-800 mb-2"><i class="fas fa-chart-bar mr-2"></i>Estatísticas</h5>
      <div id="routeStats" class="text-sm text-indigo-700"></div>
    </div>
    
    <div id="routeList"></div>
  </div>

  <!-- Etapa 1: Upload -->
  <div id="step1" class="flex-1 flex flex-col items-center justify-center p-6 min-h-screen">
    <div class="bg-white rounded-2xl shadow-lg p-10 w-full max-w-md text-center">
      <div class="w-20 h-20 mx-auto mb-6 bg-gradient-to-br from-[var(--rotix-blue)] to-purple-600 rounded-3xl flex items-center justify-center">
        <svg class="w-12 h-12 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13v-6m0-6V4a2 2 0 012-2h2a2 2 0 012 2v3m-6 10h6m-6-6h6m6-3l-5.447-2.724A1 1 0 0015 5.618v10.764a1 1 0 001.447.894L21 15m0-8v6m0 6V4a2 2 0 00-2-2h-2a2 2 0 00-2 2v3"></path></svg>
      </div>
      <h1 class="text-4xl font-bold tracking-widest text-gray-800">Rotix</h1>
      <h3 class="text-xs tracking-widest text-gray-500 mb-8">Inteligência em movimento</h3>
      <label for="fileInput" class="cursor-pointer block border-2 border-dashed border-indigo-400 rounded-xl p-10 hover:bg-indigo-50 transition">
        <i class="fas fa-file-excel text-4xl text-indigo-500 mb-4 block"></i>
        <span class="text-indigo-600 font-semibold">Clique ou arraste seu arquivo</span>
        <input type="file" id="fileInput" accept=".xlsx,.xls" class="hidden"/>
      </label>
    </div>
  </div>

  <!-- Etapa 2: Seleção de colunas -->
  <div id="step2" class="hidden flex-1 flex flex-col items-center justify-center p-6 min-h-screen">
    <div class="bg-white rounded-2xl shadow-lg p-8 w-full max-w-md">
      <h2 class="text-xl font-bold text-indigo-600 mb-4"><i class="fas fa-list-check mr-2"></i>Selecione as Informações</h2>
      <p class="text-gray-500 mb-6 text-sm">Escolha os campos que deseja visualizar nos detalhes da entrega.</p>
      <div id="columnsList" class="space-y-3 mb-6 max-h-60 overflow-y-auto"></div>
      <button id="confirmColumnsBtn" class="w-full bg-indigo-600 text-white py-3 rounded-lg font-semibold hover:bg-indigo-700 transition"><i class="fas fa-check mr-2"></i>Confirmar e Otimizar</button>
    </div>
  </div>

  <!-- Etapa 3: Mapa -->
  <div id="step3" class="hidden">
    <div id="map"></div>
    <div id="nextStopBar" class="hidden fixed bottom-0 left-0 right-0 bg-white shadow-[0_-5px_20px_rgba(0,0,0,0.1)] rounded-t-2xl z-[1001] p-4">
  <div class="w-full max-w-4xl mx-auto">
    <div class="flex justify-between items-start mb-3">
      <div id="nextStopInfo" class="text-gray-800 mr-4"></div>
      <button onclick="document.getElementById('nextStopBar').classList.add('hidden')" class="text-gray-400 hover:text-gray-600 flex-shrink-0"><i class="fas fa-times"></i></button>
    </div>
    <div class="grid grid-cols-3 gap-3">
      <button onclick="openNavigation()" class="col-span-1 bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center text-sm"><i class="fas fa-diamond-turn-right mr-2"></i>Navegar</button>
      
      <!-- BOTÕES COM IDs ADICIONADOS -->
      <button id="naoEntregueBtn" onclick="markNext('naoentregue')" class="col-span-1 bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-3 px-4 rounded-lg flex items-center justify-center text-sm">
        <i class="fas fa-box mr-2 text-red-500"></i>
        <span id="naoEntregueText">Não Entregue</span>
      </button>
      <button id="entregueBtn" onclick="markNext('entregue')" class="col-span-1 bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-3 px-4 rounded-lg flex items-center justify-center text-sm">
        <i class="fas fa-check-double mr-2 text-green-500"></i>
        <span id="entregueText">Entregue</span>
      </button>
    </div>
  </div>
</div>

  </div>

<script>
// =================================================================================
// VARIÁVEIS GLOBAIS
// =================================================================================
let deliveryData = [], userLocation = null, map, markers = [], routeLayer, nextDeliveryRouteLayer, userMarker;
let selectedColumns = [];
let startPoint = null;
let endPoint = null;

// =================================================================================
// INICIALIZAÇÃO E GERENCIAMENTO DE ESTADO
// =================================================================================
window.addEventListener('load', () => {
  loadSavedState();
  initGeolocation();
});

function saveState() {
  try {
    const stateToSave = {
      deliveryData: deliveryData,
      selectedColumns: selectedColumns,
      startPoint: startPoint,
      endPoint: endPoint,
      currentStep: getCurrentStep()
    };
    localStorage.setItem('routeOptimizerState', JSON.stringify(stateToSave));
  } catch (e) { console.error('Erro ao salvar estado:', e); }
}

function loadSavedState() {
  const savedState = localStorage.getItem('routeOptimizerState');
  if (!savedState) return;
  try {
    const state = JSON.parse(savedState);
    if (state.currentStep === 'step3' && state.deliveryData?.length > 0) {
      deliveryData = state.deliveryData;
      selectedColumns = state.selectedColumns || [];
      startPoint = state.startPoint;
      endPoint = state.endPoint;
      
      if (startPoint) document.getElementById('startAddress').value = startPoint.address || '';
      if (endPoint) document.getElementById('endAddress').value = endPoint.address || '';

      document.getElementById('step1').classList.add('hidden');
      document.getElementById('step3').classList.remove('hidden');
      
      showMapControls(true);
      initMap();
      updateUI();
      startTracking();
      showToast('Rota anterior restaurada!', 'success');
    }
  } catch (e) {
    console.error('Erro ao carregar estado:', e);
    clearState();
  }
}

function clearState() {
  localStorage.removeItem('routeOptimizerState');
  window.location.reload();
}

function getCurrentStep() {
  if (!document.getElementById('step1').classList.contains('hidden')) return 'step1';
  if (!document.getElementById('step2').classList.contains('hidden')) return 'step2';
  if (!document.getElementById('step3').classList.contains('hidden')) return 'step3';
  return null;
}

// =================================================================================
// UPLOAD DE ARQUIVO E PREPARAÇÃO
// =================================================================================
document.getElementById('fileInput').addEventListener('change', handleFileUpload);

function handleFileUpload(e) {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (event) => {
    try {
      const data = new Uint8Array(event.target.result);
      const workbook = XLSX.read(data, { type: 'array' });
      const sheetName = workbook.SheetNames[0];
      const worksheet = workbook.Sheets[sheetName];
      
      const jsonData = XLSX.utils.sheet_to_json(worksheet, {
        header: 1,
        transformHeader: (header) => header.trim()
      });

      const headers = jsonData.shift();
      const rows = jsonData;

      const cleanJsonData = rows.map(row => {
        const obj = {};
        headers.forEach((header, index) => {
          obj[header] = row[index];
        });
        return obj;
      });

      if (cleanJsonData.length === 0) return showToast('Arquivo vazio ou formato inválido', 'error');

      const firstRowKeys = Object.keys(cleanJsonData[0]);
      const stopHeader = firstRowKeys.find(key => key.toUpperCase() === 'STOP');
      const latHeader = firstRowKeys.find(key => key.toUpperCase() === 'LATITUDE');
      const lngHeader = firstRowKeys.find(key => key.toUpperCase() === 'LONGITUDE');

      if (!latHeader || !lngHeader) {
        return showToast('Arquivo deve conter colunas "Latitude" e "Longitude"', 'error');
      }
      if (!stopHeader) {
        return showToast('Arquivo deve conter uma coluna chamada "STOP"', 'error');
      }

      deliveryData = cleanJsonData.map((row, index) => ({
        ...row,
        Latitude: row[latHeader],
        Longitude: row[lngHeader],
        STOP: row[stopHeader],
        id: index,
        status: "pendente",
      }));
      
      const cols = Object.keys(deliveryData[0]).filter(c => !['id', 'status', 'Latitude', 'Longitude'].includes(c));
      
      const container = document.getElementById("columnsList");
      container.innerHTML = cols.map(c => `
        <label class="flex items-center space-x-3 cursor-pointer hover:bg-gray-50 p-2 rounded-lg">
          <input type="checkbox" value="${c}" class="columnChk h-5 w-5 text-indigo-600 border-gray-300 rounded" ${['Cliente', 'Endereço', 'Destination Address', 'Telefone', 'Observação'].includes(c) ? 'checked' : ''}/>
          <span class="text-gray-700">${c}</span>
        </label>`).join('');

      document.getElementById('step1').classList.add('hidden');
      document.getElementById('step2').classList.remove('hidden');
      showToast(`${deliveryData.length} entregas carregadas!`, 'success');
    } catch (error) {
      console.error('Erro ao processar arquivo:', error);
      showToast('Erro ao processar o arquivo. Verifique o formato.', 'error');
    }
  };
  reader.readAsArrayBuffer(file);
}

document.getElementById('confirmColumnsBtn')?.addEventListener('click', () => {
  selectedColumns = [...document.querySelectorAll(".columnChk:checked")].map(c => c.value);
  document.getElementById('step2').classList.add('hidden');
  document.getElementById('step3').classList.remove('hidden');
  
  showMapControls(true);
  initMap();
  optimizeRoute();
});

// =================================================================================
// GEOLOCALIZAÇÃO E GEOCODIFICAÇÃO (Nominatim/OSM)
// =================================================================================
function initGeolocation() {
    navigator.geolocation.getCurrentPosition(
        pos => { userLocation = { lat: pos.coords.latitude, lng: pos.coords.longitude }; },
        () => { 
            userLocation = { lat: -3.73186, lng: -38.5267 }; // Fallback
            showToast('Usando localização padrão. Permita o acesso para maior precisão.', 'warn');
        }
    );
}

async function geocodeAddress(address) {
  if (!address) return null;
  try {
    const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address )}&countrycodes=br&limit=1`);
    const data = await response.json();
    if (data && data.length > 0) {
      return { lat: parseFloat(data[0].lat), lng: parseFloat(data[0].lon), address: data[0].display_name };
    }
    return null;
  } catch (error) {
    console.error('Erro na geocodificação:', error);
    return null;
  }
}

// =================================================================================
// OTIMIZAÇÃO E ROTEAMENTO (OSRM)
// =================================================================================
function optimizeRoute() {
  if (deliveryData.length === 0) return showToast('Nenhuma entrega para otimizar', 'warn');

  let currentStartPoint = startPoint;
  if (document.getElementById('useCurrentLocationStart').checked && userLocation) {
    currentStartPoint = userLocation;
  }
  if (!currentStartPoint) {
    currentStartPoint = { lat: deliveryData[0].Latitude, lng: deliveryData[0].Longitude };
    showToast('Nenhum ponto de partida definido. Iniciando da primeira entrega.', 'info');
  }

  showToast('Otimizando rota...', 'info');
  deliveryData.forEach(d => d.status = "pendente");

  let unvisited = [...deliveryData];
  let orderedRoute = [];
  let currentPoint = currentStartPoint;

  while (unvisited.length > 0) {
      let nearestIndex = -1;
      let minDistance = Infinity;
      unvisited.forEach((stop, index) => {
          const dist = haversine(currentPoint, {lat: stop.Latitude, lng: stop.Longitude});
          if (dist < minDistance) {
              minDistance = dist;
              nearestIndex = index;
          }
      });
      const nextStop = unvisited.splice(nearestIndex, 1)[0];
      orderedRoute.push(nextStop);
      currentPoint = {lat: nextStop.Latitude, lng: nextStop.Longitude};
  }
  
  deliveryData = orderedRoute.map((d, i) => ({...d, Sequence: i + 1}));
  
  showToast(`Rota otimizada com ${deliveryData.length} entregas!`, 'success');
  saveState();
  updateUI();
  startTracking();
  
  setTimeout(() => {
    if (routeLayer) map.fitBounds(routeLayer.getBounds(), { padding: [50, 50] });
  }, 1000);
}

function reOptimizeFromCurrentLocation() {
  if (!userLocation) {
    return showToast('Localização atual não encontrada. Não é possível otimizar.', 'error');
  }

  const pendingDeliveries = deliveryData.filter(d => d.status === 'pendente');
  if (pendingDeliveries.length < 2) {
    return showToast('Não há entregas pendentes suficientes para reotimizar.', 'info');
  }

  showToast('Reotimizando rota a partir de sua localização...', 'info');

  let unvisited = [...pendingDeliveries];
  let reorderedRoute = [];
  let currentPoint = userLocation;

  while (unvisited.length > 0) {
      let nearestIndex = -1;
      let minDistance = Infinity;
      
      unvisited.forEach((stop, index) => {
          const dist = haversine(currentPoint, {lat: stop.Latitude, lng: stop.Longitude});
          if (dist < minDistance) {
              minDistance = dist;
              nearestIndex = index;
          }
      });
      
      const nextStop = unvisited.splice(nearestIndex, 1)[0];
      reorderedRoute.push(nextStop);
      currentPoint = {lat: nextStop.Latitude, lng: nextStop.Longitude};
  }

  const completedDeliveries = deliveryData.filter(d => d.status !== 'pendente');
  const finalRoute = [...completedDeliveries, ...reorderedRoute];
  deliveryData = finalRoute.map((d, i) => ({...d, Sequence: i + 1 }));

  showToast('Rota reotimizada com sucesso!', 'success');
  saveState();
  updateUI();

  setTimeout(() => {
    if (routeLayer) map.fitBounds(routeLayer.getBounds(), { padding: [50, 50] });
  }, 1000);
}

async function drawRoute(points, options) {
  if (points.length < 2) return null;
  const coords = points.map(p => `${p.lng},${p.lat}`).join(';');
  const url = `https://router.project-osrm.org/route/v1/driving/${coords}?overview=full&geometries=geojson`;
  try {
    const res = await fetch(url );
    const data = await res.json();
    if (data.routes && data.routes.length) {
      return L.geoJSON(data.routes[0].geometry, { style: options.style });
    }
  } catch (error) { console.error('Erro ao desenhar rota OSRM:', error); }
  return null;
}

// =================================================================================
// ATUALIZAÇÃO DA INTERFACE (UI)
// =================================================================================
function initMap() {
  if (!map) {
    map = L.map('map', { zoomControl: false }).setView(userLocation || [-3.73, -38.52], 13);
    L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
      attribution: '&copy; OpenStreetMap &copy; CARTO',
      maxZoom: 19
    } ).addTo(map);
  }
}

function updateUI() {
  if (!map) initMap();
  updateMarkers();
  showNextStop();
  updateStats();
  updateRouteLines();
  updateSideList();
}

async function updateRouteLines() {
    if (routeLayer) map.removeLayer(routeLayer);
    if (nextDeliveryRouteLayer) map.removeLayer(nextDeliveryRouteLayer);

    const allPoints = [
        startPoint || userLocation,
        ...deliveryData.map(d => ({ lat: +d.Latitude, lng: +d.Longitude })),
        ...(endPoint ? [endPoint] : [])
    ].filter(Boolean);

    routeLayer = await drawRoute(allPoints, { style: { color: "#5e33ea", weight: 5, opacity: 0.7 } });
    if (routeLayer) routeLayer.addTo(map);

    const nextDelivery = deliveryData.find(d => d.status === "pendente");
    if (nextDelivery && userLocation) {
        const nextPoints = [userLocation, { lat: +nextDelivery.Latitude, lng: +nextDelivery.Longitude }];
        nextDeliveryRouteLayer = await drawRoute(nextPoints, { style: { color: "#ff6b35", weight: 7, opacity: 0.9, dashArray: '10, 5' } });
        if (nextDeliveryRouteLayer) nextDeliveryRouteLayer.addTo(map);
    }
}

function updateMarkers() {
  if (!map) return;
  markers.forEach(m => m.remove());
  markers = [];
  const next = deliveryData.find(d => d.status === "pendente");

  deliveryData.forEach(d => {
    const isNext = next && d.id === next.id;
    const color = d.status === "entregue" ? "#28a745" : d.status === "naoentregue" ? "#dc3545" : isNext ? "#ff6b35" : "#007bff";
    const size = isNext ? 38 : 30;
    const zIndex = isNext ? 1000 : 500;

    const iconHtml = `<div style="background-color:${color}; color:white; border-radius:50%; width:${size}px; height:${size}px; display:flex; align-items:center; justify-content:center; font-size:14px; font-weight:bold; border: 2px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3);">${d.Sequence}</div>`;
    const marker = L.marker([+d.Latitude, +d.Longitude], {
      icon: L.divIcon({ className: '', html: iconHtml }),
      zIndexOffset: zIndex
    }).addTo(map);

    let popupContent = `<b>Pacote <em>#${d.STOP}</em> (Parada: ${d.Sequence})</b><br>`;
    selectedColumns.forEach(col => {
      if (d[col]) popupContent += `  
<small><b>${col}:</b> ${d[col]}</small><br>`;
    });
    marker.bindPopup(popupContent);
    markers.push(marker);
  });
}

function showNextStop() {
  const next = deliveryData.find(d => d.status === "pendente");
  const nextStopBar = document.getElementById('nextStopBar');
  
  if (!next) {
    nextStopBar.classList.add("hidden");
    const allDone = deliveryData.every(d => d.status !== 'pendente');
    if (allDone && deliveryData.length > 0) showToast("🎉 Rota Concluída!", 'success');
    return;
  }

  const entreguesCount = deliveryData.filter(d => d.status === 'entregue').length;
  const naoEntreguesCount = deliveryData.filter(d => d.status === 'naoentregue').length;
  const total = deliveryData.length;
  
  const endereco = next['Destination Address'] || next['Endereço'] || 'Endereço não disponível';

  let infoHtml = `
    <div>
      <div class="flex justify-between items-center mb-1">
        <h3 class="text-lg font-bold text-gray-800"><span class="text-xs font-light text-gray-600">${entreguesCount + naoEntreguesCount} / ${total} Concluídas</span> <br> Próxima Parada: ${next.Sequence} | Pacote: #${next.STOP}</h3>
      </div>
      <p class="text-sm text-gray-600">${endereco}</p>
    </div>
  `;
  
  document.getElementById('nextStopInfo').innerHTML = infoHtml;

  // --- ATUALIZAÇÃO DOS BOTÕES ---
  document.getElementById('entregueText').textContent = `Entregue (${entreguesCount})`;
  document.getElementById('naoEntregueText').textContent = `Não Entregue (${naoEntreguesCount})`;
  // --- FIM DA ATUALIZAÇÃO ---

  nextStopBar.classList.remove("hidden");
}

function markNext(status) {
  const next = deliveryData.find(d => d.status === "pendente");
  if (next) {
    next.status = status;
    const messages = {
      'entregue': { text: '✅ Entrega Realizada!', type: 'success' },
      'naoentregue': { text: '❌ Entrega Não Realizada', type: 'warn' }
    };
    if (messages[status]) {
        showToast(messages[status].text, messages[status].type);
    }
    
    // --- ATUALIZAÇÃO DOS CONTADORES APÓS O CLIQUE ---
    const entreguesCount = deliveryData.filter(d => d.status === 'entregue').length;
    const naoEntreguesCount = deliveryData.filter(d => d.status === 'naoentregue').length;
    document.getElementById('entregueText').textContent = `Entregue (${entreguesCount})`;
    document.getElementById('naoEntregueText').textContent = `Não Entregue (${naoEntreguesCount})`;
    // --- FIM DA ATUALIZAÇÃO ---

    saveState();
    // A função updateUI() já chama showNextStop(), então a atualização é garantida.
    updateUI();
  }
}



function updateStats() {
  const total = deliveryData.length;
  const entregues = deliveryData.filter(d => d.status === 'entregue').length;
  const naoEntregues = deliveryData.filter(d => d.status === 'naoentregue').length;
  const pendentes = total - entregues - naoEntregues;
  const progress = total > 0 ? Math.round(((entregues + naoEntregues) / total) * 100) : 0;
  
  document.getElementById('routeStats').innerHTML = `
    <div class="space-y-2">
      <div class="flex justify-between"><span>Total:</span><span class="font-semibold">${total}</span></div>
      <div class="flex justify-between text-green-600"><span>Entregues:</span><span class="font-semibold">${entregues}</span></div>
      <div class="flex justify-between text-red-600"><span>Não Entregues:</span><span class="font-semibold">${naoEntregues}</span></div>
      <div class="flex justify-between text-yellow-600"><span>Pendentes:</span><span class="font-semibold">${pendentes}</span></div>
      <div class="mt-3 pt-2 border-t border-indigo-200">
        <div class="flex justify-between mb-1"><span class="text-sm font-medium">Progresso:</span><span class="text-sm font-semibold">${progress}%</span></div>
        <div class="w-full bg-gray-200 rounded-full h-2.5"><div class="bg-indigo-600 h-2.5 rounded-full" style="width: ${progress}%"></div></div>
      </div>
    </div>`;
}

function updateSideList() {
    document.getElementById('routeList').innerHTML = deliveryData.map(d => {
        const statusConfig = {
            entregue: { bg: 'bg-green-50 border-green-200', text: 'text-green-700', icon: 'fa-check-circle' },
            naoentregue: { bg: 'bg-red-50 border-red-200', text: 'text-red-700', icon: 'fa-times-circle' },
            pendente: { bg: 'bg-yellow-50 border-yellow-200', text: 'text-yellow-700', icon: 'fa-clock' }
        };
        const config = statusConfig[d.status] || statusConfig.pendente;
        
        // CORREÇÃO: Procura por 'Destination Address' ou 'Endereço'
        const endereco = d['Destination Address'] || d['Endereço'] || 'Sem endereço';

        return `
          <div class="p-3 rounded-lg mb-2 border ${config.bg} flex justify-between items-center">
            <div class="flex items-center space-x-3 overflow-hidden">
              <div class="w-10 h-10 bg-indigo-600 text-white rounded-full flex items-center justify-center text-base font-bold flex-shrink-0" title="Parada Otimizada ${d.Sequence}">
                ${d.Sequence}
              </div>
              <div>
                <span class="text-sm font-semibold text-gray-800 truncate block">Parada ${d.Sequence} | Pacote: #${d.STOP}</span>
                <span class="text-xs text-gray-500 truncate block">${endereco}</span>
              </div>
            </div>
            <div class="flex items-center space-x-2 flex-shrink-0">
              <i class="fas ${config.icon} ${config.text}"></i>
              <span class="${config.text} font-medium capitalize text-xs">${d.status.replace('naoentregue', 'não entregue')}</span>
            </div>
          </div>`;
    }).join('');
}



// =================================================================================
// AÇÕES DO USUÁRIO E EVENTOS
// =================================================================================
function markNext(status) {
  const next = deliveryData.find(d => d.status === "pendente");
  if (next) {
    next.status = status;
    const messages = {
      'entregue': { text: '✅ Entrega Realizada!', type: 'success' },
      'naoentregue': { text: '❌ Entrega Não Realizada', type: 'warn' }
    };
    if (messages[status]) {
        showToast(messages[status].text, messages[status].type);
    }
    saveState();
    updateUI();
  }
}

function openNavigation() {
    const next = deliveryData.find(d => d.status === "pendente");
    if (next) {
        const url = `https://www.google.com/maps/dir/?api=1&destination=${next.Latitude},${next.Longitude}`;
        window.open(url, '_blank' );
    }
}

function startTracking() {
  if (!navigator.geolocation) return;
  const watchOptions = { enableHighAccuracy: true, timeout: 10000, maximumAge: 5000 };

  navigator.geolocation.watchPosition(pos => {
    userLocation = { lat: pos.coords.latitude, lng: pos.coords.longitude };
    if (!userMarker) {
      const pulseIcon = L.divIcon({
        className: "",
        html: `<div class="relative"><div class="w-6 h-6 bg-blue-500 rounded-full border-4 border-white shadow-md"></div><div class="absolute inset-0 rounded-full bg-blue-400 opacity-50 animate-ping"></div></div>`
      });
      userMarker = L.marker([userLocation.lat, userLocation.lng], { icon: pulseIcon }).addTo(map).bindPopup("📍 Você está aqui");
    } else {
      userMarker.setLatLng([userLocation.lat, userLocation.lng]);
    }
    updateRouteLines();

    const nextDelivery = deliveryData.find(d => d.status === "pendente");
    if (nextDelivery) {
      const distanceToNext = haversine(userLocation, { lat: +nextDelivery.Latitude, lng: +nextDelivery.Longitude });
      if (distanceToNext < 0.5) { // Zoom automático a menos de 500m
        const bounds = L.latLngBounds([userLocation, { lat: +nextDelivery.Latitude, lng: +nextDelivery.Longitude }]);
        map.fitBounds(bounds, { padding: [80, 80], maxZoom: 17 });
      }
    }
  }, () => { showToast("Não foi possível obter sua localização em tempo real.", "error"); }, watchOptions);
}

function showMapControls(show) {
    const visibility = show ? 'remove' : 'add';
    document.getElementById('menuToggleBtn').classList[visibility]('hidden');
    document.getElementById('centerUserBtn').classList[visibility]('hidden');
    document.getElementById('reOptimizeBtn').classList[visibility]('hidden');
}

function toggleMenu(force = null) {
  const sideMenu = document.getElementById("sideMenu");
  const menuOverlay = document.getElementById("menuOverlay");
  const optimizeInMenuBtn = document.getElementById("optimizeInMenuBtn");
  const isOpen = !sideMenu.classList.contains("hidden");
  const shouldOpen = force !== null ? force : !isOpen;
  if (shouldOpen) {
    sideMenu.classList.remove("hidden");
    menuOverlay.classList.remove("hidden");
    setTimeout(() => sideMenu.classList.remove("-translate-x-full"), 10);
    optimizeInMenuBtn.classList.remove('hidden');
  } else {
    sideMenu.classList.add("-translate-x-full");
    menuOverlay.classList.add("hidden");
    setTimeout(() => sideMenu.classList.add("hidden"), 300);
  }
}

// =================================================================================
// FUNÇÕES UTILITÁRIAS
// =================================================================================
function haversine(pos1, pos2) {
  const R = 6371; // Raio da Terra em km
  const dLat = (pos2.lat - pos1.lat) * Math.PI / 180;
  const dLon = (pos2.lng - pos1.lng) * Math.PI / 180;
  const a = Math.sin(dLat/2) * Math.sin(dLat/2) + Math.cos(pos1.lat * Math.PI / 180) * Math.cos(pos2.lat * Math.PI / 180) * Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

function showToast(message, type = 'info') {
  const toast = document.getElementById('toast');
  const toastMessage = document.getElementById('toastMessage');
  const toastIcon = document.getElementById('toastIcon');
  
  const icons = {
    info: 'fa-info-circle',
    success: 'fa-check-circle',
    warn: 'fa-exclamation-triangle',
    error: 'fa-times-circle'
  };
  toastIcon.className = `fas ${icons[type]} mr-3`;
  
  toastMessage.textContent = message;
  toast.classList.add('show');
  
  setTimeout(() => { toast.classList.remove('show'); }, 3000);
}

// =================================================================================
// EVENT LISTENERS
// =================================================================================
document.getElementById("menuToggleBtn").addEventListener("click", () => toggleMenu());
document.getElementById("closeMenuBtn").addEventListener("click", () => toggleMenu(false));
document.getElementById("menuOverlay").addEventListener("click", () => toggleMenu(false));
document.getElementById("loadNewFileBtn").addEventListener("click", () => {
    if (confirm('Tem certeza que deseja recomeçar? Todos os dados da rota atual serão perdidos.')) {
        clearState();
    }
});
document.getElementById("optimizeInMenuBtn").addEventListener("click", () => {
    toggleMenu(false);
    optimizeRoute();
});
document.getElementById('reOptimizeBtn').addEventListener('click', reOptimizeFromCurrentLocation);
document.getElementById('centerUserBtn').addEventListener('click', () => {
    if (userLocation) map.setView(userLocation, 16);
});

async function setupPoint(type) {
    const addressInput = document.getElementById(`${type}Address`);
    showToast('Buscando endereço...', 'info');
    const result = await geocodeAddress(addressInput.value.trim());
    
    if (result) {
        if (type === 'start') startPoint = result;
        else endPoint = result;
        addressInput.value = result.address;
        showToast('Endereço encontrado!', 'success');
        saveState();
    } else {
        showToast('Endereço não encontrado.', 'error');
    }
}

document.getElementById('geocodeStartBtn').addEventListener('click', () => setupPoint('start'));
document.getElementById('geocodeEndBtn').addEventListener('click', () => setupPoint('end'));

document.getElementById('useCurrentLocationStart').addEventListener('change', (e) => {
  if (e.target.checked && userLocation) {
    startPoint = { ...userLocation, address: 'Localização Atual' };
    document.getElementById('startAddress').value = 'Localização Atual';
    saveState();
  } else {
      startPoint = null;
      document.getElementById('startAddress').value = '';
      saveState();
  }
});

</script>
</body>
</html>
